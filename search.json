[{"title":"原博客地址","url":"/2020/11/30/%E5%8E%9F%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80/","content":"<p><a href=\"https://blog.csdn.net/jvruo_shabi?spm=1000.2115.3001.5113\">https://blog.csdn.net/jvruo_shabi?spm=1000.2115.3001.5113</a></p>\n","categories":["杂文"],"tags":["blog"]},{"title":"luogu-P5331","url":"/2021/05/08/luogu-P5331/","content":"<p>我tm，调了一整天终于A了/px/px/px</p>\n<p>好久没写主席树手生了啊/kk</p>\n<span id=\"more\"></span>\n<p>费用流。建立超级源 $s$ 以及超级汇 $t$。对于每个哨站建立两个点 $i$ 和 $i^{\\prime}$，从 $s$ 向 $i$ 连一条容量为 $1$，费用为 $0$ 的边，表示一个哨站只用连一次。从 $i$ 向 $t$ 连一条容量为 $1$，费用为 $w$ 的边，代表直接连到控制中心。从 $i^{\\prime}$ 向 $t$ 连一条容量为 $1$，费用为 $0$ 的边，代表每个哨站只能被后面的至多一个哨站连接。从 $i$ 向 $j^{\\prime}(j&lt;i)$连一条容量为 $1$，费用为 $\\lvert a_i-a_j\\rvert$，代表连向之前的点。</p>\n<p>$1000$ 个点 $10^6$ 条边，凭着信仰交了一发，发现<del>只有</del>90pts（</p>\n<p><del>？暴力90pts考试谁还会想正解啊</del></p>\n<p>瓶颈在于每个点向之前的点连边。相当于 $i$ 向 $[1,i-1]$ 连边，且流量固定，费用为一个绝对值的式子。</p>\n<p>看到绝对值按照套路拆开，建立权值线段树然后线段树优化建图？</p>\n<p>嗯好像很可做的样子。</p>\n<p>但是 $a_i$ 达到了 $10^9$，$\\log 10^9$有 $30$，而分类讨论绝对值有个 $2$ 的常数，乘一下 $60$，暴力连边倒还有个除以二的常数。。。这和暴力差不多了啊。。。</p>\n<p>所以先离散化一下 $a$ 数组是必须的。$2\\times \\log 10^9\\approx 18$，这下就可以把暴力的 $150$ 吊起来打了。</p>\n<p>那么讲一下如何线段树优化建图。</p>\n<p>由于我们建的是权值线段树，所以 $i$ 可以拆分为两个边权分别为 $a_i-a_j$ 与 $a_j-a_i$ 的区间 $[1,a_i],[a_i+1,\\infty]$。对于两种情况分别建一棵权值线段树。从表示去区间 $[i,i]$ 的叶子节点向 $a_j=i$ 的点 $j^{\\prime}$ 连一条容量为 INF，费用为 $0$ 的边。</p>\n<p>点 $i$ 分别向两个区间连边，对于到线段树上一点的连边，边权为 $\\pm a_i$ 。</p>\n<p>但是 $i$ 只能向之前的点连边，所以我们把线段树换成主席树搞一搞就好了。</p>\n<p>好久没写主席树了，写完了各种锅，自闭了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">1e15</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">abs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> k)</span> </span>&#123;<span class=\"keyword\">return</span> k &gt;= <span class=\"number\">0</span> ? k : -k;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> to, nxt, cap, cost;</span><br><span class=\"line\">&#125; e[<span class=\"number\">2000005</span>];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> v, id;</span><br><span class=\"line\">\t<span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> Node a) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> v &lt; a.v;&#125;</span><br><span class=\"line\">&#125; b[<span class=\"number\">1005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> head[<span class=\"number\">50005</span>], dis[<span class=\"number\">50005</span>], cur[<span class=\"number\">50005</span>], a[<span class=\"number\">1005</span>], tot = <span class=\"number\">1</span>, tot2, n, s, t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ls[<span class=\"number\">50005</span>], rs[<span class=\"number\">50005</span>], root1[<span class=\"number\">50005</span>], root2[<span class=\"number\">50005</span>], val[<span class=\"number\">1005</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[<span class=\"number\">50005</span>], mark[<span class=\"number\">50005</span>];</span><br><span class=\"line\">std::queue&lt;<span class=\"keyword\">int</span>&gt; Q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">AddEdge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> v, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> cap, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> cost)</span> </span>&#123;</span><br><span class=\"line\">\te[++ tot].to = v, e[tot].nxt = head[u], head[u] = tot;</span><br><span class=\"line\">\te[tot].cap = cap, e[tot].cost = cost;</span><br><span class=\"line\">\te[++ tot].to = u, e[tot].nxt = head[v], head[v] = tot;</span><br><span class=\"line\">\te[tot].cap = <span class=\"number\">0</span>, e[tot].cost = -cost;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Link</span><span class=\"params\">(<span class=\"keyword\">int</span> O, <span class=\"keyword\">int</span> L, <span class=\"keyword\">int</span> R, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> type)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (type == <span class=\"number\">1</span>) <span class=\"built_in\">AddEdge</span>(p, O, <span class=\"number\">1</span>, val[p]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">AddEdge</span>(p, O, <span class=\"number\">1</span>, -val[p]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= mid &amp;&amp; ls[O]) <span class=\"built_in\">Link</span>(ls[O], L, R, l, mid, p, type);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mid &lt; R &amp;&amp; rs[O]) <span class=\"built_in\">Link</span>(rs[O], L, R, mid + <span class=\"number\">1</span>, r, p, type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> O, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> p, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> type, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (type == <span class=\"number\">1</span>) <span class=\"built_in\">AddEdge</span>(O, p + n, INF, -val[p]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">AddEdge</span>(O, p + n, INF, val[p]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a[p] &lt;= mid) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (rs[root]) <span class=\"built_in\">AddEdge</span>(O, rs[O] = rs[root], INF, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(O, ls[O] = ++ tot2, INF, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(ls[O], l, mid, p, type, ls[root]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ls[root]) <span class=\"built_in\">AddEdge</span>(O, ls[O] = ls[root], INF, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(O, rs[O] = ++ tot2, INF, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(rs[O], mid + <span class=\"number\">1</span>, r, p, type, rs[root]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">spfa</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(cur, head, <span class=\"keyword\">sizeof</span> cur);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dis, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dis);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> vis);</span><br><span class=\"line\">\tdis[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tQ.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (Q.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> u = Q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">\t\tQ.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\tmark[u] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> v = e[i].to;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (e[i].cap &amp;&amp; dis[u] + e[i].cost &lt; dis[v]) &#123;</span><br><span class=\"line\">\t\t\t\tdis[v] = dis[u] + e[i].cost;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!mark[v]) Q.<span class=\"built_in\">push</span>(v), mark[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dis[t] &lt; INF;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> flow)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> flow;</span><br><span class=\"line\">\tvis[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> used = <span class=\"number\">0</span>, tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = cur[u]; i; i = e[i].nxt) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[e[i].to] &amp;&amp; dis[u] + e[i].cost == dis[e[i].to] &amp;&amp; e[i].cap) &#123;</span><br><span class=\"line\">\t\t\ttmp = <span class=\"built_in\">dfs</span>(e[i].to, <span class=\"built_in\">min</span>(e[i].cap, flow - used));</span><br><span class=\"line\">\t\t\tused += tmp, e[i].cap -= tmp, e[i ^ <span class=\"number\">1</span>].cap += tmp;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (used == flow) <span class=\"keyword\">return</span> used;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> used;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Dinic</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Maxflow = <span class=\"number\">0</span>, Mincost = <span class=\"number\">0</span>, flow = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">spfa</span>()) Maxflow += (flow = <span class=\"built_in\">dfs</span>(s, INF)), Mincost += dis[t] * flow;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Mincost;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> w, len = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;n, &amp;w);</span><br><span class=\"line\">\ts = <span class=\"number\">0</span>, t = <span class=\"number\">2</span> * n + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, &amp;b[i].v), b[i].id = i;</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(s, i, <span class=\"number\">1</span>, <span class=\"number\">0</span>), <span class=\"built_in\">AddEdge</span>(i, t, <span class=\"number\">1</span>, w);</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(i + n, t, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstd::<span class=\"built_in\">sort</span>(b + <span class=\"number\">1</span>, b + n + <span class=\"number\">1</span>);</span><br><span class=\"line\">\tb[<span class=\"number\">0</span>].v = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (b[i].v != b[i - <span class=\"number\">1</span>].v) ++ len;</span><br><span class=\"line\">\t\ta[b[i].id] = len, val[b[i].id] = b[i].v;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\troot1[<span class=\"number\">0</span>] = <span class=\"number\">2</span> * n + <span class=\"number\">2</span>, root2[<span class=\"number\">0</span>] = tot2 = <span class=\"number\">2</span> * n + <span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class=\"line\">\t\troot1[i] = ++ tot2, root2[i] = ++ tot2;</span><br><span class=\"line\">\t\t<span class=\"built_in\">Link</span>(root1[i - <span class=\"number\">1</span>], <span class=\"number\">1</span>, a[i], <span class=\"number\">1</span>, len, i, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[i] != len) <span class=\"built_in\">Link</span>(root2[i - <span class=\"number\">1</span>], a[i] + <span class=\"number\">1</span>, len, <span class=\"number\">1</span>, len, i, <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(root1[i], <span class=\"number\">1</span>, len, i, <span class=\"number\">1</span>, root1[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(root2[i], <span class=\"number\">1</span>, len, i, <span class=\"number\">2</span>, root2[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, <span class=\"built_in\">Dinic</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["图论"],"tags":["网络流"]},{"title":"题解 【P4768 [NOI2018] 归程】","url":"/2021/05/05/luogu-P4768/","content":"<p>spfa墓前考古并留名。</p>\n<p>谨为我们可爱的spfa，上香，烧纸。</p>\n<span id=\"more\"></span>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/cd4db5a5f8121502558b7886a5a06306.png\" alt=\"\"></p>\n<hr>\n<p>？这啥题，每次跑一遍最短路？</p>\n<p>在这之前需要学习一个叫 kruskal 重构树的东东<del>据说很冷门qaq</del></p>\n<p>什么是 kruskal 重构树呢，回忆一下 kruskal 算法的过程，每当选出一条边，我们是直接将这两个点所在的并查集合并。但在 kruskal 重构树中，是新建一个节点，将这两个端点分别作为这个节点的儿子。</p>\n<p>但是并查集有路径压缩，不能维护树的形态，所以我们还要另外存一下这棵树，然后将这条边的边权作为这个新点的点权。由于我们是求的最小生成树，所以整颗重构树是一个大根堆。</p>\n<p>所以这个题里面怎么搞呢？当然跑一遍 dijkstra 就不说了<del>关于spfa</del></p>\n<p>先求出<strong>对于边的海拔</strong>的最大生成树，维护 kruskal 重构树。初始时每个点点权是 $1$ 到它的最短路，合并时新的点点权就是边的两个端点的根节点的点权取 $\\min$。那么对于每个询问的点 $v$，找到 $v$ 的所有祖先中海拔大于 $p$ 且深度最小的那一个点 $u$，然后答案就是 $u$ 的点权。</p>\n<p>怎么找 $u$ 呢，倍增往上跳就行了。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击显示/隐藏代码</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> std::pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; PII;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> to, nxt, w, a;</span><br><span class=\"line\">&#125; e[<span class=\"number\">800005</span>];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> u, v, w, a;</span><br><span class=\"line\">\t<span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> Node x) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> a &gt; x.a;&#125;<span class=\"comment\">//求海拔的最大生成树</span></span><br><span class=\"line\">&#125; edge[<span class=\"number\">400005</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> done[<span class=\"number\">200005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> head[<span class=\"number\">200005</span>], dis[<span class=\"number\">200005</span>], tot, n, m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> fa[<span class=\"number\">500005</span>], up[<span class=\"number\">500005</span>][<span class=\"number\">20</span>], ans[<span class=\"number\">500005</span>], high[<span class=\"number\">500005</span>];</span><br><span class=\"line\">std::priority_queue&lt;PII, std::vector&lt;PII&gt;, std::greater&lt;PII&gt; &gt; Q;</span><br><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt; sons[<span class=\"number\">500005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;<span class=\"keyword\">return</span> fa[x] == x ? x : fa[x] = <span class=\"built_in\">find</span>(fa[x]);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">AddEdge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> v, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> w, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">\te[++ tot].to = v, e[tot].w = w, e[tot].a = a;</span><br><span class=\"line\">\te[tot].nxt = head[u], head[u] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Dijkstra</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dis, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dis);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(done, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> done);</span><br><span class=\"line\">\tQ.<span class=\"built_in\">push</span>(std::<span class=\"built_in\">make_pair</span>(dis[<span class=\"number\">1</span>] = <span class=\"number\">0</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (Q.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">u</span><span class=\"params\">(Q.top().second)</span></span>;</span><br><span class=\"line\">\t\tQ.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (done[u]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tdone[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(head[u]); i; i = e[i].nxt) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">v</span><span class=\"params\">(e[i].to)</span></span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dis[u] + e[i].w &lt; dis[v])</span><br><span class=\"line\">\t\t\t\tQ.<span class=\"built_in\">push</span>(std::<span class=\"built_in\">make_pair</span>(dis[v] = dis[u] + e[i].w, v));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= <span class=\"number\">19</span>; ++ i) up[u][i] = up[up[u][i - <span class=\"number\">1</span>]][i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> v : sons[u])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v != up[u][<span class=\"number\">0</span>]) up[v][<span class=\"number\">0</span>] = u, <span class=\"built_in\">dfs</span>(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kruskal</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">//重构树的函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(ans, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> ans);</span><br><span class=\"line\">\tstd::<span class=\"built_in\">sort</span>(edge + <span class=\"number\">1</span>, edge + m + <span class=\"number\">1</span>);</span><br><span class=\"line\">\tint cnt(0), k(0), now(n);//k表示当前考虑到了哪条边，cnt表示选了多少边，now表示最后一个新建点的编号</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) ans[i] = dis[i], fa[i] = i;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cnt &lt; n - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t++ k;</span><br><span class=\"line\">\t\tint fx(find(edge[k].u)), fy(find(edge[k].v));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fx != fy) &#123;</span><br><span class=\"line\">\t\t\t++ now, ++ cnt, fa[fx] = fa[fy] = fa[now] = now;</span><br><span class=\"line\">\t\t\tsons[now].<span class=\"built_in\">push_back</span>(fx);<span class=\"comment\">//将x与y并查集中的根节点作为新建点的儿子</span></span><br><span class=\"line\">\t\t\tsons[now].<span class=\"built_in\">push_back</span>(fy);</span><br><span class=\"line\">\t\t\thigh[now] = edge[k].a;<span class=\"comment\">//记录这个点的海拔</span></span><br><span class=\"line\">\t\t\tans[now] = <span class=\"built_in\">min</span>(ans[fx], ans[fy]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(now);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jump</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">19</span>); ~i; -- i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (up[u][i] &amp;&amp; high[up[u][i]] &gt; p) u = up[u][i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans[u];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> T;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;T);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (T --) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(head, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> head);</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(up, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> up);</span><br><span class=\"line\">\t\ttot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> q, k, s, <span class=\"built_in\">last</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= <span class=\"number\">2</span> * n + <span class=\"number\">1</span>; ++ i) sons[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= m; ++ i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> u, v, w, a;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w, &amp;a);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">AddEdge</span>(u, v, w, a), <span class=\"built_in\">AddEdge</span>(v, u, w, a);</span><br><span class=\"line\">\t\t\tedge[i].u = u, edge[i].v = v, edge[i].w = w, edge[i].a = a;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">Dijkstra</span>();<span class=\"comment\">//求最短路</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">kruskal</span>();<span class=\"comment\">//kruskal重构树</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;q, &amp;k, &amp;s);</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (q --) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> v, p;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;v, &amp;p);</span><br><span class=\"line\">\t\t\tv = (v + k * last - <span class=\"number\">1</span>) % n + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tp = (p + k * last) % (s + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, last = <span class=\"built_in\">jump</span>(v, p));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","categories":["图论"],"tags":["最短路","生成树"]},{"title":"题解 【P4313 文理分科】","url":"/2021/05/02/luogu-P4313/","content":"<p>非常神奇的的最小割模型。</p>\n<p>正面建立最大流/费用流模型不好搞，于是考虑最小割，发现有点东西。</p>\n<span id=\"more\"></span>\n<p>建立超级源 $S$ 和超级汇 $T$，分别代表文科和理科。对于每个人 $i$，从 $S$ 到 $i$ 连一条边，边权为第 $i$ 个人选择文科获得的收益。从 $i$ 到 $T$ 连一条边，边权为第 $i$ 个人选择理科获得的收益。</p>\n<p>以上完全是凭直觉建出来的模型，考虑一下它是否正确。显然如果第 $i$ 个人既选了文科又选了理科，一定存在 $S\\rightarrow i\\rightarrow T$ 这条路径从 $S$ 到达 $T$。因此该模型正确。</p>\n<p>现在加入相邻的人同时选择文/理科的收益。直接在这些点之间连边非常不好搞，所以对于每个人新建一个点 ，假设这个人为 $i$，新建的点为 $i^{\\prime}$。那么从 $i^{\\prime}$  向 $i$ 以及所有与第 $i$ 个人相邻的人连一条边权为 $\\infty$ 的边，因为显然这些边不可以割掉。然后从 $S$ 向 $i^{\\prime}$ 连一条边，边权为 $i$ 与它相邻的人同时选文科的收益。同理，从 $i^{\\prime}$ 向 $S$ 连一条边，边权为 $i$ 与它相邻的人同时选理科的收益</p>\n<p>再次考虑新模型的正确性。假设我获得了 $S\\rightarrow i^{\\prime}$ 这条边的收益，即与 $i$ 相邻的人全选了文科。那么只要有一个与 $i$ 相邻的人 $j$ 背叛组织，选择了理科，那么就存在一条 $S\\rightarrow i^{\\prime}\\rightarrow j\\rightarrow T$ 的路径可以从 $S$ 到达 $T$。因为根据假设，$S\\rightarrow i^{\\prime}$ 以及 $j\\rightarrow T$ 这两条边存在，而 $i^{\\prime}\\rightarrow j$ 这条边又是不可以割掉的（边权为INF），所以模型正确。</p>\n<p>把边权换成流量跑 ISAP 就行了。当然你要 Dinic 也可以<del>虽然跑得慢</del></p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击显示/隐藏代码</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">1e9</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> dx[] = &#123;<span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> dy[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> to, nxt, cap;</span><br><span class=\"line\">&#125; e[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> head[<span class=\"number\">100005</span>], cur[<span class=\"number\">100005</span>], dep[<span class=\"number\">100005</span>], num[<span class=\"number\">100005</span>], s, t, tot = <span class=\"number\">1</span>, cnt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ar[<span class=\"number\">105</span>][<span class=\"number\">105</span>], sc[<span class=\"number\">105</span>][<span class=\"number\">105</span>];</span><br><span class=\"line\">std::queue&lt;<span class=\"keyword\">int</span>&gt; Q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">AddEdge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> v, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">\te[++ tot].to = v, e[tot].cap = cap, e[tot].nxt = head[u], head[u] = tot;</span><br><span class=\"line\">\te[++ tot].to = u, e[tot].cap = <span class=\"number\">0</span>, e[tot].nxt = head[v], head[v] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(cur, head, <span class=\"keyword\">sizeof</span> cur);</span><br><span class=\"line\">\tnum[dep[t] = <span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tQ.<span class=\"built_in\">push</span>(t);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (Q.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">u</span><span class=\"params\">(Q.front())</span></span>;</span><br><span class=\"line\">\t\tQ.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(head[u]); i; i = e[i].nxt)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!dep[e[i].to]) ++ num[dep[e[i].to] = dep[u] + <span class=\"number\">1</span>], Q.<span class=\"built_in\">push</span>(e[i].to);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> flow)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> flow;</span><br><span class=\"line\">\tint used(0), tmp(0);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(cur[u]); i; i = e[i].nxt) &#123;</span><br><span class=\"line\">\t\tcur[u] = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (e[i].cap &amp;&amp; dep[u] - <span class=\"number\">1</span> == dep[e[i].to]) &#123;</span><br><span class=\"line\">\t\t\ttmp = <span class=\"built_in\">dfs</span>(e[i].to, <span class=\"built_in\">min</span>(e[i].cap, flow - used));</span><br><span class=\"line\">\t\t\te[i].cap -= tmp, e[i ^ <span class=\"number\">1</span>].cap += tmp, used += tmp;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (used == flow) <span class=\"keyword\">return</span> used;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcur[u] = head[u];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!(-- num[dep[u]])) dep[s] = cnt + <span class=\"number\">2</span>;</span><br><span class=\"line\">\t++ num[++ dep[u]];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> used;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ISAP</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Maxflow</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">bfs</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (dep[s] &lt;= cnt + <span class=\"number\">1</span>) Maxflow += <span class=\"built_in\">dfs</span>(s, INF);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Maxflow;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m, <span class=\"built_in\">ans</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\ts = <span class=\"number\">0</span>, t = (cnt = n * m + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= m; ++ j) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(s, (i - <span class=\"number\">1</span>) * m + j, x), ans += x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= m; ++ j) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>((i - <span class=\"number\">1</span>) * m + j, t, x), ans += x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= m; ++ j) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x, <span class=\"built_in\">u</span>(++ cnt);</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(s, u, x), ans += x;</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(u, (i - <span class=\"number\">1</span>) * m + j, INF);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">k</span>(<span class=\"number\">0</span>); k &lt;= <span class=\"number\">3</span>; ++ k) &#123;</span><br><span class=\"line\">\t\t\tint tx(i + dx[k]), ty(j + dy[k]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tx &lt; <span class=\"number\">1</span> || ty &lt; <span class=\"number\">1</span> || n &lt; tx || m &lt; ty) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">AddEdge</span>(u, (tx - <span class=\"number\">1</span>) * m + ty, INF);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= m; ++ j) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x, <span class=\"built_in\">u</span>(++ cnt);</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(u, t, x), ans += x;</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>((i - <span class=\"number\">1</span>) * m + j, u, INF);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">k</span>(<span class=\"number\">0</span>); k &lt;= <span class=\"number\">3</span>; ++ k) &#123;</span><br><span class=\"line\">\t\t\tint tx(i + dx[k]), ty(j + dy[k]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tx &lt; <span class=\"number\">1</span> || ty &lt; <span class=\"number\">1</span> || n &lt; tx || m &lt; ty) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">AddEdge</span>((tx - <span class=\"number\">1</span>) * m + ty, u, INF);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans - <span class=\"built_in\">ISAP</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","categories":["网络流"],"tags":["最小割"]},{"title":"【题解 nkoj8145 动物巧克力】","url":"/2021/05/02/nkoj-8145/","content":"<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><blockquote>\n<p>给定一个 $n\\times m$ 的矩阵，每个格子有一个数 $c_{i,j}$，如果这个数为 $-1$ 表示这个格子不能选。选出尽量少的连着的格子使其含有至少 $k$ 个互不相同的数。无解输出 $-1$。</p>\n<span id=\"more\"></span>\n<p>$\\texttt{Data Range:}1\\le n\\times m\\le 233,1\\le k\\le 5,1\\le c_{i,j}\\le n\\times m$</p>\n</blockquote>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p>之所以写这篇题解，是因为这个题涉及到一个非常重要的技巧。</p>\n<p>首先如果 $c_{i,j}$ 非常的小，那这就是个朴素的斯坦纳树。</p>\n<p>但是这题 $c_{i,j}$ 很大，怎么办？</p>\n<p>因为我们只要求选出 $k$ 个互不相同的数，所以考虑对这些格子的数进行染色，例如两个格子的数分别是 $2,3$，而数字 $2,3$ 染的颜色相同，那么这两个格子的数被我们认为是相同的。</p>\n<p>染色的方案数是第二类斯特林数，<del>这你不T飞我请你吃火锅（（（</del></p>\n<p>然后文首提到的“非常重要的技巧”就派上用场了——对，就是随机化乱搞！</p>\n<p>其实也不是完全地乱搞，因为手算可得这题单次随机染色得到正解的概率足够支撑我们随机 $200$ 次左右得到最优解。</p>\n<p>我把随机次数选成了 $150$，A了后发现 $125$ 次随机都不行，看来这个 $150$ 次随机在死亡的边缘反复衡跳啊（（（</p>\n<p>考场上的随机次数当然是卡着时间了，所以单次随机的常数特别重要，随机次数加上 $20\\%$ 也会大大提升正确率（</p>\n<p><del>果然乱搞总是和卡常联系在一起的（</del></p>\n<h1 id=\"texttt-Code\"><a href=\"#texttt-Code\" class=\"headerlink\" title=\"$\\texttt{Code}$\"></a>$\\texttt{Code}$</h1><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击显示/隐藏代码</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">1e9</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> dx[] = &#123;<span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> dy[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> f[<span class=\"number\">240</span>][<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">5</span>], c[<span class=\"number\">240</span>][<span class=\"number\">240</span>], rnd[<span class=\"number\">240</span>], n, m, k, ans;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> mark[<span class=\"number\">240</span>];</span><br><span class=\"line\">std::queue&lt;<span class=\"keyword\">int</span>&gt; Q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spfa</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> S)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (Q.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">u</span><span class=\"params\">(Q.front())</span></span>;</span><br><span class=\"line\">\t\tQ.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\tmark[u] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">k</span>(<span class=\"number\">0</span>); k &lt;= <span class=\"number\">3</span>; ++ k) &#123;</span><br><span class=\"line\">\t\t\tint tx(u / m + dx[k]), ty(u % m + dy[k]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tx &lt; <span class=\"number\">0</span> || ty &lt; <span class=\"number\">0</span> || n &lt;= tx || m &lt;= ty) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (c[tx + <span class=\"number\">1</span>][ty + <span class=\"number\">1</span>] == <span class=\"number\">-1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pos</span><span class=\"params\">(tx * m + ty)</span></span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (f[u][S] + <span class=\"number\">1</span> &lt; f[pos][S]) &#123;</span><br><span class=\"line\">\t\t\t\tf[pos][S] = f[u][S] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!mark[pos]) Q.<span class=\"built_in\">push</span>(pos), mark[pos] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Steiner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">S</span>(<span class=\"number\">1</span>); S &lt; <span class=\"number\">1</span> &lt;&lt; k; ++ S) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt; n * m; ++ i)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (c[i / m + <span class=\"number\">1</span>][i % m + <span class=\"number\">1</span>] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">S0</span>(S &amp; S - <span class=\"number\">1</span>); S0; S0 = S0 - <span class=\"number\">1</span> &amp; S)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (f[i][S] &gt; f[i][S0] + f[i][S ^ S0])</span><br><span class=\"line\">\t\t\t\t\t\tf[i][S] = f[i][S0] + f[i][S ^ S0] - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (f[i][S] &lt; INF) Q.<span class=\"built_in\">push</span>(i), mark[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">spfa</span>(S);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">work</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= m; ++ j)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c[i][j] != <span class=\"number\">-1</span>) rnd[c[i][j]] = <span class=\"built_in\">rand</span>() % k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= m; ++ j)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c[i][j] != <span class=\"number\">-1</span>) f[(i - <span class=\"number\">1</span>) * m + j - <span class=\"number\">1</span>][<span class=\"number\">1</span> &lt;&lt; rnd[c[i][j]]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">Steiner</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt; n * m; ++ i) ans = <span class=\"built_in\">min</span>(ans, f[i][(<span class=\"number\">1</span> &lt;&lt; k) - <span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> T;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;T);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (T --) &#123;</span><br><span class=\"line\">\t\tans = INF;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= m; ++ j) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;c[i][j]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= <span class=\"number\">150</span>; ++ i) <span class=\"built_in\">work</span>();</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, ans &lt; INF ? ans : <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","categories":["动态规划"],"tags":["状压DP","随机化"]},{"title":"题解 【P1251 餐巾计划问题】","url":"/2021/04/29/luogu-P1251/","content":"<p>非常神奇的一个trick。</p>\n<p>开始看错题想成了NOI2008的那道志愿者招募，结果写出来过不了样例（（（</p>\n<span id=\"more\"></span>\n<p>这题每天其实分为两个动作，花掉干净的餐巾和洗不干净的餐巾。</p>\n<p>所以拆成两个点，一个是这一天用餐巾的时候（简称消耗点），一个是洗净不干净的餐巾的时候（简称洗净点）。</p>\n<p>从源点向第 $i$ 天的消耗点连边，容量为 $r_i$，费用自然是 $0$。同理，从这一天的洗净点向汇点连边，容量费用同上。</p>\n<p>再从原点向第 $i$ 天开始点连一条容量为 INF，费用为 $p$ 的边，代表买新的餐巾。</p>\n<p>从第 $i$ 天的洗净点向第 $i+1$ 天的洗净点连边，流量为 INF，费用为 $0$，表示这一天不干净的餐巾可以堆到明天。</p>\n<p>从第 $i$ 天的洗净点向第 $i+m$ 天的消耗点连边，流量为 INF，费用为 $f$，表示第 $i$ 天送到快洗部，第 $i+m$ 天洗好了可以直接用。</p>\n<p>从第 $i$ 天的洗净点向第 $i+n$ 天的消耗点连边，流量为 INF，费用为 $s$，表示第 $i$ 天送到慢洗部，第 $i+n$ 天洗好了可以直接用。</p>\n<p>跑个费用流就行了。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击显示/隐藏代码</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">1e9</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> to, nxt, cap, cost;</span><br><span class=\"line\">&#125; e[<span class=\"number\">200005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> head[<span class=\"number\">50005</span>], cur[<span class=\"number\">50005</span>], dis[<span class=\"number\">50005</span>], s, t, tot = <span class=\"number\">1</span>, N;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> mark[<span class=\"number\">50005</span>], vis[<span class=\"number\">50005</span>];</span><br><span class=\"line\">std::queue&lt;<span class=\"keyword\">int</span>&gt; Q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">AddEdge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> v, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> cap, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> cost)</span> </span>&#123;</span><br><span class=\"line\">\te[++ tot].to = v, e[tot].nxt = head[u], head[u] = tot;</span><br><span class=\"line\">\te[tot].cap = cap, e[tot].cost = cost;</span><br><span class=\"line\">\te[++ tot].to = u, e[tot].nxt = head[v], head[v] = tot;</span><br><span class=\"line\">\te[tot].cap = <span class=\"number\">0</span>, e[tot].cost = -cost;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SPFA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(cur, head, <span class=\"keyword\">sizeof</span> cur);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> mark);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dis, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dis);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> vis);</span><br><span class=\"line\">\tdis[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tQ.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (Q.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">u</span><span class=\"params\">(Q.front())</span></span>;</span><br><span class=\"line\">\t\tQ.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\tmark[u] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(head[u]); i; i = e[i].nxt) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">v</span><span class=\"params\">(e[i].to)</span></span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (e[i].cap &amp;&amp; dis[u] + e[i].cost &lt; dis[v]) &#123;</span><br><span class=\"line\">\t\t\t\tdis[v] = dis[u] + e[i].cost;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!mark[v]) Q.<span class=\"built_in\">push</span>(v), mark[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dis[t] &lt;= INF;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> flow)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> flow;</span><br><span class=\"line\">\tvis[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tint used(0), tmp(0);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(cur[u]); i; i = e[i].nxt) &#123;</span><br><span class=\"line\">\t\tcur[u] = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (e[i].cap &amp;&amp; dis[u] + e[i].cost == dis[e[i].to] &amp;&amp; !vis[e[i].to]) &#123;</span><br><span class=\"line\">\t\t\ttmp = <span class=\"built_in\">dfs</span>(e[i].to, <span class=\"built_in\">min</span>(flow - used, e[i].cap));</span><br><span class=\"line\">\t\t\te[i].cap -= tmp, e[i ^ <span class=\"number\">1</span>].cap += tmp, used += tmp;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (used == flow) <span class=\"keyword\">return</span> used;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!used) dis[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> used;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Dinic</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tint Maxflow(0), Mincost(0), flow(0);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">SPFA</span>()) Maxflow += (flow = <span class=\"built_in\">dfs</span>(s, INF)), Mincost += flow * dis[t];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Mincost;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p, m, f, n, s;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, &amp;N);</span><br><span class=\"line\">\ts = <span class=\"number\">0</span>, t = <span class=\"number\">2</span> * N + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= N; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, &amp;x);</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(<span class=\"number\">0</span>, i + N, x, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(i, t, x, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld%lld%lld%lld&quot;</span>, &amp;p, &amp;m, &amp;f, &amp;n, &amp;s);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= N; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(<span class=\"number\">0</span>, i, INF, p);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i &lt; N) <span class=\"built_in\">AddEdge</span>(i + N, i + N + <span class=\"number\">1</span>, INF, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i + m &lt;= N) <span class=\"built_in\">AddEdge</span>(i + N, i + m, INF, f);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i + n &lt;= N) <span class=\"built_in\">AddEdge</span>(i + N, i + n, INF, s);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, <span class=\"built_in\">Dinic</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","categories":["图论"],"tags":["网络流"]},{"title":"题解 【P5934 [清华集训2012]最小生成树】","url":"/2021/04/28/luogu-P5924/","content":"<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><blockquote>\n<p>给你一个 $n$ 个点，$m$ 条边的图，请问至少删除原图上的多少条边，才能使得加入一条从 $u$ 到 $v$ 边权为 $L$ 的边后，该边同时在任意一颗最小生成树和最大生成树上。</p>\n<span id=\"more\"></span>\n<p>$ \\texttt{Data Range:}1\\le n\\le 2\\times 10^4,1\\le m\\le 2\\times 10^5$</p>\n</blockquote>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p>根据 kruskal 算法的原理，一条边权为 $L$ 的边在最小生成树上，必须有将所有边权 $&lt;L$ 的边加入后，$u$ 和 $v$ 仍然不连通。</p>\n<p>那么问题转化为，只考虑边权 $&lt;L$ 的情况下，需要删除多少条的边，使得 $u,v$ 不连通。就是个最小割问题了。最大生成树同理。</p>\n<p>解释一下为什么没有取到等号，因为题目只要求出现在任意一颗 MST 上，而对于 kruskal 而言，排序的时候边权相同的边之间的顺序可以随意（而且如果不能随意，就不能使用 sort 这种不稳定的排序了）。所以为了满足题目的要求，在边权为 $L$ 的，两个端点仍未连通的边中，我们选择题目让我们新加的那条边。</p>\n<p>虽然流量为 $1$ 的图上 Dinic 有优势，<del>但是不管常数多小的 Dinic 仍然被 ISAP 吊起来打</del></p>\n<p><del>不过大多数时候 EK 和 ISAP 差不多</del></p>\n<h1 id=\"texttt-Code\"><a href=\"#texttt-Code\" class=\"headerlink\" title=\"$\\texttt{Code}$\"></a>$\\texttt{Code}$</h1><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击显示/隐藏代码</div></div><div class=\"fold\">\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;queue&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">const int INF &#x3D; 1e9;</span><br><span class=\"line\">inline int min(const int x, const int y) &#123;return x &lt; y ? x : y;&#125;</span><br><span class=\"line\">struct Edge &#123;</span><br><span class=\"line\">\tint to, nxt, cap;</span><br><span class=\"line\">&#125; e[800005];</span><br><span class=\"line\">int head[20005], cur[20005], num[20005], dep[20005], from[200005], to[200005], val[200005];</span><br><span class=\"line\">int tot &#x3D; 1, s, t, n, m;</span><br><span class=\"line\">std::queue&lt;int&gt; Q;</span><br><span class=\"line\">inline void AddEdge(const int u, const int v, const int cap) &#123;</span><br><span class=\"line\">\te[++ tot].to &#x3D; v, e[tot].cap &#x3D; cap, e[tot].nxt &#x3D; head[u], head[u] &#x3D; tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void bfs() &#123;</span><br><span class=\"line\">\tmemset(num, 0, sizeof num);</span><br><span class=\"line\">\tmemset(dep, 0, sizeof dep);</span><br><span class=\"line\">\tmemcpy(cur, head, sizeof cur);</span><br><span class=\"line\">\tQ.push(t);</span><br><span class=\"line\">\tnum[dep[t] &#x3D; 1] &#x3D; 1;</span><br><span class=\"line\">\twhile (Q.size()) &#123;</span><br><span class=\"line\">\t\tint u(Q.front());</span><br><span class=\"line\">\t\tQ.pop();</span><br><span class=\"line\">\t\tfor (int i(head[u]); i; i &#x3D; e[i].nxt)</span><br><span class=\"line\">\t\t\tif (!dep[e[i].to]) ++ num[dep[e[i].to] &#x3D; dep[u] + 1], Q.push(e[i].to);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int dfs(const int u, const int flow) &#123;</span><br><span class=\"line\">\tif (u &#x3D;&#x3D; t) return flow;</span><br><span class=\"line\">\tint used(0), tmp(0);</span><br><span class=\"line\">\tfor (int i(head[u]); i; i &#x3D; e[i].nxt) &#123;</span><br><span class=\"line\">\t\tcur[u] &#x3D; i;</span><br><span class=\"line\">\t\tif (dep[u] - 1 &#x3D;&#x3D; dep[e[i].to] &amp;&amp; e[i].cap) &#123;</span><br><span class=\"line\">\t\t\tif (tmp &#x3D; dfs(e[i].to, min(e[i].cap, flow - used)))</span><br><span class=\"line\">\t\t\t\te[i].cap -&#x3D; tmp, e[i ^ 1].cap +&#x3D; tmp, used +&#x3D; tmp;</span><br><span class=\"line\">\t\t\tif (used &#x3D;&#x3D; flow) return used;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif (!(-- num[dep[u]])) dep[s] &#x3D; n + 1;</span><br><span class=\"line\">\t++ num[++ dep[u]];</span><br><span class=\"line\">\treturn used;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int ISAP() &#123;</span><br><span class=\"line\">\tint Maxflow(0);</span><br><span class=\"line\">\tbfs();</span><br><span class=\"line\">\twhile (dep[s] &amp;&amp; dep[s] &lt;&#x3D; n) Maxflow +&#x3D; dfs(s, INF);</span><br><span class=\"line\">\treturn Maxflow;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tint ans(0), L;</span><br><span class=\"line\">\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class=\"line\">\tfor (int i(1); i &lt;&#x3D; m; ++ i) scanf(&quot;%d%d%d&quot;, from + i, to + i, val + i);</span><br><span class=\"line\">\tscanf(&quot;%d%d%d&quot;, &amp;s, &amp;t, &amp;L);</span><br><span class=\"line\">\tfor (int i(1); i &lt;&#x3D; m; ++ i)</span><br><span class=\"line\">\t\tif (val[i] &lt; L) AddEdge(from[i], to[i], 1), AddEdge(to[i], from[i], 1);</span><br><span class=\"line\">\tans &#x3D; ISAP();</span><br><span class=\"line\">\tmemset(head, 0, sizeof head);</span><br><span class=\"line\">\ttot &#x3D; 1;</span><br><span class=\"line\">\tfor (int i(1); i &lt;&#x3D; m; ++ i)</span><br><span class=\"line\">\t\tif (val[i] &gt; L) AddEdge(from[i], to[i], 1), AddEdge(to[i], from[i], 1);</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;, ans + ISAP());</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</div></div>","categories":["图论"],"tags":["网络流"]},{"title":"题解 【P4452 [国家集训队]航班安排】","url":"/2021/04/27/luogu-P4452/","content":"<p><a href=\"https://www.luogu.com.cn/problem/P4452\">传送门</a></p>\n<p>虽然这题是个套路的费用流，但是作为刚学网络流的蒟蒻还是想了挺久。</p>\n<span id=\"more\"></span>\n<p>一开始我是想的将一个点按照时刻拆成 $T$ 个点，然而先不说能不能做，就这个点数也能直接爆炸。</p>\n<p>但是注意到请求数很少，把请求看做边会发现做不出来而且也是不合理的，于是考虑把每个请求看作一个点，点权为  $c_i$。因为网络流只能在边上搞事情，所以拆一下点。</p>\n<p>接下来就是连边操作。首先建立超级源 $s$ 和超级汇 $t$，如果能够在 $s_i$ 时刻前从起点到达 $a_i$ 就连一条从 $s$ 到这个请求的边，容量 $1\\sim \\infty$ 之间都可以，费用是 $f[1][a_i]$</p>\n<p>同理，如果能在 $T$ 时刻前回到起点就从这个请求连一条到 $t$ 的，容量在 $1\\sim \\infty$ 之间随便取，费用为 $f[b_i][1]$ 的边。</p>\n<p>对于两个请求之间的转移，如果能在处理完 $u$ 请求后紧接着处理 $v$ 请求，连一条 $u\\rightarrow v$，流量 $1\\sim \\infty$ 中随便取，费用为 $f[b_u][a_v]$ 的边。</p>\n<p>对这个图直接跑一边最小费用最大流，把最小费用取个相反数就是答案。</p>\n<p>为什么一定要最大流才是最优解呢？在条件允许的情况下，正常人都会多派几架飞机出去，哪怕不会让答案更优对不对。。。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击显示/隐藏代码</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">1e9</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span><span class=\"keyword\">int</span> x, y;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> to, nxt, cap, cost;</span><br><span class=\"line\">&#125; e[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> head[<span class=\"number\">505</span>], dis[<span class=\"number\">505</span>], cur[<span class=\"number\">505</span>], f[<span class=\"number\">205</span>][<span class=\"number\">205</span>], tme[<span class=\"number\">205</span>][<span class=\"number\">205</span>], tot = <span class=\"number\">1</span>, s, t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">205</span>], b[<span class=\"number\">205</span>], S[<span class=\"number\">205</span>], T[<span class=\"number\">205</span>], c[<span class=\"number\">205</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> mark[<span class=\"number\">505</span>], vis[<span class=\"number\">505</span>];</span><br><span class=\"line\">std::queue&lt;<span class=\"keyword\">int</span>&gt; Q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">AddEdge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> v, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> cap, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> cost)</span> </span>&#123;</span><br><span class=\"line\">\te[++ tot].to = v, e[tot].nxt = head[u], head[u] = tot;</span><br><span class=\"line\">\te[tot].cap = cap, e[tot].cost = cost;</span><br><span class=\"line\">\te[++ tot].to = u, e[tot].nxt = head[v], head[v] = tot;</span><br><span class=\"line\">\te[tot].cap = <span class=\"number\">0</span>, e[tot].cost = -cost;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SPFA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> vis);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dis, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dis);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> mark);</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(cur, head, <span class=\"keyword\">sizeof</span> cur);</span><br><span class=\"line\">\tdis[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tQ.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (Q.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">u</span><span class=\"params\">(Q.front())</span></span>;</span><br><span class=\"line\">\t\tQ.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\tmark[u] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(head[u]); i; i = e[i].nxt) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">v</span><span class=\"params\">(e[i].to)</span></span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (e[i].cap &amp;&amp; dis[u] + e[i].cost &lt; dis[v]) &#123;</span><br><span class=\"line\">\t\t\t\tdis[v] = dis[u] + e[i].cost;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!mark[v]) Q.<span class=\"built_in\">push</span>(v), mark[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dis[t] &lt; INF;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> flow)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> flow;</span><br><span class=\"line\">\tvis[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tint tmp(0), used(0);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(cur[u]); i; i = e[i].nxt) &#123;</span><br><span class=\"line\">\t\tcur[u] = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (e[i].cap &amp;&amp; dis[u] + e[i].cost == dis[e[i].to] &amp;&amp; !vis[e[i].to]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">v</span><span class=\"params\">(e[i].to)</span></span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp = <span class=\"built_in\">dfs</span>(v, <span class=\"built_in\">min</span>(flow - used, e[i].cap))) &#123;</span><br><span class=\"line\">\t\t\t\te[i].cap -= tmp, e[i ^ <span class=\"number\">1</span>].cap += tmp, used += tmp;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (used == flow) <span class=\"keyword\">return</span> used;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!used) dis[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> used;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Dinic</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Mincost</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">SPFA</span>()) Mincost += dis[t] * <span class=\"built_in\">dfs</span>(s, INF);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Mincost;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m, k, ed;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k, &amp;ed);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= n; ++ j) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;tme[i][j]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= n; ++ j) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;f[i][j]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= m; ++ i)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d%d%d&quot;</span>, a + i, b + i, S + i, T + i, c + i), ++ a[i], ++ b[i];</span><br><span class=\"line\">\ts = <span class=\"number\">0</span>, t = <span class=\"number\">2</span> * m + <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= m; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(i + <span class=\"number\">1</span>, i + m + <span class=\"number\">1</span>, <span class=\"number\">1</span>, -c[i]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tme[<span class=\"number\">1</span>][a[i]] &lt;= S[i]) <span class=\"built_in\">AddEdge</span>(<span class=\"number\">1</span>, i + <span class=\"number\">1</span>, <span class=\"number\">1</span>, f[<span class=\"number\">1</span>][a[i]]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (T[i] + tme[b[i]][<span class=\"number\">1</span>] &lt;= ed) <span class=\"built_in\">AddEdge</span>(i + <span class=\"number\">1</span> + m, t, <span class=\"number\">1</span>, f[b[i]][<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= m; ++ j)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i != j &amp;&amp; T[i] + tme[b[i]][a[j]] &lt;= S[j])</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">AddEdge</span>(i + m + <span class=\"number\">1</span>, j + <span class=\"number\">1</span>, <span class=\"number\">1</span>, f[b[i]][a[j]]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">AddEdge</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, k, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, -<span class=\"built_in\">Dinic</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","categories":["图论"],"tags":["网络流"]},{"title":"题解 【P7198 [CTSC2002]玩具兵】","url":"/2021/04/22/luogu-P7198/","content":"<p>u1s1，网上的题解都好简洁啊，蒟蒻表示根本看不懂（</p>\n<span id=\"more\"></span>\n<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><p>题面过于复杂，<a href=\"https://www.luogu.com.cn/problem/P7198\">见题面</a></p>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p>由于只计算使用超能力的次数，所以天兵放哪里无所谓。</p>\n<p>（以下的讨论均不考虑天兵）</p>\n<p>每次交换操作可以看成是交换一个兵的种类，即骑兵变成步兵，步兵变成骑兵。由于步兵和骑兵的数量是相同的，所以一定不会出现不合法的交换。</p>\n<p>然后就可以想到SPFA预处理一下 $dis_{i,j}$ 表示第 $i$ 个兵最少需要用几次超能力才能到第 $j$ 个目标格子。这里把一个需要有 $r$ 个兵进入的格子拆成了 $r$ 个相同的格子，原因后面就会看到。</p>\n<p>由于直接计算答案很麻烦，考虑二分答案 $mid$，对于每个 $dis_{i,j}$，如果它大于 $mid$ 不管，小于等于就加一条 $i$ 到 $j$ 的边。因为我们想要尽可能多的在不加入天兵的干涉时尽可能多的让这些兵到达目标位置，所以对建出来的这个图跑一遍最大匹配即可。假设可以有 $cnt$ 个兵到达互不相同的目标格（这里前面拆格子的作用就体现出来了，因为一个需要多个兵进入的格子在图上实际上是多个点）。假设跑出来的最大匹配是 $cnt$。</p>\n<p>但是我们还没有考虑天兵。这个题有点玩文字游戏的意思，其实想一想会发现天兵的作用就是到达一个目标格然后可以与其它兵交换，即保证了这个问题有解。那么如果二分了一个 $mid$，天兵就可以送 $mid$ 次其它的兵到目标格。注意每次超能力可以交换无限次兵的位置，因为天兵与其它兵的交换和步兵与骑兵的交换是独立的（独立指两次交换不会操作一个相同的兵，如果不独立，那么肯定不是最优解，所以不用管）。最后就得出如果 $cnt+mid\\ge 2\\times k$ 就是可行的一个答案。</p>\n<h1 id=\"texttt-Code\"><a href=\"#texttt-Code\" class=\"headerlink\" title=\"$\\texttt{Code}$\"></a>$\\texttt{Code}$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span><span class=\"keyword\">int</span> x, y;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> dx[] = &#123;<span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> dy[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">std::queue&lt;Node&gt; Q;</span><br><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt; G[<span class=\"number\">105</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> lnk[<span class=\"number\">105</span>], x[<span class=\"number\">105</span>], y[<span class=\"number\">105</span>], dis[<span class=\"number\">105</span>][<span class=\"number\">205</span>], tp[<span class=\"number\">105</span>][<span class=\"number\">105</span>], h[<span class=\"number\">105</span>][<span class=\"number\">105</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> rx[<span class=\"number\">105</span>], ry[<span class=\"number\">105</span>], n, m, k, tot;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[<span class=\"number\">105</span>], mark[<span class=\"number\">105</span>][<span class=\"number\">105</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> v : G[u]) </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[v] &amp;&amp; (vis[v] = <span class=\"literal\">true</span>))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!lnk[v] || <span class=\"built_in\">Find</span>(lnk[v])) <span class=\"keyword\">return</span> lnk[v] = u, <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SPFA</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> sx, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> sy, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> mark);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(tp, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> tp);</span><br><span class=\"line\">\ttp[sx][sy] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tQ.<span class=\"built_in\">push</span>(Node&#123;sx, sy&#125;);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (Q.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">\t\tint x(Q.front().x), y(Q.front().y);</span><br><span class=\"line\">\t\tQ.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\tmark[x][y] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">k</span>(<span class=\"number\">0</span>); k &lt;= <span class=\"number\">3</span>; ++ k) &#123;</span><br><span class=\"line\">\t\t\tint x0(x + dx[k]), y0(y + dy[k]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x0 &lt; <span class=\"number\">1</span> || n &lt; x0 || y0 &lt; <span class=\"number\">1</span> || m &lt; y0) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tint ans(0), tmp((tp[x][y] &amp; 1) ^ d);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (h[x][y] &lt; h[x0][y0] &amp;&amp; tmp) ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (h[x][y] &gt; h[x0][y0] &amp;&amp; !tmp) ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tp[x][y] + ans &lt; tp[x0][y0]) &#123;</span><br><span class=\"line\">\t\t\t\ttp[x0][y0] = tp[x][y] + ans;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!mark[x0][y0])</span><br><span class=\"line\">\t\t\t\t\tQ.<span class=\"built_in\">push</span>(Node&#123;x0, y0&#125;), mark[x0][y0] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> mid)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(lnk, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> lnk);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ans</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= <span class=\"number\">2</span> * k; ++ i) G[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= <span class=\"number\">2</span> * k; ++ i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= <span class=\"number\">2</span> * k; ++ i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= tot; ++ j)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dis[i][j] &lt;= mid) G[i].<span class=\"built_in\">push_back</span>(j);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= <span class=\"number\">2</span> * k; ++ i)</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> vis), ans += <span class=\"built_in\">Find</span>(i);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans + mid &gt;= <span class=\"number\">2</span> * k;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t, <span class=\"built_in\">l</span>(<span class=\"number\">0</span>), r;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k, &amp;t);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= <span class=\"number\">2</span> * k + <span class=\"number\">1</span>; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, x + i, y + i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= t; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x, y, r;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;r);</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (r --) rx[++ tot] = x, ry[tot] = y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= m; ++ j) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;h[i][j]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= <span class=\"number\">2</span> * k; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">SPFA</span>(x[i], y[i], i &gt; k);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= tot; ++ j) dis[i][j] = tp[rx[j]][ry[j]];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr = <span class=\"number\">2</span> * k;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(l + r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(mid)) r = mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, l);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["图论"],"tags":["二分图"]},{"title":"题解 【P3355 骑士共存问题】","url":"/2021/04/20/luogu-P3355/","content":"<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><span id=\"more\"></span>\n<blockquote>\n<p>给你一个 $n\\times n$ 的棋盘，有 $m$ 个点不能放马，求最多能放多少个马使得这些马互不攻击。马不存在蹩马腿一说。</p>\n<p>$\\texttt{Data Range:}1\\le n\\le 200$</p>\n</blockquote>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p><del>第一眼：我会爆搜！！！！11</del></p>\n<p>第二眼：题目都说了是网络流，这题又感觉可以建立二分图模型，如果两个位置不能同时<del>有妈</del>放马就连一条边。问题在于如何对这些点分组使得同一组内的点不会连边。</p>\n<p>观察一匹马会跳到哪些位置。</p>\n<p>容易发现一只位于 $(x,y)$ 的马可以跳到 $(x+1,y+2),(x+2,y+1),(x-1,y+2),(x+2,y-1)…$ 它们都有一个共同点——横纵坐标之和奇偶性和原来不一样！那么按照 $x+y$ 的奇偶性分组即可。</p>\n<p>那么这样分组后按照上文所述方式连边跑跑二分图最大独立集就行了。二分图的最大独立集是点数减去最大匹配边数。如何证明就不展开了。</p>\n<p>然而的跑匈牙利是 $O(n^4)$ 的，所以交上去被卡成90了。匈牙利又不像网络流那么假，所以直接回归Dinic正教就行啦~</p>\n<h1 id=\"texttt-Code\"><a href=\"#texttt-Code\" class=\"headerlink\" title=\"$\\texttt{Code}$\"></a>$\\texttt{Code}$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">1e9</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> dx[] = &#123;<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> dy[] = &#123;<span class=\"number\">-1</span>, <span class=\"number\">-2</span>, <span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> to, cap, nxt;</span><br><span class=\"line\">&#125; e[<span class=\"number\">400005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> head[<span class=\"number\">40005</span>], cur[<span class=\"number\">40005</span>], dis[<span class=\"number\">40005</span>], t, tot = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> ban[<span class=\"number\">40005</span>];</span><br><span class=\"line\">std::queue&lt;<span class=\"keyword\">int</span>&gt; Q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">AddEdge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> v, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">\te[++ tot].to = v, e[tot].cap = cap, e[tot].nxt = head[u], head[u] = tot;</span><br><span class=\"line\">\te[++ tot].to = u, e[tot].cap = <span class=\"number\">0</span>, e[tot].nxt = head[v], head[v] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> dis);</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(cur, head, <span class=\"keyword\">sizeof</span> cur);</span><br><span class=\"line\">\tQ.<span class=\"built_in\">push</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tdis[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (Q.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">u</span><span class=\"params\">(Q.front())</span></span>;</span><br><span class=\"line\">\t\tQ.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(head[u]); i; i = e[i].nxt)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (e[i].cap &amp;&amp; !dis[e[i].to])</span><br><span class=\"line\">\t\t\t\tdis[e[i].to] = dis[u] + <span class=\"number\">1</span>, Q.<span class=\"built_in\">push</span>(e[i].to);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dis[t];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> low)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> low;</span><br><span class=\"line\">\tint res(0), flow(0);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(cur[u]); i; i = e[i].nxt) &#123;</span><br><span class=\"line\">\t\tcur[u] = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (low &amp;&amp; e[i].cap &amp;&amp; dis[u] + <span class=\"number\">1</span> == dis[e[i].to])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (flow = <span class=\"built_in\">dfs</span>(e[i].to, <span class=\"built_in\">min</span>(low, e[i].cap))) &#123;</span><br><span class=\"line\">\t\t\t\tres += flow, low -= flow;</span><br><span class=\"line\">\t\t\t\te[i].cap -= flow, e[i ^ <span class=\"number\">1</span>].cap += flow;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Dinic</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Maxflow</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>()) Maxflow += <span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>, INF);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Maxflow;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\tt = n * n + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= m; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class=\"line\">\t\tban[(x - <span class=\"number\">1</span>) * n + y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= n; ++ j)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((i + j &amp; <span class=\"number\">1</span>) &amp;&amp; !ban[(i - <span class=\"number\">1</span>) * n + j]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pos</span><span class=\"params\">((i - <span class=\"number\">1</span>) * n + j)</span></span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">AddEdge</span>(<span class=\"number\">0</span>, pos, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">k</span>(<span class=\"number\">0</span>); k &lt;= <span class=\"number\">7</span>; ++ k) &#123;</span><br><span class=\"line\">\t\t\t\tconst int tx(i + dx[k]), ty(j + dy[k]);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (tx &lt; <span class=\"number\">1</span> || ty &lt; <span class=\"number\">1</span> || tx &gt; n || ty &gt; n) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (ban[(tx - <span class=\"number\">1</span>) * n + ty]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">AddEdge</span>(pos, (tx - <span class=\"number\">1</span>) * n + ty, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"built_in\">AddEdge</span>((i - <span class=\"number\">1</span>) * n + j, t, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, n * n - m - <span class=\"built_in\">Dinic</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["图论"],"tags":["网络流"]},{"title":"题解 【UVA1658 海军上将 Admiral】","url":"/2021/04/16/UVA-1658/","content":"<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><span id=\"more\"></span>\n<blockquote>\n<p>给你一张 $n$ 个点，$m$ 条边的有向带权图，请选出两条不相交的路线，使得权值总和最小</p>\n<p>$\\texttt{Data Range:}1\\le n\\le 10^3,1\\le m\\le 10^4$</p>\n</blockquote>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p>一眼看上去像是最短路，然而这个数据规模显然不对劲。</p>\n<p>两条路线不相交，也就意味着每条边和每个点只能经过一次。考虑建立费用流模型，对边进行流量限制，对点进行拆点以达到限制点的经过次数的目的。</p>\n<p>把一个点拆成 $i$ 和 $i^{\\prime}$ 两个点，中间连一条流量为 $1$ 费用为 $0$ 的边，代表这个点只能走一次。但注意起点和终点拆点后应该连一条流量为 $2$（或INF）的边。</p>\n<p>对于原图中的边流量都是 $1$，费用就是原图的边权。</p>\n<p>由于要找两条路径，那么需要确保求出来的最大流是 $2$，因此建立超级源点 $s$ （代码中编号为 $0$），向起点 $1$ 连一条流量为 $2$ 费用为 $0$ 的边。</p>\n<p>建立超级汇点 $t$ ，由终点向 $t$ 连一条流量为 $2$ 费用为 $0$ 的边。</p>\n<p>由于题目保证图中至少存在两条不相交的从起点到终点的路径，因此最大流一定是 $2$。所以跑一遍费用流，答案就是最小费用。</p>\n<p>虽然Dinic跑费用流时间复杂度是 $O(nmf)$ 的，<del>但因为这是网络流，所以可以过</del></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">1e9</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> to, nxt, cap, cost;</span><br><span class=\"line\">&#125; e[<span class=\"number\">50005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> head[<span class=\"number\">3005</span>], cur[<span class=\"number\">3005</span>], dis[<span class=\"number\">3005</span>], tot, s, t, n, m;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> mark[<span class=\"number\">3005</span>], vis[<span class=\"number\">3005</span>];</span><br><span class=\"line\">std::queue&lt;<span class=\"keyword\">int</span>&gt; Q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">AddEdge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> v, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> cap, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> cost)</span> </span>&#123;</span><br><span class=\"line\">\te[++ tot].to = v, e[tot].nxt = head[u], head[u] = tot;</span><br><span class=\"line\">\te[tot].cap = cap, e[tot].cost = cost;</span><br><span class=\"line\">\te[++ tot].to = u, e[tot].nxt = head[v], head[v] = tot;</span><br><span class=\"line\">\te[tot].cap = <span class=\"number\">0</span>, e[tot].cost = -cost;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SPFA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(cur, head, <span class=\"keyword\">sizeof</span> cur);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dis, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dis);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> mark);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> vis);</span><br><span class=\"line\">\tdis[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tQ.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (Q.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">u</span><span class=\"params\">(Q.front())</span></span>;</span><br><span class=\"line\">\t\tQ.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\tmark[u] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(head[u]); i; i = e[i].nxt) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">v</span><span class=\"params\">(e[i].to)</span></span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (e[i].cap &amp;&amp; dis[u] + e[i].cost &lt; dis[v]) &#123;</span><br><span class=\"line\">\t\t\t\tdis[v] = dis[u] + e[i].cost;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!mark[v]) Q.<span class=\"built_in\">push</span>(v), mark[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dis[t] &lt;= INF;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> low)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> low;</span><br><span class=\"line\">\tvis[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tint res(0), flow(0);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(cur[u]); i; i = e[i].nxt) &#123;</span><br><span class=\"line\">\t\tcur[u] = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (e[i].cap &amp;&amp; low &amp;&amp; dis[u] + e[i].cost == dis[e[i].to] &amp;&amp; !vis[e[i].to])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (flow = <span class=\"built_in\">dfs</span>(e[i].to, <span class=\"built_in\">min</span>(low, e[i].cap))) &#123;</span><br><span class=\"line\">\t\t\t\te[i].cap -= flow, e[i ^ <span class=\"number\">1</span>].cap += flow;</span><br><span class=\"line\">\t\t\t\tres += flow, low -= flow;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Dinic</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Mincost</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">SPFA</span>()) Mincost += dis[t] * <span class=\"built_in\">dfs</span>(s, INF);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Mincost;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m) == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">\t\ttot = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(head, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> head);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= m; ++ i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> u, v, w;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">AddEdge</span>(<span class=\"number\">2</span> * u, <span class=\"number\">2</span> * v - <span class=\"number\">1</span>, <span class=\"number\">1</span>, w);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">2</span>); i &lt; n; ++ i)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">AddEdge</span>(<span class=\"number\">2</span> * i - <span class=\"number\">1</span>, <span class=\"number\">2</span> * i, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>), <span class=\"built_in\">AddEdge</span>(<span class=\"number\">2</span> * n - <span class=\"number\">1</span>, <span class=\"number\">2</span> * n, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(s = <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(<span class=\"number\">2</span> * n, t = <span class=\"number\">2</span> * n + <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, <span class=\"built_in\">Dinic</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["图论"],"tags":["网络流"]},{"title":"题解 【P4689 [Ynoi2016] 这是我自己的发明】","url":"/2021/04/14/luogu-P4689/","content":"<p><del>大家好，我是来拉低这题通过率的</del></p>\n<span id=\"more\"></span>\n<p>这个题有一个弱化版<a href=\"https://www.luogu.com.cn/problem/P5268\">P5268</a>。在这里简单地讲一下这个弱化版。</p>\n<p>就是设 $f(l_1,l_2,r_1,r_2)$ 表示区间 $[l_1,l_2]$ 与 $[r_1,r_2]$ 的答案。那么容斥一下或者暴力展开式子（像下面这样，$g(l,r,x)$ 表示区间 $[l,r]$ 内 $x$ 出现的次数）。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nf(l_1,l_2,r_1,r_2)&=\\sum\\limits^{\\infty}_{i=1}g(l_1,r_1,i)\\times g(l_2,r_2,i)\\\\\n&=\\sum\\limits^{\\infty}_{i=1}[g(1,r_1,i)-g(1,l_1-1,i)]\\times [g(1,r_2,i)-g(1,l_2-1,i)]\\\\\n&=\\sum\\limits^{\\infty}_{i=1}g(1,l_1,i)\\times g(1,r_2,i)-g(1,l_1-1,i)\\times g(1,r_2,i)-g(1,r_1,i)\\times g(1,l_2-1,i)+g(1,l_1-1,i)\\times g(1,r_2-1,i)\\\\\n&=f(1,1,r_1,r_2)-f(1,1,l_1-1,r_2)-f(1,1,l_2-1,r_1)+f(1,1,l_1-1,r_1-1)\n\\end{aligned}</script><p>然后上个莫队就可以了。</p>\n<p>这题有两个地方加强了：</p>\n<ol>\n<li><p>原问题搬到了树上</p>\n</li>\n<li><p>数据范围扩大，<del>然而仍然是Ynoi少有的不卡常的良心题</del></p>\n</li>\n</ol>\n<p>那么怎么把序列上的题搬到树上呢？</p>\n<p>一个可行的做法是dfs序。换根操作是个非常套路的dfs序自带功能，分类讨论一下：</p>\n<ol>\n<li><p>$u$ 是 $root$，$u$ 对应的就是整个区间。</p>\n</li>\n<li><p>$u$ 不是 $root$ 也不是 $root$ 的祖先，对应的区间就是 $[In_u,Out_u]$。</p>\n</li>\n<li><p>$u$ 不是 $root$ 且是 $root$ 的祖先。这种情况稍微麻烦一点，假设 $u$ 向 $root$ 方向的儿子是 $v$，那么对应的区间是 $[1,In_y)$ 和 $(Out_y+1,n)$ 两段区间。</p>\n</li>\n</ol>\n<p>然后就可以强行拆成膜队了。</p>\n<p>但是注意直接拆最多会拆成 $16$ 个询问，<del>根据lxl的凉心程度，这辈子都不可能放你过的（</del></p>\n<p>为了<del>少打几个字</del>方便表述设 $f_0(x,y)=f(1,1,x,y)$</p>\n<p>但是 $f_0$ 函数当 $x$ 或 $y$ 为 $0$ 时值为 $0$，然后就只有 $9$ 个膜队了！！！！！！11</p>\n<p><del>不好意思，根据膜队的复杂度这样只会让常数除以1.4</del></p>\n<p>然鹅拆成的询问很多 $f_0$ 函数 都是 $f_0(i,n)$ 的，我们让 $g_i$ 表示 $f_0(i,n)$，然后就只需要拆成 $4$ 个询问了！！！！！！！！！！1111（雾</p>\n<p>放一下最后展开的式子：</p>\n<p>$f(1,l,x,r)+f(y,l,n,r)=f_0(x,r)-f_0(l-1,x)+f_0(y-1,l-1)-f_0(y-1,r)-g_{l-1}+g_r$</p>\n<p>$f(1,1,x_0,x_1)+f(1,y,x_0,n)+f(y_0,1,n,x_1)+f(y_0,y_1,n,n)=f_0(x_0,x_1)+g_{x_0}-f_0(y_1-1,x_0)+g-{x_1}-f_0(y_0-1,x_1)-g_{y_1-1}-g_{y_0-1}+g_n+f_0(y_0-1,y_1-1)-g_{y_0-1}-g_{y_1-1}$</p>\n<p><del>不是很长对吧</del></p>\n<p>然后，对于如何找点 $u$ 在 $v$ 方向的儿子，当然倍增是可以的，但是有一个更简单的方法，就是记录 $u$ 所有儿子的 $In$ 值，查询的时候直接二分查找就行了。详见带马。</p>\n<p>最后的复杂度 $O(n\\sqrt{m})$。注意膜队的正确块长是 $n\\div \\sqrt{m}$，否则复杂度会退化。</p>\n<p><del>祝愿没有人像我一样为本题无私地贡献36次提交。</del></p>\n<p>还有，十年OI一场空，不开<strong>__</strong>见祖宗（（（</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> gc (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 65536, stdin), p1 == p2) ? EOF : *p1 ++)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">65536</span>], *p1, *p2;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">x</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((ch = gc) &lt; <span class=\"number\">48</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> x = x * <span class=\"number\">10</span> + ch - <span class=\"number\">48</span>; <span class=\"keyword\">while</span> ((ch = gc) &gt;= <span class=\"number\">48</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">100005</span>], A[<span class=\"number\">100005</span>], cnt[<span class=\"number\">100005</span>][<span class=\"number\">2</span>], In[<span class=\"number\">100005</span>], Out[<span class=\"number\">100005</span>], P[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> Now, S, tot, <span class=\"built_in\">root</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">ll g[<span class=\"number\">100005</span>], Q[<span class=\"number\">500005</span>], ans;</span><br><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt; sons[<span class=\"number\">100005</span>], dfn[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">chk</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;<span class=\"keyword\">return</span> In[u] &lt; In[root] &amp;&amp; Out[root] &lt;= Out[u];&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">getance</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> P[*(std::<span class=\"built_in\">upper_bound</span>(dfn[u].<span class=\"built_in\">begin</span>(), dfn[u].<span class=\"built_in\">end</span>(), In[root]) - <span class=\"number\">1</span>)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Question</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> op, id, l, r;</span><br><span class=\"line\">\t<span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> Question a) <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">\t\tint x((l - 1) / S), y((a.l - 1) / S);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x == y ? (r - <span class=\"number\">1</span>) / S &lt; (a.r - <span class=\"number\">1</span>) / S : x &lt; y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; q[<span class=\"number\">2000005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\tans += cnt[x][d ^ <span class=\"number\">1</span>], ++ cnt[x][d];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">del</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\tans -= cnt[x][d ^ <span class=\"number\">1</span>], -- cnt[x][d];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> fa)</span> </span>&#123;</span><br><span class=\"line\">\tP[In[u] = ++ Now] = u;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> v : sons[u])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v != fa) <span class=\"built_in\">dfs</span>(v, u), dfn[u].<span class=\"built_in\">push_back</span>(In[v]);</span><br><span class=\"line\">\tOut[u] = Now;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m, <span class=\"built_in\">l</span>(<span class=\"number\">0</span>), <span class=\"built_in\">r</span>(<span class=\"number\">0</span>), <span class=\"built_in\">qid</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tn = <span class=\"built_in\">read</span>(), m = <span class=\"built_in\">read</span>();</span><br><span class=\"line\">\tS = n / <span class=\"built_in\">sqrt</span>(m);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) A[i] = a[i] = <span class=\"built_in\">read</span>();</span><br><span class=\"line\">\tstd::<span class=\"built_in\">sort</span>(a + <span class=\"number\">1</span>, a + n + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\tA[i] = std::<span class=\"built_in\">lower_bound</span>(a + <span class=\"number\">1</span>, a + n + <span class=\"number\">1</span>, A[i]) - a;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt; n; ++ i) &#123;</span><br><span class=\"line\">\t\tint u(read()), v(read());</span><br><span class=\"line\">\t\tsons[u].<span class=\"built_in\">push_back</span>(v), sons[v].<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) ++ cnt[a[In[i]] = A[i]][<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) g[i] = g[i - <span class=\"number\">1</span>] + cnt[a[i]][<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(cnt, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> cnt);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= m; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">op</span><span class=\"params\">(read())</span></span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>) root = <span class=\"built_in\">read</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t++ qid;</span><br><span class=\"line\">\t\t\tint u(read()), v(read());</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!<span class=\"built_in\">chk</span>(u) &amp;&amp; <span class=\"built_in\">chk</span>(v)) std::<span class=\"built_in\">swap</span>(u, v);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= <span class=\"number\">4</span>; ++ j) q[tot + j].id = qid;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!<span class=\"built_in\">chk</span>(u) &amp;&amp; !<span class=\"built_in\">chk</span>(v)) &#123;</span><br><span class=\"line\">\t\t\t\tint l1(In[u]), r1(Out[u]), l2(In[v]), r2(Out[v]);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (u == root) l1 = <span class=\"number\">1</span>, r1 = n;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (v == root) l2 = <span class=\"number\">1</span>, r2 = n;</span><br><span class=\"line\">\t\t\t\tq[++ tot].op = <span class=\"number\">1</span>, q[tot].l = r1, q[tot].r = r2;</span><br><span class=\"line\">\t\t\t\tq[++ tot].op = <span class=\"number\">-1</span>, q[tot].l = l1 - <span class=\"number\">1</span>, q[tot].r = r2;</span><br><span class=\"line\">\t\t\t\tq[++ tot].op = <span class=\"number\">-1</span>, q[tot].l = l2 - <span class=\"number\">1</span>, q[tot].r = r1;</span><br><span class=\"line\">\t\t\t\tq[++ tot].op = <span class=\"number\">1</span>, q[tot].l = l1 - <span class=\"number\">1</span>, q[tot].r = l2 - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">chk</span>(u) &amp;&amp; !<span class=\"built_in\">chk</span>(v)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> <span class=\"built_in\">t</span>(<span class=\"built_in\">getance</span>(u));</span><br><span class=\"line\">\t\t\t\tint x(In[t] - 1), y(Out[t] + 1), l(In[v]), r(Out[v]);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (v == root) l = <span class=\"number\">1</span>, r = n;</span><br><span class=\"line\">\t\t\t\tQ[qid] = g[r] - g[l - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t\tq[++ tot].op = <span class=\"number\">1</span>, q[tot].l = x, q[tot].r = r;</span><br><span class=\"line\">\t\t\t\tq[++ tot].op = <span class=\"number\">-1</span>, q[tot].l = l - <span class=\"number\">1</span>, q[tot].r = x;</span><br><span class=\"line\">\t\t\t\tq[++ tot].op = <span class=\"number\">1</span>, q[tot].l = y - <span class=\"number\">1</span>, q[tot].r = l - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\tq[++ tot].op = <span class=\"number\">-1</span>, q[tot].l = y - <span class=\"number\">1</span>, q[tot].r = r;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> <span class=\"built_in\">t1</span>(<span class=\"built_in\">getance</span>(u)), <span class=\"built_in\">t2</span>(<span class=\"built_in\">getance</span>(v));</span><br><span class=\"line\">\t\t\t\tint x0(In[t1] - 1), x1(In[t2] - 1), y0(Out[t1] + 1), y1(Out[t2] + 1);</span><br><span class=\"line\">\t\t\t\tQ[qid] = g[x0] + g[x1] - g[y1 - <span class=\"number\">1</span>] - g[y0 - <span class=\"number\">1</span>] + g[n];</span><br><span class=\"line\">\t\t\t\tq[++ tot].op = <span class=\"number\">1</span>, q[tot].l = x0, q[tot].r = x1;</span><br><span class=\"line\">\t\t\t\tq[++ tot].op = <span class=\"number\">-1</span>, q[tot].l = y1 - <span class=\"number\">1</span>, q[tot].r = x0;</span><br><span class=\"line\">\t\t\t\tq[++ tot].op = <span class=\"number\">-1</span>, q[tot].l = y0 - <span class=\"number\">1</span>, q[tot].r = x1;</span><br><span class=\"line\">\t\t\t\tq[++ tot].op = <span class=\"number\">1</span>, q[tot].l = y0 - <span class=\"number\">1</span>, q[tot].r = y1 - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= tot; ++ i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (q[i].l &gt; q[i].r) std::<span class=\"built_in\">swap</span>(q[i].l, q[i].r);</span><br><span class=\"line\">\tstd::<span class=\"built_in\">sort</span>(q + <span class=\"number\">1</span>, q + tot + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= tot; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (l &lt; q[i].l) <span class=\"built_in\">add</span>(a[++ l], <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (l &gt; q[i].l) <span class=\"built_in\">del</span>(a[l --], <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (r &lt; q[i].r) <span class=\"built_in\">add</span>(a[++ r], <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (r &gt; q[i].r) <span class=\"built_in\">del</span>(a[r --], <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tQ[q[i].id] += q[i].op * ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= qid; ++ i) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld\\n&quot;</span>, Q[i]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数据结构"],"tags":["莫队"]},{"title":"题解【P5268 [SNOI2017]一个简单的询问】","url":"/2021/04/11/luogu-P5268/","content":"<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><span id=\"more\"></span>\n<p>题面非常明了就不废话了，直接看<a href=\"https://www.luogu.com.cn/problem/P5268\">题面</a></p>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p>题目给了个需要依赖四个参数的式子，看起来不怎么可做。</p>\n<p>这个式子好像也挺恶心，我们尝试把它展开以下看能不能变得好做。以下 $g$ 代表 $get$ 函数，令 $f(l_1,l_2,r_1,r_2)=\\sum\\limits^{\\infty}_{i=1}g(l_1,r_1,i)\\times g(l_2,r_2,i)$（就是题目里给的那坨）。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nf(l_1,l_2,r_1,r_2)&=\\sum\\limits^{\\infty}_{i=1}g(l_1,r_1,i)\\times g(l_2,r_2,i)\\\\\n&=\\sum\\limits^{\\infty}_{i=1}[g(1,r_1,i)-g(1,l_1-1,i)]\\times [g(1,r_2,i)-g(1,l_2-1,i)]\\\\\n&=\\sum\\limits^{\\infty}_{i=1}g(1,l_1,i)\\times g(1,r_2,i)-g(1,l_1-1,i)\\times g(1,r_2,i)-g(1,r_1,i)\\times g(1,l_2-1,i)+g(1,l_1-1,i)\\times g(1,r_2-1,i)\\\\\n&=f(1,1,r_1,r_2)-f(1,1,l_1-1,r_2)-f(1,1,l_2-1,r_1)+f(1,1,l_1-1,r_1-1)\n\\end{aligned}</script><p>最后整个柿子就变成了一个<del>可口的</del>二位数点的容斥柿子……</p>\n<p>令 $f_0(x,y)=f(1,1,x,y)$。一看数据范围，五万，显然是个根号级别起步的算法。由于很容易根据 $f_0(x,y)$ 推出 $f_0(x+1,y)$ 等，那么直接莫队维护两个<code>cnt</code>数组即可。详见代码。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">50005</span>], cnt[<span class=\"number\">50005</span>][<span class=\"number\">2</span>], Q[<span class=\"number\">50005</span>], ans, S, tot;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Question</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> op, id, l, r;</span><br><span class=\"line\">\t<span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> Question a) <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">\t\tint x((l - 1) / S), y((a.l - 1) / S);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x == y ? (r - <span class=\"number\">1</span>) / S &lt; (a.r - <span class=\"number\">1</span>) / S + <span class=\"number\">1</span> : x &lt; y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; q[<span class=\"number\">200005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\tans += cnt[x][d ^ <span class=\"number\">1</span>], ++ cnt[x][d];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">del</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\tans -= cnt[x][d ^ <span class=\"number\">1</span>], -- cnt[x][d];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m, <span class=\"built_in\">l</span>(<span class=\"number\">0</span>), <span class=\"built_in\">r</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, a + i);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;m);</span><br><span class=\"line\">\tS = n / <span class=\"built_in\">sqrt</span>(m);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= m; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> l1, l2, r1, r2;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class=\"line\">\t\tq[++ tot].op = <span class=\"number\">1</span>, q[tot].id = i, q[tot].l = r1, q[tot].r = r2;</span><br><span class=\"line\">\t\tq[++ tot].op = <span class=\"number\">-1</span>, q[tot].id = i, q[tot].l = l1 - <span class=\"number\">1</span>, q[tot].r = r2;</span><br><span class=\"line\">\t\tq[++ tot].op = <span class=\"number\">-1</span>, q[tot].id = i, q[tot].l = l2 - <span class=\"number\">1</span>, q[tot].r = r1;</span><br><span class=\"line\">\t\tq[++ tot].op = <span class=\"number\">1</span>, q[tot].id = i, q[tot].l = l1 - <span class=\"number\">1</span>, q[tot].r = l2 - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(tot - <span class=\"number\">3</span>); j &lt;= tot; ++ j)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (q[j].l &gt; q[j].r) std::<span class=\"built_in\">swap</span>(q[j].l, q[j].r);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstd::<span class=\"built_in\">sort</span>(q + <span class=\"number\">1</span>, q + tot + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= tot; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (l &lt; q[i].l) <span class=\"built_in\">add</span>(a[++ l], <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (l &gt; q[i].l) <span class=\"built_in\">del</span>(a[l --], <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (r &lt; q[i].r) <span class=\"built_in\">add</span>(a[++ r], <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (r &gt; q[i].r) <span class=\"built_in\">del</span>(a[r --], <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tQ[q[i].id] += q[i].op * ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= m; ++ i) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, Q[i]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["莫队"]},{"title":"题解 【P1600 [NOIP2016 提高组] 天天爱跑步】","url":"/2021/03/25/luogu-P1600/","content":"<p>这是NOIP2016D1T2？我觉得我参加NOIP绝对爆零。</p>\n<span id=\"more\"></span>\n<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><p>由于题面太长，不再赘述。<a href=\"https://www.luogu.com.cn/problem/P1600\">传送门</a></p>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p>手动膜你每个玩家的跑步过程显然不可行，因此只能对于每个观察员计算有多少个玩家会对他产生贡献。</p>\n<p>考虑一个玩家，它会先从 $s$ 跑到 $s$ 和 $t$ 的 $lca$ 上，因此分两种情况。</p>\n<p>一、 $u$ 在某个玩家 $s$ 到 $lca$ 的路径上。<img src=\"https://i.loli.net/2021/03/25/BXvQWlF2JwUg1bO.png\" alt=\"\"></p>\n<p>那么此时玩家到 $u$ 的时刻应为 $Dep_s-Dep_u$，$Dep_u$ 表示 $u$ 的深度。</p>\n<p>当 $Dep_s-Dep_u=w_u$ 时，这个玩家对 $u$ 产生贡献。我们希望把与 $u$ 无关的项全部移到一边去，因此移项得 $Dep_s=Dep_u+w_u$。</p>\n<p>二、 $u$ 在某个玩家从 $lca$ 到 $t$ 的路径上。<img src=\"https://i.loli.net/2021/03/25/BXvQWlF2JwUg1bO.png\" alt=\"未命名绘图.png\"></p>\n<p>那么此时玩家到 $u$ 的时刻应为 $Dep_s-Dep_{lca}+Dep_u-Dep_{lca}$。当 $Dep_s+Dep_u-Dep_{lca}\\times 2=w_u$ 时产生贡献，移项得 $Dep_s+-Dep_{lca}\\times 2=w_u-Dep_u$。</p>\n<p>以上两种情况，均要求 $s$ 或 $t$ 是 $u$ 的子节点，且 $u$ 是 $lca$ 的子节点。可以想到线段树合并，对每个节点建立两颗线段树，一个维护情况一的贡献，一个维护情况二的贡献。查询情况一的线段树里面下标为 $Dep_u+w_u$ 的值即可。情况二同理。由于 $u$ 在 $lca$ 时会重复计算，因此需要将 $lca$ 与它的父亲减一下。感觉这里光凭说有点绕，详见代码。</p>\n<p>时间复杂度 $O(nlogn)$。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这题的权值线段树只需要单点修改单点查询，但是需要合并，使用vector应该能够做到更好的复杂度，但是我懒（逃</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt; sons[<span class=\"number\">300005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> w[<span class=\"number\">300005</span>], fa[<span class=\"number\">300005</span>][<span class=\"number\">19</span>], Dep[<span class=\"number\">300005</span>], ans[<span class=\"number\">300005</span>], n;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MAX</span><span class=\"params\">(ceil(log2(Dep[u] = Dep[fa[u][<span class=\"number\">0</span>]] + <span class=\"number\">1</span>)))</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= MAX; ++ i) fa[u][i] = fa[fa[u][i - <span class=\"number\">1</span>]][i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> v : sons[u])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v != fa[u][<span class=\"number\">0</span>]) fa[v][<span class=\"number\">0</span>] = u, <span class=\"built_in\">dfs</span>(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LCA</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Dep[u] &lt; Dep[v]) u ^= v ^= u ^= v;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MAX</span><span class=\"params\">(ceil(log2(Dep[u] - Dep[v])))</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt;= MAX; ++ i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (Dep[u] - Dep[v] &amp; <span class=\"number\">1</span> &lt;&lt; i) u = fa[u][i];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (u == v) <span class=\"keyword\">return</span> u;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"built_in\">ceil</span>(<span class=\"built_in\">log2</span>(Dep[u]))); i &gt;= <span class=\"number\">0</span>; -- i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fa[u][<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> sum[<span class=\"number\">10000005</span>], ls[<span class=\"number\">10000005</span>], rs[<span class=\"number\">10000005</span>], root[<span class=\"number\">300005</span>], root2[<span class=\"number\">300005</span>], tot;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> l, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> r, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> p, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!O) O = ++ tot;</span><br><span class=\"line\">\tsum[O] += d;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(l + r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p &lt;= mid) <span class=\"built_in\">update</span>(ls[O], l, mid, p, d);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(rs[O], mid + <span class=\"number\">1</span>, r, p, d);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> l, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!x || !y) &#123;x |= y; <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">\tsum[x] += sum[y];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(l + r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">merge</span>(ls[x], ls[y], l, mid);</span><br><span class=\"line\">\t<span class=\"built_in\">merge</span>(rs[x], rs[y], mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> l, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> r, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!O || p &lt; l || r &lt; p) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//有可能出现dep[u]+w[u]&gt;n的情况，因此特判一下。</span></span><br><span class=\"line\"> \t<span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span> sum[O];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(l + r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p &lt;= mid) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(ls[O], l, mid, p);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(rs[O], mid + <span class=\"number\">1</span>, r, p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> v : sons[u]) <span class=\"keyword\">if</span> (v != fa[u][<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs2</span>(v);</span><br><span class=\"line\">\t\t<span class=\"built_in\">merge</span>(root[u], root[v], -n, n);</span><br><span class=\"line\">\t\t<span class=\"built_in\">merge</span>(root2[u], root2[v], -n, n);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tans[u] = <span class=\"built_in\">query</span>(root2[u], <span class=\"number\">1</span>, n &lt;&lt; <span class=\"number\">1</span>, n + w[u] - Dep[u]) + <span class=\"built_in\">query</span>(root[u], <span class=\"number\">1</span>, n &lt;&lt; <span class=\"number\">1</span>, n + Dep[u] + w[u]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt; n; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> u, v;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class=\"line\">\t\tsons[u].<span class=\"built_in\">push_back</span>(v), sons[v].<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, w + i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= m; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> s, t, lca;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;s, &amp;t);</span><br><span class=\"line\">\t\tlca = <span class=\"built_in\">LCA</span>(s, t);</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(root[s], <span class=\"number\">1</span>, n &lt;&lt; <span class=\"number\">1</span>, n + Dep[s], <span class=\"number\">1</span>);<span class=\"comment\">//本题的核心，套式子，算贡献</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(root2[t], <span class=\"number\">1</span>, n &lt;&lt; <span class=\"number\">1</span>, n + Dep[s] - Dep[lca] * <span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(root[lca], <span class=\"number\">1</span>, n &lt;&lt; <span class=\"number\">1</span>, n + Dep[s], <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(root2[fa[lca][<span class=\"number\">0</span>]], <span class=\"number\">1</span>, n &lt;&lt; <span class=\"number\">1</span>, n + Dep[s] - Dep[lca] * <span class=\"number\">2</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs2</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, ans[i]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数据结构"],"tags":["线段树"]},{"title":"洛谷P3899题解 【[湖南集训]谈笑风生】","url":"/2021/03/23/luogu-p3899/","content":"<p>有巨佬说这题亦可赛艇，确实挺亦可赛艇（</p>\n<span id=\"more\"></span>\n<h1 id=\"texttt-Desciption\"><a href=\"#texttt-Desciption\" class=\"headerlink\" title=\"$\\texttt{Desciption}$\"></a>$\\texttt{Desciption}$</h1><p>我觉得题面挺简洁的，至少没有废话，所以直接<a href=\"https://www.luogu.com.cn/problem/P3899\">传送门</a></p>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><h2 id=\"方法一：\"><a href=\"#方法一：\" class=\"headerlink\" title=\"方法一：\"></a>方法一：</h2><p>首先，当 $b$ 是 $a$ 的祖先时，$c$ 有 $cnt_a$ 种情况（$cnt_u$ 表示 $u$ 所有子节点个数（不包括 $u$ 自己））。而 $b$ 有 $min(k,dep_a)$ 种情况（$dep_u$ 表示 $u$ 的深度），所以一共有 $min(k,dep_a)\\times cnt_a$ 种情况。</p>\n<p>当 $a$ 是 $b$ 的祖先时，$b$ 需要满足以下条件：</p>\n<ul>\n<li>是 $a$ 的子节点（<del>废话</del>）</li>\n<li>$dep_b-dep_a\\le k$</li>\n</ul>\n<p>考虑对于每个节点都建一颗线段树，以深度作为下标，则我们需要查询 $[dep_a,dep_a+k]$ 区间的贡献。每个节点的贡献是它的 $cnt$ 值。</p>\n<p>那么就成了线段树合并的题了。线段树合并如果直接在原子树合并就是离线的，时空常数小，新建节点就是在线的，时空常数大。</p>\n<h2 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h2><p>当 $a$ 是 $b$ 的祖先时，该方法处理与方法一不同。</p>\n<p>$b$ 是 $a$ 的子节点这个条件，方法一是直接给每个节点建了一颗线段树，但我们可以想到，判断 $b$ 是否是 $a$ 子节点可以 dfs 序。为了方便描述，$In_u$ 表示第一次访问 $u$ 时的时间戳，$Out_u$ 表示回溯到 $u$ 时的时间戳。</p>\n<p>则点 $b$ 需要满足以下条件：</p>\n<ul>\n<li>$In_a\\le In_b\\le Out_a$</li>\n<li>$dep_b-dep_a\\le k$</li>\n</ul>\n<p>那这不就是一个二维偏序问题了？离线BIT处理即可。</p>\n<p>两种方法时间复杂度均为 $O(nlogn)$</p>\n<h1 id=\"texttt-Code\"><a href=\"#texttt-Code\" class=\"headerlink\" title=\"$\\texttt{Code}$\"></a>$\\texttt{Code}$</h1><p>只写了方法一。写完了发现BIT可以做口胡的第二种做法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> getl(p) (ls[p] ? ls[p] : ls[p] = ++ tot)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> getr(p) (rs[p] ? rs[p] : rs[p] = ++ tot)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> to, nxt;</span><br><span class=\"line\">&#125; e[<span class=\"number\">600005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> ls[<span class=\"number\">3000005</span>], rs[<span class=\"number\">3000005</span>], v[<span class=\"number\">3000005</span>], root[<span class=\"number\">300005</span>], tot, tot2;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Dep[<span class=\"number\">300005</span>], head[<span class=\"number\">300005</span>], cnt[<span class=\"number\">300005</span>], ans[<span class=\"number\">300005</span>], n;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> id, k;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">std::vector&lt;Node&gt; ques[<span class=\"number\">300005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">AddEdge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">\te[++ tot2].to = v, e[tot2].nxt = head[u], head[u] = tot2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> l, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r) &#123;v[O] += d; <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(l + r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x &lt;= mid) <span class=\"built_in\">update</span>(<span class=\"built_in\">getl</span>(O), x, d, l, l + r &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(<span class=\"built_in\">getr</span>(O), x, d, (l + r &gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">\tv[O] = v[ls[O]] + v[rs[O]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> l, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class=\"keyword\">return</span> v[O];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(l + r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ans</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= mid &amp;&amp; ls[O]) ans += <span class=\"built_in\">query</span>(ls[O], L, R, l, mid);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mid &lt; R &amp;&amp; rs[O]) ans += <span class=\"built_in\">query</span>(rs[O], L, R, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!x || !y) &#123;x |= y; <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">\tv[x] += v[y];</span><br><span class=\"line\">\t<span class=\"built_in\">merge</span>(ls[x], ls[y]);</span><br><span class=\"line\">\t<span class=\"built_in\">merge</span>(rs[x], rs[y]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> fa)</span> </span>&#123;</span><br><span class=\"line\">\tDep[u] = Dep[fa] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(head[u]); i; i = e[i].nxt) <span class=\"keyword\">if</span> (e[i].to != fa) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">v</span><span class=\"params\">(e[i].to)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v, u);</span><br><span class=\"line\">\t\tcnt[u] += cnt[v] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">merge</span>(root[u], root[v]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (Node&amp; i : ques[u]) &#123;</span><br><span class=\"line\">\t\tans[i.id] = <span class=\"built_in\">query</span>(root[u], Dep[u], Dep[u] + i.k, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">\t\tans[i.id] += <span class=\"built_in\">min</span>(Dep[u] - <span class=\"number\">1</span>, i.k) * cnt[u];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">update</span>(root[u], Dep[u], cnt[u], <span class=\"number\">1</span>, n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> q;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;n, &amp;q);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt; n; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> u, v;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;u, &amp;v);</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(u, v), <span class=\"built_in\">AddEdge</span>(v, u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) root[i] = i;</span><br><span class=\"line\">\ttot = n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= q; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> p, k;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;p, &amp;k);</span><br><span class=\"line\">\t\tques[p].<span class=\"built_in\">push_back</span>(Node&#123;i, k&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= q; ++ i) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld\\n&quot;</span>, ans[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数据结构"],"tags":["线段树"]},{"title":"nkoj P5668题解","url":"/2021/03/22/nkoj-5658/","content":"<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><span id=\"more\"></span>\n<blockquote>\n<p>给定一棵大小为 n 的有根点权树,支持以下操作:</p>\n<p>　- 换根<br>　　- 修改点权</p>\n<ul>\n<li>查询子树最小值 </li>\n</ul>\n<p>$\\texttt{Data Range:}1\\le n\\le 10^5$</p>\n</blockquote>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p><del>LCT是什么啊，LCT的前置知识树链剖分又是什么啊，LCT的前置知识Splay我也不会写啊，得出我菜得没救。</del></p>\n<p>233能换根的数据结构看来只有Splay和LCT两个<del>我不会的</del>了啊/kk</p>\n<p>由于老板放到了dfs序作业里面，所以就往这方面想。</p>\n<p>预处理出dfs序。考虑换根操作。老板评讲的时候说了“换根会导致整棵树的形态发生变化，极其耗时，因此换根只在我们脑海中进行，程序中不可能真的换根”。</p>\n<p>由于只有换根操作改变了树的形态，因此记录下当前的根 $root$。</p>\n<p>对于当前询问以 $x$ 为根的子树的最小值，分类讨论（我们按照 $1$ 为根建好树，之后所有的“父亲”“儿子”“祖先”定义都是在这颗建好的树上的）：</p>\n<ol>\n<li><p>$x$ 就是 $root$。输出所有节点中最小权值即可。</p>\n</li>\n<li><p>$x$ 不是 $root$ 的祖先。那么你 $root$ 当了老大<del>关我p事</del>雨我无瓜，直接输出原来的树上以 $x$ 为根的子树最小值。</p>\n</li>\n<li><p>$x$ 是 $root$ 的祖先。那么设 $x$ 的儿子 $y$ 是 $root$ 的祖先（特别的，$y$ 可能等于 $root$。那么在区间 $[1,In_y),(Out_y,n]$ 中取最小值。</p>\n</li>\n</ol>\n<p>修改点权可以线段树，判断 $x$ 是否是 $root$ 祖先以及求 $y$ 可以倍增LCA。</p>\n<h1 id=\"texttt-Code\"><a href=\"#texttt-Code\" class=\"headerlink\" title=\"$\\texttt{Code}$\"></a>$\\texttt{Code}$</h1><p>底部附hack数据方便调试。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> fa[<span class=\"number\">100005</span>][<span class=\"number\">20</span>], Dep[<span class=\"number\">100005</span>], In[<span class=\"number\">100005</span>], Out[<span class=\"number\">100005</span>], val[<span class=\"number\">100005</span>], n, cnt;</span><br><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt; sons[<span class=\"number\">100005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Segment_tree</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> l, r, v;</span><br><span class=\"line\">\t&#125; c[<span class=\"number\">400005</span>];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make_tree</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">\t\tc[O].l = L, c[O].r = R;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (L != R) <span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span>, L, L + R &gt;&gt; <span class=\"number\">1</span>), <span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, (L + R &gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>, R);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> p, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c[O].l == c[O].r) &#123;c[O].v = x; <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p &lt;= c[O &lt;&lt; <span class=\"number\">1</span>].r) <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span>, p, x);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, p, x);</span><br><span class=\"line\">\t\tc[O].v = <span class=\"built_in\">min</span>(c[O &lt;&lt; <span class=\"number\">1</span>].v, c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> l, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> r)</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l &gt; r) <span class=\"keyword\">return</span> <span class=\"number\">0x3fffffff</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l &lt;= c[O].l &amp;&amp; c[O].r &lt;= r) <span class=\"keyword\">return</span> c[O].v;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(c[O &lt;&lt; <span class=\"number\">1</span>].r)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ans</span><span class=\"params\">(<span class=\"number\">0x3fffffff</span>)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l &lt;= mid) ans = <span class=\"built_in\">min</span>(ans, <span class=\"built_in\">query</span>(O &lt;&lt; <span class=\"number\">1</span>, l, r));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (mid &lt; r) ans = <span class=\"built_in\">min</span>(ans, <span class=\"built_in\">query</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; Tree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">\tTree.<span class=\"built_in\">update</span>(<span class=\"number\">1</span>, In[u] = ++ cnt, val[u]);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MAX</span><span class=\"params\">(ceil(log2(Dep[u] = Dep[fa[u][<span class=\"number\">0</span>]] + <span class=\"number\">1</span>)))</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= MAX; ++ i) fa[u][i] = fa[fa[u][i - <span class=\"number\">1</span>]][i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : sons[u]) <span class=\"keyword\">if</span> (i != fa[u][<span class=\"number\">0</span>]) <span class=\"built_in\">dfs</span>(i);</span><br><span class=\"line\">\tOut[u] = cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">LCA</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Dep[x] &lt; Dep[y]) &#123;<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">t</span><span class=\"params\">(x)</span></span>; x = y, y = t;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MAX</span><span class=\"params\">(ceil(log2(n)))</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt;= MAX; ++ i) <span class=\"keyword\">if</span> (Dep[x] - Dep[y] &amp; <span class=\"number\">1</span> &lt;&lt; i) x = fa[x][i];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x == y) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(MAX); i &gt;= <span class=\"number\">0</span>; -- i)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fa[x][<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">Jump</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MAX</span><span class=\"params\">(ceil(log2(n)))</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt;= MAX; ++ i) <span class=\"keyword\">if</span> (Dep[x] - Dep[y] - <span class=\"number\">1</span> &amp; <span class=\"number\">1</span> &lt;&lt; i) x = fa[x][i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m, <span class=\"built_in\">root</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\tTree.<span class=\"built_in\">make_tree</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;fa[i][<span class=\"number\">0</span>], val + i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fa[i][<span class=\"number\">0</span>]) sons[fa[i][<span class=\"number\">0</span>]].<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (m --) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> op;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot; %c%d&quot;</span>, &amp;op, &amp;x);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"string\">&#x27;V&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> y;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;y);</span><br><span class=\"line\">\t\t\tTree.<span class=\"built_in\">update</span>(<span class=\"number\">1</span>, In[x], y);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (op == <span class=\"string\">&#x27;E&#x27;</span>) root = x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x == root) &#123;<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, Tree.<span class=\"built_in\">query</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n)); <span class=\"keyword\">continue</span>;&#125;</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">lca</span><span class=\"params\">(LCA(x, root))</span></span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (lca != x) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, Tree.<span class=\"built_in\">query</span>(<span class=\"number\">1</span>, In[x], Out[x]));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> <span class=\"built_in\">y</span>(<span class=\"built_in\">Jump</span>(root, x));</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, <span class=\"built_in\">min</span>(Tree.<span class=\"built_in\">query</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, In[y] - <span class=\"number\">1</span>), Tree.<span class=\"built_in\">query</span>(<span class=\"number\">1</span>, Out[y] + <span class=\"number\">1</span>, n)));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">10 2</span></span><br><span class=\"line\"><span class=\"comment\">0 6</span></span><br><span class=\"line\"><span class=\"comment\">1 7</span></span><br><span class=\"line\"><span class=\"comment\">2 1</span></span><br><span class=\"line\"><span class=\"comment\">2 4</span></span><br><span class=\"line\"><span class=\"comment\">4 2</span></span><br><span class=\"line\"><span class=\"comment\">1 10</span></span><br><span class=\"line\"><span class=\"comment\">6 5</span></span><br><span class=\"line\"><span class=\"comment\">7 6</span></span><br><span class=\"line\"><span class=\"comment\">7 0</span></span><br><span class=\"line\"><span class=\"comment\">6 18</span></span><br><span class=\"line\"><span class=\"comment\">E 7</span></span><br><span class=\"line\"><span class=\"comment\">Q 6</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>","categories":["数据结构"],"tags":["线段树","dfs序"]},{"title":"nkoj P5975题解","url":"/2021/03/22/nkoj-5975/","content":"<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><span id=\"more\"></span>\n<blockquote>\n<p> 给你 $n$ 个节点的树，要你选择 $k$ 个点 $a_1,a_2…a_k$，使得 $\\sum\\limits_{i=1}^{i&lt;k} dis(a_i,a_{i+1})$ 最小，$dis(u,v)$ 表示节点 $u$ 和 $v$ 的距离。树的边权均为正整数且小于 $10^5$。</p>\n<p>$\\texttt{Data Range:}1\\le k\\le n\\le 10^5$</p>\n</blockquote>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p>算是比较毒瘤的一个树形 dp了吧。需要充分挖掘题目性质，否则直接树形背包会非常痛苦并且最后发现做不出来。</p>\n<p>首先，我们选出的 $k$ 个点一定是紧密相连的，否则如果中间有空隙，那么用这些空隙位置的点替换原来的点一定更优。</p>\n<p>因此选择的 $k$ 个点一定构成一棵树。当选择好了这棵树后，我们需要找到一条最短的遍历整棵树的路径。那么这条最短路径的长度一定是所有边权之和的两倍减去树的直径。因为路径经过了一条边还要回来，但是有些路径是可以不回来的。选择的这些只经过一次的边构成一条链，我们自然希望这条链最长，因此这条链长度即为树的直径。</p>\n<p>如果直接进行树形背包，不知道直径是哪条链，也就没法 dp。因此考虑在状态中加入对直径的限制：$dp_{u,i,x}$ 表示在以 $u$ 为根的子树中，选择 $i$ 个点，其中包含了 $x$ 个直径端点（$0\\le x\\le 2$)，最小代价是多少。</p>\n<p>有一个注意的地方，树形背包的填表法时间复杂度是假的，之前没被卡过但在这题上被卡了。只有刷表法复杂度是经过严格证明 $O(n^2)$ 的。</p>\n<script type=\"math/tex; mode=display\">dp_{u,i+j,0}=min(dp_{u,i,0}+dp_{v,j,0}+len(u,v)\\times 2)</script><script type=\"math/tex; mode=display\">dp_{u,i+j,1}=min(dp_{u,i,1}+dp_{v,j,0}+len(u,v)\\times 2,dp_{u,i,0}+dp_{v,j,1}+len(u,v))</script><script type=\"math/tex; mode=display\">dp_{u,i+j,2}=min(dp_{u,i,0}+dp_{v,j,2}+len(u,v)\\times 2,dp_{u,i,1}+dp_{v,j,1}+len(u,v),dp_{u,i,2}+dp_{v,j,0}+len(u,v)\\times 2)</script><p>$v$ 是 $u$ 的儿子，$len(u,v)$ 表示连接 $u,v$ 两点的边的长度。</p>\n<h1 id=\"texttt-Code\"><a href=\"#texttt-Code\" class=\"headerlink\" title=\"$\\texttt{Code}$\"></a>$\\texttt{Code}$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> to, w, nxt;</span><br><span class=\"line\">&#125; e[<span class=\"number\">6005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> head[<span class=\"number\">3005</span>], dp[<span class=\"number\">3005</span>][<span class=\"number\">3005</span>][<span class=\"number\">3</span>], cnt[<span class=\"number\">3005</span>], tot, n, k, ans = <span class=\"number\">2e9</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">AddEdge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> v, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> w)</span> </span>&#123;</span><br><span class=\"line\">\te[++ tot].to = v, e[tot].w = w, e[tot].nxt = head[u], head[u] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> fa)</span> </span>&#123;</span><br><span class=\"line\">\tdp[u][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = dp[u][<span class=\"number\">1</span>][<span class=\"number\">0</span>] = dp[u][<span class=\"number\">1</span>][<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tcnt[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">I</span>(head[u]); I; I = e[I].nxt) <span class=\"keyword\">if</span> (e[I].to != fa) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">v</span><span class=\"params\">(e[I].to)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v, u);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"built_in\">min</span>(cnt[u], k)); i; -- i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= cnt[v] &amp;&amp; i + j &lt;= k; ++ j) &#123;</span><br><span class=\"line\">\t\t\tint t0(dp[u][i][0]), t1(dp[u][i][1]), t2(dp[u][i][2]);</span><br><span class=\"line\">\t\t\tdp[u][i + j][<span class=\"number\">0</span>] = <span class=\"built_in\">min</span>(dp[u][i + j][<span class=\"number\">0</span>], t0 + dp[v][j][<span class=\"number\">0</span>] + e[I].w * <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\tdp[u][i + j][<span class=\"number\">1</span>] = <span class=\"built_in\">min</span>(dp[u][i + j][<span class=\"number\">1</span>], <span class=\"built_in\">min</span>(t1 + dp[v][j][<span class=\"number\">0</span>] + e[I].w * <span class=\"number\">2</span>, t0 + dp[v][j][<span class=\"number\">1</span>] + e[I].w));</span><br><span class=\"line\">\t\t\tdp[u][i + j][<span class=\"number\">2</span>] = <span class=\"built_in\">min</span>(dp[u][i + j][<span class=\"number\">2</span>], <span class=\"built_in\">min</span>(t0 + dp[v][j][<span class=\"number\">2</span>] + e[I].w * <span class=\"number\">2</span>, <span class=\"built_in\">min</span>(t1 + dp[v][j][<span class=\"number\">1</span>] + e[I].w, t2 + dp[v][j][<span class=\"number\">0</span>] + e[I].w * <span class=\"number\">2</span>)));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans = <span class=\"built_in\">min</span>(ans, dp[u][k][<span class=\"number\">2</span>]);</span><br><span class=\"line\">\t\tcnt[u] += cnt[v];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dp, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dp);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;0&quot;</span>), <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt; n; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> u, v, w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class=\"line\">\t\t<span class=\"built_in\">AddEdge</span>(u, v, w), <span class=\"built_in\">AddEdge</span>(v, u, w);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["动态规划"],"tags":["树形dp"]},{"title":"3/21 练习赛总结","url":"/2021/03/21/3-21-macth-summary/","content":"<h1 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"$A$\"></a>$A$</h1><span id=\"more\"></span>\n<p>正常的签到？</p>\n<p><del>然而我写了多长一大坨屎山代码</del></p>\n<p>暴力字符串匹配，然后将每个密码子能匹配上的位置起止位置作为线段的左右端点，则问题转化为选择尽量多的互不重叠的线段，贪心即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> fa[<span class=\"number\">1000005</span>], l[<span class=\"number\">1000005</span>], r[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"><span class=\"keyword\">char</span> s[<span class=\"number\">10005</span>], p[<span class=\"number\">100</span>][<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> removed[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Line</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l, r;</span><br><span class=\"line\">\t<span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> Line X) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> l &lt; X.l;&#125;</span><br><span class=\"line\">&#125; li[<span class=\"number\">10005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;<span class=\"keyword\">return</span> fa[x] == x ? x : fa[x] = <span class=\"built_in\">find</span>(fa[x]);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, <span class=\"built_in\">m</span>(<span class=\"number\">0</span>), <span class=\"built_in\">t</span>(<span class=\"number\">0</span>), <span class=\"built_in\">MaxR</span>(<span class=\"number\">0</span>), <span class=\"built_in\">ans</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, s + <span class=\"number\">1</span>);</span><br><span class=\"line\">\tn = <span class=\"built_in\">strlen</span>(s + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, p[m + <span class=\"number\">1</span>] + <span class=\"number\">1</span>) != EOF) ++ m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= m; ++ i)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j + <span class=\"number\">2</span> &lt;= n; ++ j)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s[j] == p[i][<span class=\"number\">1</span>] &amp;&amp; s[j + <span class=\"number\">1</span>] == p[i][<span class=\"number\">2</span>] &amp;&amp; s[j + <span class=\"number\">2</span>] == p[i][<span class=\"number\">3</span>])</span><br><span class=\"line\">\t\t\tli[++ t].l = j, li[t].r = j + <span class=\"number\">2</span>;</span><br><span class=\"line\">\tstd::<span class=\"built_in\">sort</span>(li + <span class=\"number\">1</span>, li + t + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= t; ++ i) fa[i] = i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(t); i; -- i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (li[i - <span class=\"number\">1</span>].r &gt; li[<span class=\"built_in\">find</span>(i)].r) removed[i - <span class=\"number\">1</span>] = <span class=\"literal\">true</span>, fa[i - <span class=\"number\">1</span>] = <span class=\"built_in\">find</span>(i);</span><br><span class=\"line\">\tm = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= t; ++ i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!removed[i]) l[++ m] = li[i].l, r[m] = li[i].r;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= m; ++ i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!removed[i] &amp;&amp; MaxR &lt; l[i]) MaxR = r[i], ++ ans;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"$B$\"></a>$B$</h1><p>贪心。考虑按照罪犯指控关系建图，则将目前所有入度为 $0$ 的点设定为罪犯，删掉从这个点出发的边，从这个点开始dfs。</p>\n<p>因为图有环，最后再扫一遍，从所有入度为 $1$ 的点开始 dfs 一遍。</p>\n<p>感性理解一下这个贪心应该是正确的。严格证明不会，老师也没讲。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> A[<span class=\"number\">500005</span>], In[<span class=\"number\">500005</span>], n, ans;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[<span class=\"number\">500005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> mark)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vis[u]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\tvis[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tans += mark;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (-- In[A[u]] == <span class=\"number\">0</span> || mark) <span class=\"built_in\">dfs</span>(A[u], mark ^ <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, A + i), ++ In[A[i]];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (In[i] == <span class=\"number\">0</span>) <span class=\"built_in\">dfs</span>(i, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (In[i] == <span class=\"number\">1</span>) <span class=\"built_in\">dfs</span>(i, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"$C$\"></a>$C$</h1><p>你既可以状压也可以贪心，考试时觉得状压代码也很短，贪心反而不好严格证明（虽然我找不出hack）就写了状压。</p>\n<p>状压做的话就是板子题了。$dp_S$ 表示打完 $S$ 集合中的英雄最小所需HP。转移方程不再赘述。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">20</span>], h[<span class=\"number\">20</span>], d[<span class=\"number\">20</span>], sum[<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">20</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dp, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dp);</span><br><span class=\"line\">\tdp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt; n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, d + i, h + i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt; <span class=\"number\">1</span> &lt;&lt; n; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">0</span>); j &lt; n; ++ j)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i &amp; <span class=\"number\">1</span> &lt;&lt; j) sum[i] += d[j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt; <span class=\"number\">1</span> &lt;&lt; n; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">0</span>); j &lt; n; ++ j)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i &amp; <span class=\"number\">1</span> &lt;&lt; j) dp[i] = <span class=\"built_in\">min</span>(dp[i], dp[i ^ <span class=\"number\">1</span> &lt;&lt; j] + sum[i] * h[j]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, dp[(<span class=\"number\">1</span> &lt;&lt; n) - <span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"$D$\"></a>$D$</h1><p>妙啊（蒟蒻听完评讲后的感言）！</p>\n<p>题目：给你一颗树，求这些树上的节点权值两两异或和（所有点对路径上的异或和）。注意 $(x,x)$ 也是点对。</p>\n<p>这个题没法像之前的套路性找最短路径和问题一样，因为异或没有分配律。</p>\n<p>既然异或是二进制运算，那么对于每一位都进行一次求解，则原来的节点权值只有 $0$ 和 $1$ 两种。考虑树形dp。</p>\n<p>$dp_{u,0/1}$ 表示在以 $u$ 为根节点的子树中，经过根节点 $u$，且不同时经过 $u$ 的两个以上的儿子的路径，异或和为 $0/1$ 的数量。</p>\n<script type=\"math/tex; mode=display\">dp_{u,0}=\\sum\\limits_{v\\in sons(u)}dp_{v,val_u}</script><script type=\"math/tex; mode=display\">dp_{u,1}=\\sum\\limits_{v\\in sons(u)}dp_{v,!val_u}</script><p>注意边算 $dp_{u,0/1}$ 边统计答案。乘法原理将两个子树路径条数撑起来即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">100005</span>][<span class=\"number\">23</span>][<span class=\"number\">2</span>], val[<span class=\"number\">100005</span>], ans;</span><br><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt; sons[<span class=\"number\">100005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> fa)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt;= <span class=\"number\">22</span>; ++ i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (val[u] &amp; <span class=\"number\">1LL</span> &lt;&lt; i) dp[u][i][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> dp[u][i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> v : sons[u]) <span class=\"keyword\">if</span> (v != fa) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v, u);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt;= <span class=\"number\">22</span>; ++ i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">f</span><span class=\"params\">(val[u] &amp; <span class=\"number\">1</span> &lt;&lt; i)</span></span>;</span><br><span class=\"line\">\t\t\tans += (dp[u][i][<span class=\"number\">0</span>] * dp[v][i][<span class=\"number\">1</span>] + dp[u][i][<span class=\"number\">1</span>] * dp[v][i][<span class=\"number\">0</span>]) &lt;&lt; i;</span><br><span class=\"line\">\t\t\tdp[u][i][<span class=\"number\">0</span>] += dp[v][i][f];</span><br><span class=\"line\">\t\t\tdp[u][i][<span class=\"number\">1</span>] += dp[v][i][!f];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, &amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, val + i), ans += val[i];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt; n; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> u, v;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;u, &amp;v);</span><br><span class=\"line\">\t\tsons[u].<span class=\"built_in\">push_back</span>(v), sons[v].<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld\\n&quot;</span>, ans);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"E\"><a href=\"#E\" class=\"headerlink\" title=\"$E$\"></a>$E$</h1><p>之前做过和这道题有那么一点点相似的题，<del>但是那题太难了（所以这就是你做不出这题的理由？）。</del></p>\n<p>首先 $1\\le a_i\\le 50$ 显然有鬼对吧，正常情况直接给到1e9。也就是题目自动帮你离散化了亿下。</p>\n<p>然后仍然没有头绪。挖掘一下区间反转的本质。其实就是两两交换了若干个数（当然数的位置有要求）。</p>\n<p>想到这一步这题就和之前那题有一点相似了（想到这一步了这题甚至还简单一些）。</p>\n<p>$dp_{l,r,d,u}$ 表示 $[l,r]$ 区间的数，经过若干次合法的交换，构成一个最大值大于 $u$，最小值小于 $d$ 的最长不下降子序列长度。</p>\n<p>转移非常套路。$dp_{l,r,d,u}=max(dp_{l,r,d+1,u},dp_{l,r,d,u-1},dp_{l+1,r,d,u}+(A_l=d),dp_{l,r-1,d,u}+(A_r=u),dp_{l+1,r-1,d,u}+(A_l=u)+(A_r=d))$</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">if</span> (x &lt; y) x = y;&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> A[<span class=\"number\">51</span>], dp[<span class=\"number\">51</span>][<span class=\"number\">51</span>][<span class=\"number\">51</span>][<span class=\"number\">51</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[<span class=\"number\">51</span>][<span class=\"number\">51</span>][<span class=\"number\">51</span>][<span class=\"number\">51</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> l, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> r, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l &gt; r) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span> d &lt;= A[l] &amp;&amp; A[l] &lt;= u;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (d &gt; u) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vis[l][r][d][u]) <span class=\"keyword\">return</span> dp[l][r][d][u];</span><br><span class=\"line\">\tvis[l][r][d][u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> &amp;<span class=\"title\">ans</span><span class=\"params\">(dp[l][r][d][u])</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">max</span>(ans, <span class=\"built_in\">dfs</span>(l, r, d + <span class=\"number\">1</span>, u));</span><br><span class=\"line\">\t<span class=\"built_in\">max</span>(ans, <span class=\"built_in\">dfs</span>(l, r, d, u - <span class=\"number\">1</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">max</span>(ans, <span class=\"built_in\">dfs</span>(l + <span class=\"number\">1</span>, r, d, u) + (A[l] == d));</span><br><span class=\"line\">\t<span class=\"built_in\">max</span>(ans, <span class=\"built_in\">dfs</span>(l, r - <span class=\"number\">1</span>, d, u) + (A[r] == u));</span><br><span class=\"line\">\t<span class=\"built_in\">max</span>(ans, <span class=\"built_in\">dfs</span>(l + <span class=\"number\">1</span>, r - <span class=\"number\">1</span>, d, u) + (A[l] == u) + (A[r] == d));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, A + i);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>, n, <span class=\"number\">1</span>, <span class=\"number\">50</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["比赛"],"tags":["比赛"]},{"title":"nkoj-5974 树的难题 题解","url":"/2021/03/16/nkoj-5974/","content":"<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><span id=\"more\"></span>\n<p>见题面。</p>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p>十分套路的树形dp。</p>\n<p>$dp_{u,i,j}$ 表示在以 $u$ 为根节点的子树中，与根节点相连的节点中有 $i$ 个黑色，$j$ 个白色，最小花费。</p>\n<p>$dp_{u,min(1,i+x),min(2,j+y)}=min(dp_{u,i,j}+dp_{v,x,y})$。其中，$v$ 是 $u$ 的子节点。</p>\n<p>所以大概是树形背包板题？</p>\n<p><del>所以呢我特么把 $u$ 写成了 $i$，以及变量重名，调了1h</del></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FORAKIOI for (int i(0); i &lt;= 1; ++ i) for (int j(0); j &lt;= 2; ++ j)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">1e18</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">upd</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">if</span> (x &gt; y) x = y;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> to, w, nxt;</span><br><span class=\"line\">&#125; e[<span class=\"number\">600005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> head[<span class=\"number\">300005</span>], color[<span class=\"number\">300005</span>], dp[<span class=\"number\">300005</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>], tmp[<span class=\"number\">2</span>][<span class=\"number\">3</span>], tot;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">AddEdge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> v, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> w)</span> </span>&#123;</span><br><span class=\"line\">\te[++ tot].to = v, e[tot].w = w, e[tot].nxt = head[u], head[u] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> fa)</span> </span>&#123;</span><br><span class=\"line\">\tFORAKIOI dp[u][i][j] = INF;</span><br><span class=\"line\">\tdp[u][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">I</span>(head[u]); I; I = e[I].nxt) <span class=\"keyword\">if</span> (e[I].to != fa) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">v</span><span class=\"params\">(e[I].to)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v, u);</span><br><span class=\"line\">\t\tFORAKIOI tmp[i][j] = INF;</span><br><span class=\"line\">\t\tFORAKIOI</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">x</span>(<span class=\"number\">0</span>); x &lt;= <span class=\"number\">1</span>; ++ x)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">y</span>(<span class=\"number\">0</span>); y &lt;= <span class=\"number\">2</span>; ++ y) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">upd</span>(tmp[<span class=\"built_in\">min</span>(<span class=\"number\">1</span>, i + x)][<span class=\"built_in\">min</span>(<span class=\"number\">2</span>, j + y)], dp[u][i][j] + dp[v][x][y]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x &lt; <span class=\"number\">1</span> || y &lt; <span class=\"number\">2</span>) <span class=\"built_in\">upd</span>(tmp[i][j], dp[u][i][j] + dp[v][x][y] + e[I].w);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tFORAKIOI dp[u][i][j] = tmp[i][j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tFORAKIOI tmp[i][j] = INF;</span><br><span class=\"line\">\t<span class=\"function\">FORAKIOI <span class=\"title\">upd</span><span class=\"params\">(tmp[min(<span class=\"number\">1</span>, i + (color[u] == <span class=\"number\">0</span>))][min(<span class=\"number\">2</span>, j + (color[u] == <span class=\"number\">1</span>))], dp[u][i][j])</span></span>;</span><br><span class=\"line\">\tFORAKIOI dp[u][i][j] = tmp[i][j];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> T;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, &amp;T);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (T --) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(head, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> head);</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(dp, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dp);</span><br><span class=\"line\">\t\ttot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, &amp;n);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, color + i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt; n; ++ i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> u, v, w;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld%lld&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">AddEdge</span>(u, v, w), <span class=\"built_in\">AddEdge</span>(v, u, w);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ans</span><span class=\"params\">(INF)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"function\">FORAKIOI <span class=\"title\">if</span> <span class=\"params\">(i &lt; <span class=\"number\">1</span> || j &lt; <span class=\"number\">2</span>)</span> <span class=\"title\">upd</span><span class=\"params\">(ans, dp[<span class=\"number\">1</span>][i][j])</span></span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld\\n&quot;</span>, ans);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["动态规划"],"tags":["树形dp"]},{"title":"UVA10917 【Walk Through the Forest】 题解","url":"/2021/03/14/UVA-10917/","content":"<p>算是比较板子的题了。不懂为什么难度被评到了紫题……</p>\n<span id=\"more\"></span>\n<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><blockquote>\n<p>给你一个 $n$ 个点，$m$ 条边的图，令 $dis_i$ 表示编号为 $2$ 的点到点 $i$ 的最短路，求从点 $1$ 出发，经过原图中 $dis_{from}&gt;dis_{to}$ 的边到达点 $2$ 的方案数，$from,to$ 分别表示这条边的起点和终点。</p>\n<p>$\\texttt{Data Range}:n\\le 1000,m\\le n^2$。</p>\n</blockquote>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p>跑一边最短路那是必须的，建议不要用某死了的算法。</p>\n<p>那么建一个新的图，对于原图一条 $u\\rightarrow v$ 的点，当且仅当  $dis_u&gt;dis_v$ 在新图中加入这条边。</p>\n<p>新的图一定是一个 DAG，dp 求解 $1\\rightarrow 2$ 的方案数即可，我建了个隐式反图。</p>\n<p>时间复杂度 $O(mlogn)$。</p>\n<p>按理说这题数据范围珂以给到 $1\\le n,m,\\le 500000$ 啊/yiw</p>\n<h1 id=\"texttt-Code\"><a href=\"#texttt-Code\" class=\"headerlink\" title=\"$\\texttt{Code}$\"></a>$\\texttt{Code}$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> std::pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; PII;</span><br><span class=\"line\">std::priority_queue&lt;PII, std::vector&lt;PII&gt;, std::greater&lt;PII&gt; &gt; q;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> to, nxt, w;</span><br><span class=\"line\">&#125; e[<span class=\"number\">2000005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[<span class=\"number\">1005</span>], head[<span class=\"number\">1005</span>], dp[<span class=\"number\">1005</span>], tot, n, m;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> mp[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>], done[<span class=\"number\">1005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">AddEdge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> v, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> w)</span> </span>&#123;</span><br><span class=\"line\">\te[++ tot].to = v, e[tot].nxt = head[u], e[tot].w = w, head[u] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Dijkstra</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> dp);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dis, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dis);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(done, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> done);</span><br><span class=\"line\">\tdp[<span class=\"number\">2</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tq.<span class=\"built_in\">push</span>(std::<span class=\"built_in\">make_pair</span>(dis[<span class=\"number\">2</span>] = <span class=\"number\">0</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (q.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">u</span><span class=\"params\">(q.top().second)</span></span>;</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (done[u]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tdone[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(head[u]); i; i = e[i].nxt) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">v</span><span class=\"params\">(e[i].to)</span></span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dis[u] + e[i].w &lt; dis[v])</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(std::<span class=\"built_in\">make_pair</span>(dis[v] = dis[u] + e[i].w, v));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DP</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dp[u]) <span class=\"keyword\">return</span> dp[u];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dis[i] &lt; dis[u] &amp;&amp; mp[i][u]) dp[u] += <span class=\"built_in\">DP</span>(i);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[u];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!n) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(head, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> head);</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(mp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> mp);</span><br><span class=\"line\">\t\ttot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;m);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= m; ++ i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> u, v, w;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class=\"line\">\t\t\tmp[u][v] = mp[v][u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">AddEdge</span>(u, v, w), <span class=\"built_in\">AddEdge</span>(v, u, w);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">Dijkstra</span>();</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, <span class=\"built_in\">DP</span>(<span class=\"number\">1</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["图论"],"tags":["最短路","动态规划"]},{"title":"洛谷 P2480 【[SDOI2010]古代猪文】 题解","url":"/2021/03/10/luogu-P2480/","content":"<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><span id=\"more\"></span>\n<blockquote>\n<p>给定 $n,g$，求 $g^{\\sum_{k\\mid n}\\tbinom{n}{k}}\\texttt{ mod } 999911659$ 。</p>\n<p>$\\texttt{Data Range:}1\\le n,g\\le 10^9$</p>\n</blockquote>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p>CRT板题（</p>\n<p>这飞上天的指数显然考虑降冥。根据欧拉定理，$g^{\\sum_{k\\mid n}\\tbinom{n}{k}}\\texttt{ mod } 999911659=g^{\\sum_{k\\mid n}\\tbinom{n}{k}\\texttt{ mod }999911658}\\texttt{ mod } 999911659$。</p>\n<p>现在计算出指数后套上快速冥即可。因此考虑计算 $\\sum_{k\\mid n}\\tbinom{n}{k}\\texttt{ mod }999911658$。</p>\n<p>啥啥啥 $\\texttt{99911658}$ 是合数？<del>我不会扩卢别吓我。</del></p>\n<p>然而你分解了质因数发现 $99911658=2\\times 3\\times 4679\\times 35617$。好像所有质因数的指数都是1欸？</p>\n<p>那么就好做起来了。令 $S=\\sum_{k\\mid n}\\tbinom{n}{k}$，则分别算出 $S\\texttt{ mod } 2,S\\texttt{ mod } 3,S\\texttt{ mod } 4679,S\\texttt{ mod } 35617$ ，用CRT合并解即可。</p>\n<p>组合数对指数取模求和用 Lucas 应该都会吧（大雾</p>\n<p>注意 Lucas 计算 $\\tbinom{n}{m}$ 时特判 $n&lt;m$ 的情况。</p>\n<p><del>我怎么会轻易告诉你我交了十几发呢。</del></p>\n<h1 id=\"texttt-Code\"><a href=\"#texttt-Code\" class=\"headerlink\" title=\"$\\texttt{Code}$\"></a>$\\texttt{Code}$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MOD = <span class=\"number\">999911659LL</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> f[] = &#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4679</span>, <span class=\"number\">35617</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> fact[<span class=\"number\">360000</span>], a[<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">qpow</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> mod)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ret</span><span class=\"params\">(<span class=\"number\">1LL</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (b) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (b &amp; <span class=\"number\">1</span>) ret = ret * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t\tb &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">inv</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> mod)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">qpow</span>(a, mod - <span class=\"number\">2</span>, mod);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">C</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> m, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt; m) <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fact[n] * <span class=\"built_in\">inv</span>(fact[m], p) % p * <span class=\"built_in\">inv</span>(fact[n - m], p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">Lucas</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> m, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt; m) <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> m == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"built_in\">C</span>(n % p, m % p, p) * <span class=\"built_in\">Lucas</span>(n / p, m / p, p) % p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">CRT</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tint sum(MOD - 1), ans(0LL);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt;= <span class=\"number\">3</span>; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">t</span><span class=\"params\">(sum / f[i])</span></span>;</span><br><span class=\"line\">\t\tans = (ans + a[i] * t % sum * <span class=\"built_in\">inv</span>(t, f[i]) % sum) % sum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tfact[<span class=\"number\">0</span>] = <span class=\"number\">1LL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, g;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;n, &amp;g);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (g == MOD) <span class=\"keyword\">return</span> <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;0&#x27;</span>), <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= <span class=\"number\">35617</span>; ++ i) fact[i] = fact[i - <span class=\"number\">1</span>] * i % MOD;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">0</span>); j &lt;= <span class=\"number\">3</span>; ++ j) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= f[j]; ++ i) fact[i] = fact[i - <span class=\"number\">1</span>] * i % f[j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i * i &lt;= n; ++ i) <span class=\"keyword\">if</span> (n % i == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\ta[j] = (a[j] + <span class=\"built_in\">Lucas</span>(n, i, f[j])) % f[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i * i != n) a[j] = (a[j] + <span class=\"built_in\">Lucas</span>(n, n / i, f[j])) % f[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, <span class=\"built_in\">qpow</span>(g, <span class=\"built_in\">CRT</span>(), MOD));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数学"],"tags":["数论"]},{"title":"洛谷P2048 【[NOI2010] 超级钢琴】题解","url":"/2021/03/07/luogu-P2048/","content":"<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><span id=\"more\"></span>\n<blockquote>\n<p>给你一个长度为 $n$ 的序列，要求求出和前 $k$ 小的，长度在 $L,R$ 之间的不同子串的和。两个子串不同当且仅当他们的起点和终点至少有一个不同。</p>\n<p>$\\texttt{Data Range:} n\\leq 5\\times 10^5,k\\leq 5\\times 10^5$</p>\n</blockquote>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p>直接枚举所有子串然后排序？当然可行，但是时间空间双爆炸。</p>\n<p>对于这种只求前 $k$ 小/大的，先考虑把所有可能成为当前最小/大的值放入堆中。</p>\n<p>我们把起点为 $i(1\\le i\\le n)$ 的最大的子串放入堆中。获取堆顶元素后，删除这个元素，然后插入以 $i$ 作为起点的第 $2$ 小的子串。如果下次再次取出了这个元素，那么删除后插入以 $i$ 作为起点的第 $3$ 小的子串，以此类推。</p>\n<p>由于起点固定为 $i$，设 $s_i$ 表示序列 $a$ 的前缀和，即要求找出 $[i+L-1,min(n,i+R-1)]$ 区间中第 $k$ 小的前缀和。主席树即可。</p>\n<p>好像很多神仙用的是其它常数远小于主席树的RMQ之类的玩意儿，<del>反正我只知道时间复杂度 $O(nlogn)$ 的做法中主席树最无脑最好想</del></p>\n<h1 id=\"texttt-Code\"><a href=\"#texttt-Code\" class=\"headerlink\" title=\"$\\texttt{Code}$\"></a>$\\texttt{Code}$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GetL(p) (ls[p] ? ls[p] : ls[p] = ++ nodetot)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GetR(p) (rs[p] ? rs[p] : rs[p] = ++ nodetot)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> std::pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; PII;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">500005</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[N], b[N], kth[N], nodetot, n;</span><br><span class=\"line\">std::priority_queue&lt;PII&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Chairman_tree</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum[N &lt;&lt; <span class=\"number\">5</span>], root[N], ls[N &lt;&lt; <span class=\"number\">5</span>], rs[N &lt;&lt; <span class=\"number\">5</span>], nodetot, x;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">\t\tx = p, <span class=\"built_in\">update</span>(root[k] = ++ nodetot, <span class=\"number\">1</span>, n, root[k - <span class=\"number\">1</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">Query</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(root[r], root[l - <span class=\"number\">1</span>], <span class=\"number\">1</span>, n, k);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make_tree</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == y) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">make_tree</span>(ls[p] = <span class=\"built_in\">GetL</span>(p), x, x + y &gt;&gt; <span class=\"number\">1</span>),</span><br><span class=\"line\">\t\t<span class=\"built_in\">make_tree</span>(rs[p] = <span class=\"built_in\">GetR</span>(p), (x + y &gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>, y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> root)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l == r) &#123;sum[p] = sum[root] + <span class=\"number\">1</span>; <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(l + r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (mid &gt;= x) <span class=\"built_in\">update</span>(ls[p] = <span class=\"built_in\">GetL</span>(p), l, mid, ls[root]), rs[p] = rs[root];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(rs[p] = <span class=\"built_in\">GetR</span>(p), mid + <span class=\"number\">1</span>, r, rs[root]), ls[p] = ls[root];</span><br><span class=\"line\">\t\tsum[p] = sum[ls[p]] + sum[rs[p]];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">\t\tint mid(l + r &gt;&gt; 1), x(sum[ls[u]] - sum[ls[v]]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (d &lt;= x) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(ls[u], ls[v], l, mid, d);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(rs[u], rs[v], mid + <span class=\"number\">1</span>, r, d - x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; Tree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k, L, R;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">ans</span><span class=\"params\">(<span class=\"number\">0LL</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;k, &amp;L, &amp;R);</span><br><span class=\"line\">\tTree.<span class=\"built_in\">make_tree</span>(Tree.root[<span class=\"number\">0</span>] = Tree.nodetot = <span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, &amp;x);</span><br><span class=\"line\">\t\tb[i] = a[i] = a[i - <span class=\"number\">1</span>] + x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstd::<span class=\"built_in\">sort</span>(b + <span class=\"number\">1</span>, b + n + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\tTree.<span class=\"built_in\">Update</span>(i, std::<span class=\"built_in\">lower_bound</span>(b + <span class=\"number\">1</span>, b + n + <span class=\"number\">1</span>, a[i]) - b);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i + L - <span class=\"number\">1</span> &lt;= n; ++ i) &#123;</span><br><span class=\"line\">\t\tconst int st(i + L - 1), ed(min(i + R - 1, n));</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">push</span>(std::<span class=\"built_in\">make_pair</span>(b[Tree.<span class=\"built_in\">Query</span>(st, ed, ed - st + <span class=\"number\">1</span>)] - a[i - <span class=\"number\">1</span>], i));</span><br><span class=\"line\">\t\tkth[i] = ed - st + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (k --) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\">PII <span class=\"title\">t</span><span class=\"params\">(q.top())</span></span>;</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\tans += t.first;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">i</span><span class=\"params\">(t.second)</span></span>;</span><br><span class=\"line\">\t\tconst int st(i + L - 1), ed(min(i + R - 1, n));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (-- kth[i]) q.<span class=\"built_in\">push</span>(std::<span class=\"built_in\">make_pair</span>(b[Tree.<span class=\"built_in\">Query</span>(st, ed, kth[i])] - a[i - <span class=\"number\">1</span>], i));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, ans);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数据结构"],"tags":["主席树"]},{"title":"3/5练习赛题解","url":"/2021/03/06/3-5-solution/","content":"<h1 id=\"A：\"><a href=\"#A：\" class=\"headerlink\" title=\"A：\"></a>A：</h1><span id=\"more\"></span>\n<p><del>看起来很签到,写起来很恶心</del></p>\n<p><del>不过貌似我写的代码是全场最长</del></p>\n<p>类似最大连续和，线段树维护一下最大前缀，最大后缀，最大子段。我的代码里面需要维护一下最大前缀开头的数字是多少，最大后缀开头的数字是多少（所以就有了<code>sub0,sub1,suf0,suf1</code>）。</p>\n<p>然后就是码农了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">wrnm，这题出题人没有horse实锤了 </span></span><br><span class=\"line\"><span class=\"comment\">等等，就我一个人写了这么长吗，wtcl </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &gt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l, r, v, sub0, sub1, suf0, suf1;</span><br><span class=\"line\">&#125; c[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">200005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make_tree</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">\tc[O].l = L, c[O].r = R, c[O].v = c[O].sub0 = c[O].suf0 = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L != R) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span>, L, L + R &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, (L + R &gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>, R);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> ls c[O &lt;&lt; 1]</span></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> rs c[O &lt;&lt; 1 | 1]</span></span><br><span class=\"line\">\tconst int llen(ls.r - ls.l + 1), rlen(rs.r - rs.l + 1);</span><br><span class=\"line\">\tc[O].sub0 = c[O].sub1 = c[O].suf0 = c[O].suf1 = c[O].v = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ls.suf0 == llen) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!a[ls.l]) c[O].sub0 = <span class=\"built_in\">max</span>(c[O].sub0, llen + rs.sub1);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> c[O].sub1 = <span class=\"built_in\">max</span>(c[O].sub1, llen + rs.sub1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ls.suf1 == llen) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!a[ls.l]) c[O].sub0 = <span class=\"built_in\">max</span>(c[O].sub0, llen + rs.sub0);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> c[O].sub1 = <span class=\"built_in\">max</span>(c[O].sub1, llen + rs.sub0);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (rs.sub0 == rlen) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!a[rs.r]) c[O].suf0 = <span class=\"built_in\">max</span>(c[O].suf0, rlen + ls.suf1);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> c[O].suf1 = <span class=\"built_in\">max</span>(c[O].suf1, rlen + ls.suf1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (rs.sub1 == rlen) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!a[rs.r]) c[O].suf0 = <span class=\"built_in\">max</span>(c[O].suf0, rlen + ls.suf0);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> c[O].suf1 = <span class=\"built_in\">max</span>(c[O].suf1, rlen + ls.suf0);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc[O].sub0 = <span class=\"built_in\">max</span>(c[O].sub0, ls.sub0);</span><br><span class=\"line\">\tc[O].sub1 = <span class=\"built_in\">max</span>(c[O].sub1, ls.sub1);</span><br><span class=\"line\">\tc[O].suf0 = <span class=\"built_in\">max</span>(c[O].suf0, rs.suf0);</span><br><span class=\"line\">\tc[O].suf1 = <span class=\"built_in\">max</span>(c[O].suf1, rs.suf1);</span><br><span class=\"line\">\tc[O].v = <span class=\"built_in\">max</span>(<span class=\"built_in\">max</span>(ls.v, rs.v), <span class=\"built_in\">max</span>(ls.suf0 + rs.sub1, ls.suf1 + rs.sub0));</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">undef</span> ls</span></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">undef</span> rs</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c[O].l == c[O].r) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[p] == <span class=\"number\">0</span>) c[O].sub1 = c[O].suf1 = a[p] = <span class=\"number\">1</span>, c[O].sub0 = c[O].suf0 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> c[O].sub0 = c[O].suf0 = <span class=\"number\">1</span>, c[O].sub1 = c[O].suf1 = a[p] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(c[O].l + c[O].r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p &lt;= mid) <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span>, p);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, p);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(O);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, q;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class=\"line\">\t<span class=\"built_in\">make_tree</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (q --) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(<span class=\"number\">1</span>, x);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, c[<span class=\"number\">1</span>].v);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B:\"></a>B:</h1><p>被C题耽误了，没时间想。。。</p>\n<p>不难想到给 $A$ 数组排个序，这样可以线段树上二分出当前第一个 $\\ge b$ 的位置 $pos$。将 $[pos,n]$ 这段区间设为 $b$ 即可。然后每一次操作都要整体加一下，因此线段树需要写区间赋值，区间加。因为只求总共割掉了多少，因此直接看根节点的值就行了。注意由于要在线段树上二分，所以为了方便我记了一个最大值。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">const</span> ll x, <span class=\"keyword\">const</span> ll y)</span> </span>&#123;<span class=\"keyword\">return</span> x &gt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">\tll l, r, v, mx, Lazy1, Lazy2;</span><br><span class=\"line\">&#125; c[<span class=\"number\">2000005</span>];</span><br><span class=\"line\">ll a[<span class=\"number\">500005</span>], s[<span class=\"number\">500005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O)</span> </span>&#123;</span><br><span class=\"line\">\tconst ll llen(c[O &lt;&lt; 1].r - c[O &lt;&lt; 1].l + 1), rlen(c[O &lt;&lt; 1 | 1].r - c[O &lt;&lt; 1 | 1].l + 1);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c[O].Lazy2 != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\tc[O &lt;&lt; <span class=\"number\">1</span>].Lazy2 = c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].Lazy2 = c[O].Lazy2;</span><br><span class=\"line\">\t\tc[O &lt;&lt; <span class=\"number\">1</span>].v = llen * c[O].Lazy2, c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v = rlen * c[O].Lazy2;</span><br><span class=\"line\">\t\tc[O &lt;&lt; <span class=\"number\">1</span>].mx = c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mx = c[O].Lazy2;</span><br><span class=\"line\">\t\tc[O &lt;&lt; <span class=\"number\">1</span>].Lazy1 = c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].Lazy1 = <span class=\"number\">0LL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc[O &lt;&lt; <span class=\"number\">1</span>].v += (s[c[O &lt;&lt; <span class=\"number\">1</span>].r] - s[c[O &lt;&lt; <span class=\"number\">1</span>].l - <span class=\"number\">1</span>]) * c[O].Lazy1;</span><br><span class=\"line\">\tc[O &lt;&lt; <span class=\"number\">1</span>].Lazy1 += c[O].Lazy1;</span><br><span class=\"line\">\tc[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v += (s[c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].r] - s[c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].l - <span class=\"number\">1</span>]) * c[O].Lazy1;</span><br><span class=\"line\">\tc[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].Lazy1 += c[O].Lazy1;</span><br><span class=\"line\">\tc[O &lt;&lt; <span class=\"number\">1</span>].mx += c[O].Lazy1 * a[c[O &lt;&lt; <span class=\"number\">1</span>].r], c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mx += c[O].Lazy1 * a[c[O].r];</span><br><span class=\"line\">\tc[O].Lazy1 = <span class=\"number\">0LL</span>, c[O].Lazy2 = <span class=\"number\">-1LL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O)</span> </span>&#123;</span><br><span class=\"line\">\tc[O].v = c[O &lt;&lt; <span class=\"number\">1</span>].v + c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v;</span><br><span class=\"line\">\tc[O].mx = <span class=\"built_in\">max</span>(c[O &lt;&lt; <span class=\"number\">1</span>].mx, c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mx);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make_tree</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">\tc[O].l = L, c[O].r = R, c[O].Lazy2 = <span class=\"number\">-1LL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L != R) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span>, L, L + R &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, (L + R &gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>, R);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Set</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R, <span class=\"keyword\">const</span> ll d)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &gt; R) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= c[O].l &amp;&amp; c[O].r &lt;= R) &#123;</span><br><span class=\"line\">\t\tc[O].v = d * (c[O].r - c[O].l + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tc[O].Lazy1 = <span class=\"number\">0LL</span>, c[O].Lazy2 = c[O].mx = d;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(c[O].l + c[O].r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">pushdown</span>(O);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= mid) <span class=\"built_in\">Set</span>(O &lt;&lt; <span class=\"number\">1</span>, L, R, d);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mid &lt; R) <span class=\"built_in\">Set</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, L, R, d);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(O);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R, <span class=\"keyword\">const</span> ll d)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= c[O].l &amp;&amp; c[O].r &lt;= R) &#123;</span><br><span class=\"line\">\t\tc[O].v += d * (s[c[O].r] - s[c[O].l - <span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\tc[O].Lazy1 += d, c[O].mx += a[c[O].r] * d;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(c[O].l + c[O].r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">pushdown</span>(O);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= mid) <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span>, L, R, d);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mid &lt; R) <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, L, R, d);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(O);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c[O].mx &lt;= x) <span class=\"keyword\">return</span> c[O].r + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c[O].l == c[O].r) <span class=\"keyword\">return</span> c[O].l;</span><br><span class=\"line\">\t<span class=\"built_in\">pushdown</span>(O);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c[O &lt;&lt; <span class=\"number\">1</span>].mx &gt; x) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(O &lt;&lt; <span class=\"number\">1</span>, x);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m, <span class=\"built_in\">pred</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, a + i);</span><br><span class=\"line\">\tstd::<span class=\"built_in\">sort</span>(a + <span class=\"number\">1</span>, a + n + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) s[i] = s[i - <span class=\"number\">1</span>] + a[i];</span><br><span class=\"line\">\t<span class=\"built_in\">make_tree</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (m --) &#123;</span><br><span class=\"line\">\t\tll d, b;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;d, &amp;b);</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, d - pred);</span><br><span class=\"line\">\t\tpred = d;</span><br><span class=\"line\">\t\t<span class=\"function\">ll <span class=\"title\">t</span><span class=\"params\">(c[<span class=\"number\">1</span>].v)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">Set</span>(<span class=\"number\">1</span>, <span class=\"built_in\">query</span>(<span class=\"number\">1</span>, b), n, b);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld\\n&quot;</span>, t - c[<span class=\"number\">1</span>].v);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C:\"></a>C:</h1><p>考场上送我爆零的题。</p>\n<p>考虑暴力。自然就是 $dp_{i,j}$ 表示完成了前 $i$ 个操作，其中位置不在 $x_i$ 上的棋子的位置为 $j$。对于所有的 $dp_{i,j}$，$dp_{i,j}=dp_{i-1,j}+abs(x_i-x_{i-1})$。对于 $dp_{i,x_{i-1}}$，$dp_{i,x_{i-1}}=min(dp_{i-1,j}+abs(x_i-j))$。展开绝对值分类讨论即可。</p>\n<p>滚动<code>dp</code>数组然后，对于每个操作，$dp$ 数组先整体加上 $abs(x_i-x_{i-1})$。单独考虑 $dp_{i,x_{i-1}}$。这里对于 $j\\le x_i$ 的取一个min,对于 $j\\ge x_i$ 取一个min。显然两颗线段树优化。</p>\n<p>草稿本上的式子抄错调了2h无果，不愧是我。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Tree1 Tree[0]</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Tree2 Tree[1]</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Tree3 Tree[2]</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 100000000000000000LL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">abs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> k)</span> </span>&#123;<span class=\"keyword\">return</span> k &gt;= <span class=\"number\">0</span> ? k : -k;&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> x[<span class=\"number\">200005</span>], tot;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Segment_tree</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> l, r, v, Lazy;</span><br><span class=\"line\">\t&#125; c[<span class=\"number\">1000005</span>];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make_tree</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">\t\tc[O].l = L, c[O].r = R, c[O].v = INF;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (L != R) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span>, L, L + R &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, (L + R &gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>, R);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O)</span> </span>&#123;</span><br><span class=\"line\">\t\tc[O &lt;&lt; <span class=\"number\">1</span>].v += c[O].Lazy, c[O &lt;&lt; <span class=\"number\">1</span>].Lazy += c[O].Lazy;</span><br><span class=\"line\">\t\tc[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v += c[O].Lazy, c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].Lazy += c[O].Lazy;</span><br><span class=\"line\">\t\tc[O].Lazy = <span class=\"number\">0LL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> p, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c[O].l == c[O].r) &#123;c[O].v = <span class=\"built_in\">min</span>(c[O].v, d); <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushdown</span>(O);</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(c[O].l + c[O].r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p &lt;= mid) <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span>, p, d);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, p, d);</span><br><span class=\"line\">\t\tc[O].v = <span class=\"built_in\">min</span>(c[O &lt;&lt; <span class=\"number\">1</span>].v, c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (L &gt; R) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (L &lt;= c[O].l &amp;&amp; c[O].r &lt;= R) &#123;c[O].v += d, c[O].Lazy += d; <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(c[O].l + c[O].r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushdown</span>(O);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (L &lt;= mid) <span class=\"built_in\">Add</span>(O &lt;&lt; <span class=\"number\">1</span>, L, R, d);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (mid &lt; R) <span class=\"built_in\">Add</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, L, R, d);</span><br><span class=\"line\">\t\tc[O].v = <span class=\"built_in\">min</span>(c[O &lt;&lt; <span class=\"number\">1</span>].v, c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (L &gt; R) <span class=\"keyword\">return</span> INF;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (L &lt;= c[O].l &amp;&amp; c[O].r &lt;= R) <span class=\"keyword\">return</span> c[O].v;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(c[O].l + c[O].r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushdown</span>(O);</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ans</span><span class=\"params\">(INF)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (L &lt;= mid) ans = <span class=\"built_in\">min</span>(ans, <span class=\"built_in\">query</span>(O &lt;&lt; <span class=\"number\">1</span>, L, R));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (mid &lt; R) ans = <span class=\"built_in\">min</span>(ans, <span class=\"built_in\">query</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, L, R));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; Tree[<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, q, A, B;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;q, &amp;A, &amp;B);</span><br><span class=\"line\">\tTree1.<span class=\"built_in\">make_tree</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">\tTree2.<span class=\"built_in\">make_tree</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">\tTree3.<span class=\"built_in\">make_tree</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">\tx[tot = <span class=\"number\">1</span>] = A;</span><br><span class=\"line\">\tTree1.<span class=\"built_in\">update</span>(<span class=\"number\">1</span>, B, -B);</span><br><span class=\"line\">\tTree2.<span class=\"built_in\">update</span>(<span class=\"number\">1</span>, B, B);</span><br><span class=\"line\">\tTree3.<span class=\"built_in\">update</span>(<span class=\"number\">1</span>, B, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (q --) &#123;</span><br><span class=\"line\">\t\t++ tot; </span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, &amp;x[tot]);</span><br><span class=\"line\">\t\tint ret(min(x[tot] + Tree1.query(1, 1, x[tot]), Tree2.query(1, x[tot], n) - x[tot])), add();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt;= <span class=\"number\">2</span>; ++ i)</span><br><span class=\"line\">\t\t\tTree[i].<span class=\"built_in\">Add</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, <span class=\"built_in\">abs</span>(x[tot] - x[tot - <span class=\"number\">1</span>]));</span><br><span class=\"line\">\t\tTree1.<span class=\"built_in\">update</span>(<span class=\"number\">1</span>, x[tot - <span class=\"number\">1</span>], ret - x[tot - <span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\tTree2.<span class=\"built_in\">update</span>(<span class=\"number\">1</span>, x[tot - <span class=\"number\">1</span>], ret + x[tot - <span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\tTree3.<span class=\"built_in\">update</span>(<span class=\"number\">1</span>, x[tot - <span class=\"number\">1</span>], ret);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, Tree3.<span class=\"built_in\">query</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["比赛"],"tags":["比赛"]},{"title":"nkoj-7906题解","url":"/2021/02/27/nkoj-7906/","content":"<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><span id=\"more\"></span>\n<p>略。</p>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p>很神奇的好题。</p>\n<p>对于这种题目第一眼就会想到万能的暴力状压。然后我们规定一下这些数字对排列的顺序以使其变为一般DP优化复杂度：对于两个数对 $i,j$，当且仅当 $a_i&gt;b_j,b_i\\le a_j$ 时， $i$ 必须排在 $j$ 前面。即 $a_i+a_j\\le b_i+b_j$  时，$i$ 一定能排在 $j$ 前面（但不一定必须排在 $j$ 前面）。于是把原来的数对排个序。</p>\n<p>$dp_{i,j}$ 表示考虑到了第 $i$ 个数对。当前选择了的最小的 $a_i$ 为 $j$，最多能选多少对出来。</p>\n<p>转移方程：</p>\n<p>$dp_{i,a_i}=max^{\\infty}_{a_i}+1$（选择第 $i$ 个数对，且 $a_i$ 为最小值）</p>\n<p>$dp_{i,j}=dp_{i-1,j}+1(b_i&lt; j\\le a_i)$（选择第 $i$ 个数对，且之前已经出现过了比当前的 $a_i$ 更大的 $a$ 值）</p>\n<p>否则 $dp_{i,j}=dp{i-1,j}$ （无法接上第 $i$ 个数对）</p>\n<p>注意 $a_i\\le b_i$ 时第二条转移方程不适用，且第一条方程要改为 $dp_{i,b_i+1}=max^{\\infty}_{a_i}+1$</p>\n<p>注意，上面的转移方程相对于上一个阶段，仅仅是将一段区间的状态加上了 $1$，对 $dp_{i,a_i}$ 单独计算。这样重新暴力计算这个阶段是很浪费的，用线段树维护即可。</p>\n<h1 id=\"texttt-Code\"><a href=\"#texttt-Code\" class=\"headerlink\" title=\"$\\texttt{Code}$\"></a>$\\texttt{Code}$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &gt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l, r, v, Lazy;</span><br><span class=\"line\">&#125; c[<span class=\"number\">800005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make_tree</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">\tc[O].l = L, c[O].r = R;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L != R) <span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span>, L, L + R &gt;&gt; <span class=\"number\">1</span>), <span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, (L + R &gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>, R);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O)</span> </span>&#123;</span><br><span class=\"line\">\tc[O &lt;&lt; <span class=\"number\">1</span>].v += c[O].Lazy, c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v += c[O].Lazy;</span><br><span class=\"line\">\tc[O &lt;&lt; <span class=\"number\">1</span>].Lazy += c[O].Lazy, c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].Lazy += c[O].Lazy;</span><br><span class=\"line\">\tc[O].Lazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= c[O].l &amp;&amp; c[O].r &lt;= R) &#123;c[O].v += d, c[O].Lazy += d; <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(c[O].l + c[O].r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">pushdown</span>(O);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= mid) <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span>, L, R, d);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mid &lt; R) <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, L, R, d);</span><br><span class=\"line\">\tc[O].v = <span class=\"built_in\">max</span>(c[O &lt;&lt; <span class=\"number\">1</span>].v, c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= c[O].l &amp;&amp; c[O].r &lt;= R) <span class=\"keyword\">return</span> c[O].v;</span><br><span class=\"line\">\tint mid(c[O].l + c[O].r &gt;&gt; 1), ans(0);</span><br><span class=\"line\">\t<span class=\"built_in\">pushdown</span>(O);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= mid) ans = <span class=\"built_in\">query</span>(O &lt;&lt; <span class=\"number\">1</span>, L, R);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mid &lt; R) ans = <span class=\"built_in\">max</span>(ans, <span class=\"built_in\">query</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, L, R));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">\t<span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> node X) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> a + b &gt; X.a + X.b;&#125;</span><br><span class=\"line\">&#125; a[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> b[<span class=\"number\">200005</span>], A[<span class=\"number\">100005</span>], B[<span class=\"number\">100005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;a[i].a, &amp;a[i].b);</span><br><span class=\"line\">\tstd::<span class=\"built_in\">sort</span>(a + <span class=\"number\">1</span>, a + n + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) b[<span class=\"number\">2</span> * i - <span class=\"number\">1</span>] = a[i].a, b[<span class=\"number\">2</span> * i] = a[i].b;</span><br><span class=\"line\">\tstd::<span class=\"built_in\">sort</span>(b + <span class=\"number\">1</span>, b + <span class=\"number\">2</span> * n + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) &#123;</span><br><span class=\"line\">\t\tA[i] = std::<span class=\"built_in\">lower_bound</span>(b + <span class=\"number\">1</span>, b + <span class=\"number\">2</span> * n + <span class=\"number\">1</span>, a[i].a) - b;</span><br><span class=\"line\">\t\tB[i] = std::<span class=\"built_in\">lower_bound</span>(b + <span class=\"number\">1</span>, b + <span class=\"number\">2</span> * n + <span class=\"number\">1</span>, a[i].b) - b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">make_tree</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n &lt;&lt; <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (A[i] &lt;= B[i]) <span class=\"built_in\">update</span>(<span class=\"number\">1</span>, A[i], A[i], <span class=\"built_in\">query</span>(<span class=\"number\">1</span>, B[i] + <span class=\"number\">1</span>, <span class=\"number\">2</span> * n) - <span class=\"built_in\">query</span>(<span class=\"number\">1</span>, A[i], A[i]) + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">update</span>(<span class=\"number\">1</span>, A[i], A[i], <span class=\"built_in\">query</span>(<span class=\"number\">1</span>, A[i], n &lt;&lt; <span class=\"number\">1</span>) - <span class=\"built_in\">query</span>(<span class=\"number\">1</span>, A[i], A[i]));</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">update</span>(<span class=\"number\">1</span>, B[i] + <span class=\"number\">1</span>, A[i], <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, <span class=\"built_in\">query</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n &lt;&lt; <span class=\"number\">1</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["DP","数据结构"],"tags":["线段树","DP"]},{"title":"洛谷P3582 [POI2015]KIN 题解","url":"/2021/02/27/luogu-P3582/","content":"<p><del>又是蒟蒻水题解的地方</del></p>\n<span id=\"more\"></span>\n<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><p><a href=\"https://www.luogu.com.cn/problem/P3582\">题面友好，不做解释</a></p>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p>考试的时候没做出来。赛后才知道这是一个套路题。</p>\n<p>对于这种“选出一段区间，要求总贡献最大”的题目，尝试沿用这样一种思路：从左往右枚举左端点，快速找到最优的右端点。本题我从右往左扫，因为比较方便。</p>\n<p>$nxt_i$ 表示第 $i$ 部电影后面的第一部与它相同的电影在第几天放映。</p>\n<p>然后从右往左枚举区间左端点，线段树维护对于当前的左端点，每个右端点能得到的贡献。当右端点由 $r+1$ 变为 $r$ 时，将 $[r,nxt_r)$ 区间加上 $w_{f_i}$，将 $nxt_{nxt_i}$ 区间减少 $w_{f_i}$。这个比较容易理解。</p>\n<h1 id=\"texttt-Code\"><a href=\"#texttt-Code\" class=\"headerlink\" title=\"$\\texttt{Code}$\"></a>$\\texttt{Code}$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &gt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l, r, v, Lazy;</span><br><span class=\"line\">&#125; c[<span class=\"number\">4000005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> wow[<span class=\"number\">4000005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make_tree</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">\tc[O].l = L, c[O].r = R;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L != R) <span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span>, L, L + R &gt;&gt; <span class=\"number\">1</span>), <span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, (L + R &gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>, R);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O)</span> </span>&#123;</span><br><span class=\"line\">\tc[O &lt;&lt; <span class=\"number\">1</span>].v += c[O].Lazy, c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v += c[O].Lazy;</span><br><span class=\"line\">\tc[O &lt;&lt; <span class=\"number\">1</span>].Lazy += c[O].Lazy, c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].Lazy += c[O].Lazy;</span><br><span class=\"line\">\tc[O].Lazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= c[O].l &amp;&amp; c[O].r &lt;= R) &#123;c[O].Lazy += d, c[O].v += d; <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(c[O].l + c[O].r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">pushdown</span>(O);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= mid) <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span>, L, R, d);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mid &lt; R) <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, L, R, d);</span><br><span class=\"line\">\tc[O].v = <span class=\"built_in\">max</span>(c[O &lt;&lt; <span class=\"number\">1</span>].v, c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> f[<span class=\"number\">1000005</span>], w[<span class=\"number\">1000005</span>], nxt[<span class=\"number\">1000005</span>], pre[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m, <span class=\"built_in\">ans</span>(<span class=\"number\">0LL</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, f + i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= m; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, w + i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) nxt[pre[f[i]]] = i, pre[f[i]] = i;</span><br><span class=\"line\">\t<span class=\"built_in\">make_tree</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(n); i; -- i)  &#123;<span class=\"comment\">//枚举右端点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nxt[i]) <span class=\"built_in\">update</span>(<span class=\"number\">1LL</span>, i, nxt[i] - <span class=\"number\">1LL</span>, w[f[i]]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(<span class=\"number\">1LL</span>, i, n, w[f[i]]);<span class=\"comment\">//特判边界</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nxt[i]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (nxt[nxt[i]]) <span class=\"built_in\">update</span>(<span class=\"number\">1LL</span>, nxt[i], nxt[nxt[i]] - <span class=\"number\">1LL</span>, -w[f[i]]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(<span class=\"number\">1LL</span>, nxt[i], n, -w[f[i]]);<span class=\"comment\">//特判边界</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans = <span class=\"built_in\">max</span>(ans, c[<span class=\"number\">1</span>].v);<span class=\"comment\">//由于是整体取最大值，可以少写一个查询函数，直接取根节点的值即可</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, ans);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"texttt-Summary\"><a href=\"#texttt-Summary\" class=\"headerlink\" title=\"$\\texttt{Summary}$\"></a>$\\texttt{Summary}$</h1><p>这种经典的套路题还是有必要总结一下的。</p>\n<p>首先，这种“选择一段区间，使其总贡献最大/总花费最小”的题目，应该立即反应到枚举左端点，快速找到最优右端点的方法。典型如<a href=\"https://www.luogu.com.cn/problem/UVA1471\">UVA1471</a></p>\n<p>其次，类似“重复的只算一次”（本题一次都不算），”求种类数”的题，一般是记录 $nxt_i$ 表示第 $i$ 个“数”后面与它种类相同的“数”，然后采用树状数组/线段树等支持区修区查或单修区查的数据结构来维护对应右端点的取值。典型如<a href=\"https://www.luogu.com.cn/problem/P1972\">HH的项链</a></p>\n<p>end.</p>\n","tags":["线段树"]},{"title":"洛谷P5610题解","url":"/2021/02/16/luogu-P5610/","content":"<p>Ynoi二血（</p>\n<span id=\"more\"></span>\n<h1 id=\"texttt-Desciption\"><a href=\"#texttt-Desciption\" class=\"headerlink\" title=\"$\\texttt{Desciption}$\"></a>$\\texttt{Desciption}$</h1><p>这题题面友好，直接<a href=\"https://www.luogu.com.cn/problem/P5610\">看题面</a></p>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p>考虑到一个数的质因数个数最多不会超过 $O(logn)$ 个，因此除法最多只会执行 $O(nlogn)$ 次。</p>\n<p>那么如何找出一段区间内能被 $x$ 整除的数呢？</p>\n<p>把<strong>一开始</strong>所有能被 $x$ 整除的数放到一个数据结构 $s_x$ 中，这个数据结构里面从小到大存储着这些一开始能被 $x$ 整除的数的下标。每次我们需要查询<code>lower_bound</code>（查询第一个下标大于等于 $l$ 的位置），删除（有可能这个数一开始能被整除但除着除着就变了，比如 $20$ 能被 $2$ 整除，但 $20$ 除了 $4$ 后就不能了）。</p>\n<p><del>作为一个不会写平衡树的智障，我……</del></p>\n<p>貌似我见过这种套路，大概是用一个并查集维护它后面（包括它自己）距离它最近的没被删除的位置。每删除 $i$ 位置，$fa_i=find(i+1)$ 即可。</p>\n<p>然后用BIT维护区间和即可。注意维护原始的 $a$ 数组。</p>\n<p>时间复杂度？不好说，大概 $O(n\\sqrt{n}+nlogn+mlogn)$？</p>\n<p>于是你愉快的被卡常卡成66……</p>\n<h1 id=\"优化卡常：\"><a href=\"#优化卡常：\" class=\"headerlink\" title=\"优化卡常：\"></a><del>优化</del>卡常：</h1><p><del>卡常指导：monsters谔谔神犇</del></p>\n<ol>\n<li><p>众所周知，由乃题应该先打<code>fread</code>再打正解。</p>\n</li>\n<li><p>你会发现 $O(n\\sqrt{n})$ 的复杂度非常的不优秀，于是改为桶+筛法分解质因数。</p>\n</li>\n<li><p>你会发现这样需要对下标排序。但是一排序反而越来越慢，因此我们在每次操作的时候再排序，用一个 $vis$ 数组记录是否排过序。</p>\n</li>\n<li><p>你会发现还是会T，所以我们排序的时候判断一下顺序，如果已经是顺序了那么就不用排序了。</p>\n</li>\n<li><p>用vector还想过Ynoi？手写内存池即可。</p>\n</li>\n<li><p>最后，反正我的代码到这里就过了，如果你还是T，建议手动二分内存池大小。</p>\n</li>\n</ol>\n<h1 id=\"texttt-Code\"><a href=\"#texttt-Code\" class=\"headerlink\" title=\"$\\texttt{Code}$\"></a>$\\texttt{Code}$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> gc (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 65536, stdin), p1 == p2) ? EOF : *p1 ++)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">65536</span>], *p1, *p2;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">x</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((ch = gc) &lt; <span class=\"number\">48</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> x = x * <span class=\"number\">10</span> + ch - <span class=\"number\">48</span>; <span class=\"keyword\">while</span> ((ch = gc) &gt;= <span class=\"number\">48</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">500005</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &gt; y ? x : y;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[N], mem[<span class=\"number\">45000005</span>], tot, n;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Vector</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stpos, endpos;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t\tstpos ? mem[endpos = ++ tot] = x : mem[stpos = endpos = ++ tot] = x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">inline</span> <span class=\"keyword\">int</span>&amp; <span class=\"keyword\">operator</span> [] (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> mem[stpos + x];&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span>* <span class=\"title\">begin</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> mem + stpos;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> *<span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> mem + endpos + <span class=\"number\">1</span>;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> stpos ? endpos - stpos + <span class=\"number\">1</span> : <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> !stpos;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> c[N];</span><br><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt; cnt[N];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(x); i &lt;= n; i += (i &amp; ~i + <span class=\"number\">1</span>)) c[i] += d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"number\">0LL</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(x); i; i -= (i &amp; ~i + <span class=\"number\">1</span>)) sum += c[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Reap</span> &#123;</span></span><br><span class=\"line\">\tVector fac, fa;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;<span class=\"keyword\">return</span> fa[x] == x ? x : fa[x] = <span class=\"built_in\">find</span>(fa[x]);&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">upd</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> l, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> r, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[x]) &#123;</span><br><span class=\"line\">\t\t\tvis[x] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (fac.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">flag</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt; fac.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; ++ i)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (fac[i] &gt; fac[i + <span class=\"number\">1</span>]) &#123;flag = <span class=\"number\">1</span>; <span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (flag) std::<span class=\"built_in\">sort</span>(fac.<span class=\"built_in\">begin</span>(), fac.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt;= fac.<span class=\"built_in\">size</span>(); ++ i) fa.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fac.<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i</span><span class=\"params\">(find(std::lower_bound(fac.begin(), fac.end(), l) - fac.begin()))</span></span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i &lt; fac.<span class=\"built_in\">size</span>() &amp;&amp; fac[i] &lt;= r) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[fac[i]] % x) fa[i] = <span class=\"built_in\">find</span>(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(fac[i], a[fac[i]] / x - a[fac[i]]), a[fac[i]] /= x;</span><br><span class=\"line\">\t\t\ti = <span class=\"built_in\">find</span>(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; s[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m, <span class=\"built_in\">t</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">last</span><span class=\"params\">(<span class=\"number\">0LL</span>)</span></span>;</span><br><span class=\"line\">\tn = <span class=\"built_in\">read</span>(), m = <span class=\"built_in\">read</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\tt = <span class=\"built_in\">max</span>(t, a[i] = <span class=\"built_in\">read</span>()), <span class=\"built_in\">update</span>(i, a[i]), cnt[a[i]].<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">2</span>); i &lt;= t; ++ i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(i); j &lt;= t; j += i)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> k : cnt[j]) s[i].fac.<span class=\"built_in\">push_back</span>(k);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (m --) &#123;</span><br><span class=\"line\">\t\tint op(read()), l(read() ^ last), r(read() ^ last), x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\tx = <span class=\"built_in\">read</span>() ^ last;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x != <span class=\"number\">1</span>) s[x].<span class=\"built_in\">upd</span>(l, r, x);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld\\n&quot;</span>, last = <span class=\"built_in\">query</span>(r) - <span class=\"built_in\">query</span>(l - <span class=\"number\">1</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数据结构"],"tags":["树状数组","并查集"]},{"title":"洛谷P5068题解","url":"/2021/02/16/luogu-P5068/","content":"<p>这里是被楼上Froggy大佬<del>点名爆踩</del>的做法qaq。</p>\n<span id=\"more\"></span>\n<p><del>废话有点多，不想看直接跳</del></p>\n<blockquote>\n<p>在太阳西斜的这个世界里，置身天上之森。 等这场战争结束之后，不归之人与望眼欲穿的众人，人人本着正义之名。 长存不灭的过去；逐渐消逝的未来。 我回来了，纵使日薄西山，即便看不到未来，此时此刻的光辉，盼君勿忘。</p>\n<p>————世界上最幸福的女孩 珂朵莉</p>\n</blockquote>\n<p>不愧是Ynoi，如此毒瘤。</p>\n<p>这是我Ynoi一血<del>初始化那题暴力艹过去的</del>qaq。</p>\n<p><del>想了一个小时，深感此题毒瘤</del></p>\n<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><p>给你一个序列，每次操作可以增加一个数，也可以查询对于一个数 $x$，将这个序列从小到大排序后找到最小的 $i$ 满足 $\\lceil \\frac{a_{i+1}}{x}\\rceil -1&gt; \\lceil \\frac{a_i}{x}\\rceil$（若当前序列长度为 $n$，令 $a_{n+1}=\\infty$）</p>\n<h1 id=\"texttt-Solution\"><a href=\"#texttt-Solution\" class=\"headerlink\" title=\"$\\texttt{Solution}$\"></a>$\\texttt{Solution}$</h1><p>题目说了 $h\\le n\\le 10^5$，因此我们盲猜这题要用权值线段树or权值树状数组。再看到每次查询一段区间的期望值，还要乘上这段区间的长度，其实就是求每种方案的总和，查询区间 $[l,r]$ 对应的答案的总和……再一看数据范围，显然要用一个支持修改和区间查询的数据结构维护答案。</p>\n<p>$n\\le 10^5,m\\le 10^6$，<del>Ynoi不用分块惹爷青结</del></p>\n<p>至于如何维护答案，我们将每个随从的血量放到一个权值树状数组里面，每次增加一个随从，找到被他影响的答案，然后暴力调整即可。</p>\n<p>为什么说是暴力调整呢？</p>\n<p>形象的理解一下，上面向上取整可以理解为对这个权值树状数组进行分块。数组的每个值 $d_i$ 表示血量为 $d_i$ 的随从的数目。块长为 $x$，我们要求的就是最早哪个块里面的数字均为 $0$。</p>\n<p>由于 $x$ 的取值在 $[1,n]$ 之间，所以每次暴力往后跳最多也就不跳超过 $\\sum\\limits^{i\\le n}_{i=1}\\frac{n}{i}\\approx nlogn$。</p>\n<p>每次跳的时候查询一下树状数组，当前这个块是否全部为 $0$，如果不是就往后跳。</p>\n<p>现在的问题是不可能每加进来一个随从就把所有块往后跳，因为就算总共跳的次数少，把这些块遍历一遍也需要 $O(n)$ 的时间。因此我们需要找到对于当前血量为 $h$ 的随从，有多少块经过了 $h$ 这个点。将这些块全部删除并往后跳，再把新的块插入进去。</p>\n<p>现在需要一种数据结构，支持三种操作：</p>\n<ul>\n<li>插入一条线段</li>\n<li>删除一条线段</li>\n<li>查询经过了给定点的所有线段</li>\n</ul>\n<p>对于给定点 $h$，经过它的线段左端点必然在 $[1,h]$ 之间，不妨把每条线段的左端点看做下标，则我们每次查询左端点在 $[1,h]$ 之间的线段右端点最大的，将它往后调整后删除，直到当前查询到的最大右端点 $&lt;h$ 为止。就是一个动态的RMQ，我使用线段树维护。（当然可能有多个线段左端点一样，因此线段树每个叶子节点对应一个大根堆而不是一个数）。</p>\n<p>然后维护一个表示答案的树状数组，每次暴力往后跳块后就要更新它。</p>\n<p>貌似很多神仙用<code>set</code>被卡常了，显然用<code>set</code>常数比堆大得多啊……</p>\n<h1 id=\"texttt-Code\"><a href=\"#texttt-Code\" class=\"headerlink\" title=\"$\\texttt{Code}$\"></a>$\\texttt{Code}$</h1><p>由于没有刻意卡常，所以是我的正常马蜂。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Re(x) (RMQ::a[x].size() ? RMQ::a[x].top() : 0)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">5e5</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> RMQ &#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> l, r, v;</span><br><span class=\"line\">\t&#125; c[N &lt;&lt; <span class=\"number\">4</span>];</span><br><span class=\"line\">\tstd::priority_queue&lt;<span class=\"keyword\">int</span>&gt; a[N];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make_tree</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">\t\tc[O].l = L, c[O].r = R;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (L == R) &#123;c[O].v = L; <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span>, L, L + R &gt;&gt; <span class=\"number\">1</span>), <span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, (L + R &gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>, R);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">Re</span>(c[O &lt;&lt; <span class=\"number\">1</span>].v) &gt;= <span class=\"built_in\">Re</span>(c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v)) c[O].v = c[O &lt;&lt; <span class=\"number\">1</span>].v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> c[O].v = c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c[O].l == c[O].r) &#123;a[x].<span class=\"built_in\">push</span>(d); <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c[O &lt;&lt; <span class=\"number\">1</span>].r &gt;= x) <span class=\"built_in\">insert</span>(O &lt;&lt; <span class=\"number\">1</span>, x, d);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">insert</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, x, d);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">Re</span>(c[O &lt;&lt; <span class=\"number\">1</span>].v) &gt;= <span class=\"built_in\">Re</span>(c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v)) c[O].v = c[O &lt;&lt; <span class=\"number\">1</span>].v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> c[O].v = c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">del</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c[O].l == c[O].r) &#123;</span><br><span class=\"line\">\t\t\ta[x].<span class=\"built_in\">pop</span>(), c[O].v = x;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c[O &lt;&lt; <span class=\"number\">1</span>].r &gt;= x) <span class=\"built_in\">del</span>(O &lt;&lt; <span class=\"number\">1</span>, x);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">del</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, x);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">Re</span>(c[O &lt;&lt; <span class=\"number\">1</span>].v) &gt;= <span class=\"built_in\">Re</span>(c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v)) c[O].v = c[O &lt;&lt; <span class=\"number\">1</span>].v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> c[O].v = c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (L &lt;= c[O].l &amp;&amp; c[O].r &lt;= R) <span class=\"keyword\">return</span> c[O].v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c[O &lt;&lt; <span class=\"number\">1</span>].r &lt; L) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, L, R);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].l &gt; R) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(O &lt;&lt; <span class=\"number\">1</span>, L, R);</span><br><span class=\"line\">\t\tint t1(query(O &lt;&lt; 1, L, R)), t2(query(O &lt;&lt; 1 | 1, L, R));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">Re</span>(t1) &gt;= <span class=\"built_in\">Re</span>(t2) ? t1 : t2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BIT</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> c[N];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(x); i &lt;= N; i += (i &amp; ~i + <span class=\"number\">1</span>)) c[i] += d;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(x); i; i -= (i &amp; ~i + <span class=\"number\">1</span>)) sum += c[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; summary, ans;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\tans.<span class=\"built_in\">update</span>(i, <span class=\"number\">1</span>), RMQ::a[<span class=\"number\">1</span>].<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">\tRMQ::<span class=\"built_in\">make_tree</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (m --) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> op;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, &amp;op);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> h;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, &amp;h);</span><br><span class=\"line\">\t\t\tsummary.<span class=\"built_in\">update</span>(h, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> p;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> ((<span class=\"built_in\">Re</span>(p = RMQ::<span class=\"built_in\">query</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, h))) &gt;= h) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">len</span><span class=\"params\">(RMQ::a[p].top() - p)</span></span>;</span><br><span class=\"line\">\t\t\t\tans.<span class=\"built_in\">update</span>(len + <span class=\"number\">1</span>, -(p - <span class=\"number\">1</span>) / (len + <span class=\"number\">1</span>) - <span class=\"number\">1</span>), RMQ::<span class=\"built_in\">del</span>(<span class=\"number\">1</span>, p);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (summary.<span class=\"built_in\">query</span>(p + len) - summary.<span class=\"built_in\">query</span>(p - <span class=\"number\">1</span>)) p += len + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\tans.<span class=\"built_in\">update</span>(len + <span class=\"number\">1</span>, (p - <span class=\"number\">1</span>) / (len + <span class=\"number\">1</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (p &lt;= n) RMQ::<span class=\"built_in\">insert</span>(<span class=\"number\">1</span>, p, p + len);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> l, r;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld\\n&quot;</span>, ans.<span class=\"built_in\">query</span>(r) - ans.<span class=\"built_in\">query</span>(l - <span class=\"number\">1</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数据结构"],"tags":["线段树","树状数组"]},{"title":"洛谷P2221题解","url":"/2021/02/16/luogu-P2221/","content":"<p><del>终于A了，我马上跳楼庆祝！</del></p>\n<span id=\"more\"></span>\n<p>人在老家，回去了再搬到个人博客。</p>\n<p>由于我做这题做出了史诗级的血泪史，所以写的会比较细。</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P2221\">传送门</a></p>\n<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}$\"></a>$\\texttt{Description}$</h1><p>给你一个数列 $a$，长度为 $n-1$，每次操作可以将一段区间内的数字加上 $v$，也可以查询 $\\sum\\limits^{i\\le r}_{i=l}\\sum\\limits^{j\\le r}_{j=i}\\sum\\limits^{k\\le r}_{k=l} a_i$。</p>\n<p>然后你会发现这题挂着期望的标签其实就是套着期望的外壳出数据结构题。</p>\n<h1 id=\"texttt-solution\"><a href=\"#texttt-solution\" class=\"headerlink\" title=\"$\\texttt{solution}$\"></a>$\\texttt{solution}$</h1><ul>\n<li>采用什么数据结构？</li>\n</ul>\n<p><del>别告诉我你连这是个数据结构题都看不出来</del></p>\n<p>数据范围 $n\\le 10^5$。这是省选题，不可能给你太宽裕的时限，所以大概就是 $O(n\\sqrt{n})$ 的分块或者 $O(nlogn)$ 的巨大常数线段树。个人更喜欢线段树，所以一开始就往线段树方面想了（主要是感觉这题线段树好做）。</p>\n<ul>\n<li>线段树的每个节点维护什么？</li>\n</ul>\n<p>设这个节点表示的区间为 $[l,r]$，则维护一个值 $w$ 表示 $\\sum\\limits^{i\\le r}_{i=l}\\sum\\limits^{j\\le r}_{j=i}\\sum\\limits^{k\\le r}_{k=l} a_i$。</p>\n<ul>\n<li>如何合并左右子树的信息？</li>\n</ul>\n<p>左右子树光有这个 $w$ 显然我们没法合并。因为要考虑跨过左右子树的区间。那么，设左子树表示的区间为 $[l,mid]$，<del>柚子树</del>右子树表示的区间为 $[mid+1,r]$。</p>\n<p>那么跨过左右子树的区间和就是：</p>\n<p>$(r-mid)\\times \\sum\\limits^{i\\le mid}_{i=l}a_i\\times (i-l+1)+(mid-l+1)\\times \\sum\\limits^{i\\le r}_{i=mid+1}a_i\\times (r-i+1)$。</p>\n<p>式子看起来挺恶心，但是我们会发现加号左边的部分就是左子树表示的区间的<strong>前缀和之和</strong>乘上右子树表示的区间的长度，加号右边的就是右子树表示区间的<strong>后缀和之和</strong>乘上左子树表示的区间长度。</p>\n<p>因此对于每个节点，额外开辟两个变量 $sum1,sum2$。前者表示前缀和之和，后者表示后缀和之和。</p>\n<p>那问题来了，似乎光有上面的信息，$sum1$ 和 $sum2$ 又没法通过左右子树的信息计算了？</p>\n<p><del>完了无限递归了快跑不做了</del></p>\n<p>其实我们只需要再额外新建一个变量 $sum$ 表示整个区间的和<del>不会吧不会吧都是学过线段树的还有不会合并这个的吗</del>，然后前缀和之和与后缀和之和就水到渠成了。自己动手画一下就会发现。</p>\n<p>所以合并（pushup）代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">c[O].w = c[O &lt;&lt; <span class=\"number\">1</span>].w + c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].w + c[O &lt;&lt; <span class=\"number\">1</span>].sum2 * (r - mid) + c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum1 * (mid - l + <span class=\"number\">1</span>);</span><br><span class=\"line\">c[O].sum = c[O &lt;&lt; <span class=\"number\">1</span>].sum + c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">c[O].sum1 = c[O &lt;&lt; <span class=\"number\">1</span>].sum1 + c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum1 + c[O &lt;&lt; <span class=\"number\">1</span>].sum * (r - mid);</span><br><span class=\"line\">c[O].sum2 = c[O &lt;&lt; <span class=\"number\">1</span>].sum2 + c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum2 + c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum * (mid - l + <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>查询时候的区间信息合并类似。</p>\n<ul>\n<li>Lazytag如何处理？</li>\n</ul>\n<p><code>sum</code>变量很好处理Lazytag。<code>sum1</code>和<code>sum2</code>也比较容易，只需要计算<code>lazytag</code>乘上区间长度乘上区间长度加一除以二。</p>\n<p>重点在于 $w$ 变量。设当前需要给整个区间加上 $x$，则 $w$ 需要加上多少？</p>\n<p>设 $l$ 为区间长度，依次考虑这个区间内长度为 $1,2,3…l$ 的子区间。不难发现 $w$ 需要增加 $\\sum\\limits^{i\\le l}_{i=1}\\times (n-i-1)\\times x$。</p>\n<p>这个式子显然我们需要预处理 $p_i=\\sum\\limits^{j\\le i}_{j=1}\\times (n-j-1)$。而预处理还要讲究，不能暴力根据定义预处理，否则努力就白费了，跑得比暴力还慢。</p>\n<p>手算可得递推式：$p_i=p_{i-1}+i\\times (i+1)\\div 2$。</p>\n<p>因此Lazytag的处理如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (L &lt;= c[O].l &amp;&amp; c[O].r &lt;= R) &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">t</span><span class=\"params\">(c[O].r - c[O].l + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\tc[O].w += p[t] * d, c[O].Lazy += d, c[O].sum += t * d;</span><br><span class=\"line\">\tc[O].sum1 += t * (t + <span class=\"number\">1</span>) / <span class=\"number\">2</span> * d, c[O].sum2 += t * (t + <span class=\"number\">1</span>) / <span class=\"number\">2</span> * d;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有了这些，在细节上还需注意<code>query</code>的时候，为了区间合并的方便，我把返回值设成了一个四元组。</p>\n<p><del>血泪史就是式子推错了 $\\infty$ 次</del></p>\n<h1 id=\"texttt-code\"><a href=\"#texttt-code\" class=\"headerlink\" title=\"$\\texttt{code}$\"></a>$\\texttt{code}$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &gt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(ll x, ll y)</span> </span>&#123;<span class=\"keyword\">return</span> y ? <span class=\"built_in\">gcd</span>(y, x % y) : x;&#125;</span><br><span class=\"line\">ll p[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l, r, Lazy;</span><br><span class=\"line\">\tll w, sum, sum1, sum2;</span><br><span class=\"line\">&#125; c[<span class=\"number\">400005</span>];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Tuple</span> &#123;</span>ll w, sum, sum1, sum2;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make_tree</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">\tc[O].l = L, c[O].r = R;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L != R) <span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span>, L, L + R &gt;&gt; <span class=\"number\">1</span>), <span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, (L + R &gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>, R);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O)</span> </span>&#123;</span><br><span class=\"line\">\tint t(c[O].Lazy), l(c[O].l), r(c[O].r);</span><br><span class=\"line\">\tint lt(c[O &lt;&lt; 1].r - c[O &lt;&lt; 1].l + 1), rt(c[O &lt;&lt; 1 | 1].r - c[O &lt;&lt; 1 | 1].l + 1);</span><br><span class=\"line\">\tc[O &lt;&lt; <span class=\"number\">1</span>].w += p[lt] * t, c[O &lt;&lt; <span class=\"number\">1</span>].Lazy += t, c[O &lt;&lt; <span class=\"number\">1</span>].sum += lt * t;</span><br><span class=\"line\">\tc[O &lt;&lt; <span class=\"number\">1</span>].sum1 += lt * (lt + <span class=\"number\">1</span>) / <span class=\"number\">2</span> * t, c[O &lt;&lt; <span class=\"number\">1</span>].sum2 += lt * (lt + <span class=\"number\">1</span>) / <span class=\"number\">2</span> * t;</span><br><span class=\"line\">\tc[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].w += p[rt] * t, c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].Lazy += t, c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum += rt * t;</span><br><span class=\"line\">\tc[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum1 += rt * (rt + <span class=\"number\">1</span>) / <span class=\"number\">2</span> * t, c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum2 += rt * (rt + <span class=\"number\">1</span>) / <span class=\"number\">2</span> * t;</span><br><span class=\"line\">\tc[O].Lazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= c[O].l &amp;&amp; c[O].r &lt;= R) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">t</span><span class=\"params\">(c[O].r - c[O].l + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t\tc[O].w += p[t] * d, c[O].Lazy += d, c[O].sum += t * d;</span><br><span class=\"line\">\t\tc[O].sum1 += t * (t + <span class=\"number\">1</span>) / <span class=\"number\">2</span> * d, c[O].sum2 += t * (t + <span class=\"number\">1</span>) / <span class=\"number\">2</span> * d;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">pushdown</span>(O);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c[O &lt;&lt; <span class=\"number\">1</span>].r &gt;= L) <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span>, L, R, d);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].l &lt;= R) <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, L, R, d);</span><br><span class=\"line\">\tconst int l(c[O].l), r(c[O].r), mid(l + r &gt;&gt; 1);</span><br><span class=\"line\">\tc[O].w = c[O &lt;&lt; <span class=\"number\">1</span>].w + c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].w + c[O &lt;&lt; <span class=\"number\">1</span>].sum2 * (r - mid) + c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum1 * (mid - l + <span class=\"number\">1</span>);</span><br><span class=\"line\">\tc[O].sum = c[O &lt;&lt; <span class=\"number\">1</span>].sum + c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">\tc[O].sum1 = c[O &lt;&lt; <span class=\"number\">1</span>].sum1 + c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum1 + c[O &lt;&lt; <span class=\"number\">1</span>].sum * (r - mid);</span><br><span class=\"line\">\tc[O].sum2 = c[O &lt;&lt; <span class=\"number\">1</span>].sum2 + c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum2 + c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum * (mid - l + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">Tuple <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> O, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L &lt;= c[O].l &amp;&amp; c[O].r &lt;= R) <span class=\"keyword\">return</span> Tuple&#123;c[O].w, c[O].sum, c[O].sum1, c[O].sum2&#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">pushdown</span>(O);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c[O &lt;&lt; <span class=\"number\">1</span>].r &lt; L) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, L, R);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].l &gt; R) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(O &lt;&lt; <span class=\"number\">1</span>, L, R);</span><br><span class=\"line\">\tTuple ls(query(O &lt;&lt; 1, L, R)), rs(query(O &lt;&lt; 1 | 1, L, R));</span><br><span class=\"line\">\tconst int l(max(c[O].l, L)), r(min(c[O].r, R)), mid(c[O].l + c[O].r &gt;&gt; 1);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Tuple&#123;ls.w + rs.w + ls.sum2 * (r - mid) + rs.sum1 * (mid - l + <span class=\"number\">1</span>),</span><br><span class=\"line\">\tls.sum + rs.sum, ls.sum1 + rs.sum1 + ls.sum * (r - mid), ls.sum2 + rs.sum2 + rs.sum * (mid - l + <span class=\"number\">1</span>)&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) p[i] = p[i - <span class=\"number\">1</span>] + i * (i + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">make_tree</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (m --) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> l, r;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> op;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot; %c%lld%lld&quot;</span>, &amp;op, &amp;l, &amp;r);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"string\">&#x27;C&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, &amp;x);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (l &lt; r) <span class=\"built_in\">update</span>(<span class=\"number\">1</span>, l, r - <span class=\"number\">1</span>, x);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (l &lt; r) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"built_in\">a</span>(<span class=\"built_in\">query</span>(<span class=\"number\">1</span>, l, r - <span class=\"number\">1</span>).w &lt;&lt; <span class=\"number\">1</span>), <span class=\"built_in\">b</span>((r - l) * (r - l + <span class=\"number\">1</span>));</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld/%lld\\n&quot;</span>, a / <span class=\"built_in\">gcd</span>(a, b), b / <span class=\"built_in\">gcd</span>(a, b));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;0/1&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数据结构"],"tags":["线段树"]},{"title":"KMP板子","url":"/2021/02/16/kmp/","content":"<p>之前花了很多时间都没有弄懂KMP的原理，今天又花了一下午去看KMP的资料总算弄懂了，还A了KMP的板子，开森~</p>\n<span id=\"more\"></span>\n<p>所以特地保存一下板子……</p>\n<p>其实我主要是卡在了next数组的构建上面。</p>\n<p>这里借用rxz神犇的一张图片（<del>害我还真是看rxz巨佬的博客才弄懂kmp</del>）</p>\n<p><img src=\"https://www.ruanx.net/content/images/2020/02/16-2.png\" alt=\"\"></p>\n<p><del><a href=\"https://www.ruanx.net/kmp/\">宣传一波</a></del></p>\n<p>这里next数组失配了。我们想要找到这样一个位置 $i$，使得 $[0,i]$ 这个串等于 $[x-i-1,x-1]$ 这个串。因为只有这样才有可能匹配成功（但不一定匹配成功）那么这就相当于要找A的前缀等于B的相同长度的后缀，要求这个长度尽量大。那么，根据next数组的定义，很显然这就是 $nxt[p[now]-1]$。</p>\n<p>话不多说直接放板子了qaq（此代码能够AC <a href=\"https://www.luogu.com.cn/problem/P3375\">P3375 【模板】KMP字符串匹配</a>）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> s[<span class=\"number\">1000005</span>], p[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> nxt[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tint now(0), n, m;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s\\n%s&quot;</span>, s + <span class=\"number\">1</span>, p + <span class=\"number\">1</span>);</span><br><span class=\"line\">\tn = <span class=\"built_in\">strlen</span>(s + <span class=\"number\">1</span>), m = <span class=\"built_in\">strlen</span>(p + <span class=\"number\">1</span>);</span><br><span class=\"line\">\tnxt[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> x = <span class=\"number\">2</span>; x &lt;= m;) </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p[now + <span class=\"number\">1</span>] == p[x]) nxt[x ++] = ++ now;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (now) now = nxt[now];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> nxt[x ++] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">1</span>; i &lt;= n;) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s[i] == p[j]) ++ i, ++ j;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j != <span class=\"number\">1</span>) j = nxt[j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ++ i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j &gt; m) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, i - m), j = nxt[j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= m; ++ i) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, nxt[i]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["字符串"],"tags":["KMP"]},{"title":"洛谷P3793题解","url":"/2021/02/16/luogu-P3793/","content":"<h1 id=\"texttt-Description\"><a href=\"#texttt-Description\" class=\"headerlink\" title=\"$\\texttt{Description}:$\"></a>$\\texttt{Description}:$</h1><span id=\"more\"></span>\n<p><a href=\"https://www.luogu.com.cn/problem/P3793\">见题面</a></p>\n<h1 id=\"texttt-Soluton\"><a href=\"#texttt-Soluton\" class=\"headerlink\" title=\"$\\texttt{Soluton}:$\"></a>$\\texttt{Soluton}:$</h1><p>一眼看上去就是个rmq卡常题，st表显然过不去（lxl不会这么良心的（大雾）</p>\n<p>但是众所周知随机数据=用脚趾造数据。</p>\n<p>既然st表，考虑其它鬼畜算法。看到由乃题首先应该想到分块。所以我们想到一个十分鬼畜的算法：对整个区间进行分块，st表维护连续若干个块的最小值，对于不完整块，记录前缀后缀和，如果 $l,r$ 在一个块内暴力统计即可。</p>\n<p>这样做的期望时间复杂度大概是多少呢？取块长为 $S$（这里假设块长是 $n$ 的约数方便计算时间复杂度），那么期望时间复杂度为 $O(N+(N/S)log(N/S)+m\\times (\\frac{S^2}{N}+1)\\div 2)$。</p>\n<p>只要知道期望的定义应该都会推上面的式子。$O(N)$ 是预处理前缀后缀的复杂度，$O((N/S)log(N/S))$ 是st表预处理复杂度，$\\frac{S}{N}$ 是 $l,r$ 在同一个区间内的概率，$\\frac{S^2}{N}$ 是在同一块内的期望复杂度（从数学上来说这里有一些常数没算进去，但无伤大雅）， 不在一个块的期望复杂度为 $1$，那么总的期望就是 $(\\frac{S^2}{N}+1)\\div 2$。</p>\n<p>块长 $S$ 无脑取 $\\sqrt{n}$ 就能做到一个不错的线性复杂度，虽然这个块长不是最优的，但是不管你块长再优，优化的也仅仅是几乎看不出来的常数而已了。</p>\n<p>另外 $l&gt;r$ 的情况是交换 $l$ 和 $r$，因为这个我被坑了好久…………</p>\n<p>完结撒花~</p>\n<h1 id=\"texttt-Code\"><a href=\"#texttt-Code\" class=\"headerlink\" title=\"$\\texttt{Code}:$\"></a>$\\texttt{Code}:$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &gt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">max2</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">if</span> (x &lt; y) x = y;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> GenHelper</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> z1,z2,z3,z4,b;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">rand_</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    b=((z1&lt;&lt;<span class=\"number\">6</span>)^z1)&gt;&gt;<span class=\"number\">13</span>;</span><br><span class=\"line\">    z1=((z1&amp;<span class=\"number\">4294967294U</span>)&lt;&lt;<span class=\"number\">18</span>)^b;</span><br><span class=\"line\">    b=((z2&lt;&lt;<span class=\"number\">2</span>)^z2)&gt;&gt;<span class=\"number\">27</span>;</span><br><span class=\"line\">    z2=((z2&amp;<span class=\"number\">4294967288U</span>)&lt;&lt;<span class=\"number\">2</span>)^b;</span><br><span class=\"line\">    b=((z3&lt;&lt;<span class=\"number\">13</span>)^z3)&gt;&gt;<span class=\"number\">21</span>;</span><br><span class=\"line\">    z3=((z3&amp;<span class=\"number\">4294967280U</span>)&lt;&lt;<span class=\"number\">7</span>)^b;</span><br><span class=\"line\">    b=((z4&lt;&lt;<span class=\"number\">3</span>)^z4)&gt;&gt;<span class=\"number\">12</span>;</span><br><span class=\"line\">    z4=((z4&amp;<span class=\"number\">4294967168U</span>)&lt;&lt;<span class=\"number\">13</span>)^b;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (z1^z2^z3^z4);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">srand</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> GenHelper;</span><br><span class=\"line\">z1=x; z2=(~x)^<span class=\"number\">0x233333333</span>U; z3=x^<span class=\"number\">0x1234598766</span>U; z4=(~x)+<span class=\"number\">51</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> GenHelper;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a=<span class=\"built_in\">rand_</span>()&amp;<span class=\"number\">32767</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b=<span class=\"built_in\">rand_</span>()&amp;<span class=\"number\">32767</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a*<span class=\"number\">32768</span>+b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">20000005</span>], b[<span class=\"number\">5005</span>], c[<span class=\"number\">20000005</span>], d[<span class=\"number\">20000005</span>], s[<span class=\"number\">5005</span>], st[<span class=\"number\">5005</span>][<span class=\"number\">15</span>], S;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">Query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">k</span><span class=\"params\">(log2(R - L + <span class=\"number\">1</span>))</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(st[L][k], st[R - (<span class=\"number\">1</span> &lt;&lt; k) + <span class=\"number\">1</span>][k]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> l, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\tint i((l - 1) / S + 1), j((r - 1) / S + 1), ans(0);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (i == j) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">k</span>(l); k &lt;= r; ++ k) ans = <span class=\"built_in\">max</span>(ans, a[k]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; j) ans = <span class=\"built_in\">Query</span>(i + <span class=\"number\">1</span>, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(ans, <span class=\"built_in\">max</span>(d[l], c[r]));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m, s;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">ans</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s);</span><br><span class=\"line\">\tS = <span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">\t<span class=\"built_in\">srand</span>(s);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">len</span><span class=\"params\">(ceil(n * <span class=\"number\">1.0</span> / S))</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">max2</span>(b[(i - <span class=\"number\">1</span>) / S + <span class=\"number\">1</span>], a[i] = <span class=\"built_in\">read</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= len; ++ i) &#123;</span><br><span class=\"line\">\t\tint st((i - 1) * S + 1), ed(min(n, i * S));</span><br><span class=\"line\">\t\tc[st] = a[st];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(st + <span class=\"number\">1</span>); j &lt;= ed; ++ j) c[j] = <span class=\"built_in\">max</span>(c[j - <span class=\"number\">1</span>], a[j]);</span><br><span class=\"line\">\t\td[ed] = a[ed];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(ed - <span class=\"number\">1</span>); j &gt;= st; -- j) d[j] = <span class=\"built_in\">max</span>(d[j + <span class=\"number\">1</span>], a[j]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= len; ++ i) st[i][<span class=\"number\">0</span>] = b[i];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); <span class=\"number\">1</span> &lt;&lt; j &lt;= len; ++ j)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i + (<span class=\"number\">1</span> &lt;&lt; j) - <span class=\"number\">1</span> &lt;= len; ++ i)</span><br><span class=\"line\">\tst[i][j] = <span class=\"built_in\">max</span>(st[i][j - <span class=\"number\">1</span>], st[i + (<span class=\"number\">1</span> &lt;&lt; j - <span class=\"number\">1</span>)][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (m --) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> l, r;</span><br><span class=\"line\">\t\tl = <span class=\"built_in\">read</span>() % n + <span class=\"number\">1</span>, r = <span class=\"built_in\">read</span>() % n + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l &gt; r) l ^= r ^= l ^= r;</span><br><span class=\"line\">\t\tans += <span class=\"built_in\">query</span>(l, r);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%llu&quot;</span>, ans);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["分块"]},{"title":"U149793题解","url":"/2021/02/04/U149793-solution/","content":"<p>老板给我们布置了一个寒假作业，回家自己出题提供题面+std+数据+题解。</p>\n<span id=\"more\"></span>\n<p>自己瞎出的一道题，然后自己做了五个多小时（逃</p>\n<p><a href=\"https://www.luogu.com.cn/problem/U149793\">传送门</a></p>\n<h1 id=\"部分分\"><a href=\"#部分分\" class=\"headerlink\" title=\"部分分\"></a>部分分</h1><p>对于1,2测试点，令 $f_i$ 表示当前已经到了第 $i$ 天，且一定刷了第 $i$ 天的题（不然没法转移），最高能提高多少水平。</p>\n<p>$f_i=\\operatorname{max}${$f_j-(i-j-1)^2$}。</p>\n<p>对于第三个测试点，输出所有 $w_i$ 总和即可。</p>\n<p><del>综上前15分有手就行</del></p>\n<p>第11个点放了一个蜜汁性质，<del>其实我也没怎么考虑这个性质有啥用</del>。</p>\n<p>第四个点，卡常（bushi</p>\n<p>第5，6个点估计暴力做法的话估计只有lxl能卡过去了（</p>\n<h1 id=\"solution\"><a href=\"#solution\" class=\"headerlink\" title=\"$solution$\"></a>$solution$</h1><p>这题的本意是卡掉 $O(nlogn)$ 的做法，现在正解不加fread看来卡不掉了（（（</p>\n<p>所以本来想开6e6的数据直接搞成了2e6。。。</p>\n<p><del>貌似我透露了正解复杂度</del></p>\n<p>这题显然我们应该先展开原式。</p>\n<p>$f_i=f_j-(i-j-1)^2$</p>\n<p>$=f_j-(i-(j+1))^2$</p>\n<p>$=f_j-i^2-(j+1)^2+2i(j+1)$</p>\n<p>$=f_j-i^2-j^2-1-2j+2ij+2i$</p>\n<p>原式可以变形为：</p>\n<p>$f_j=\\operatorname{max}${$f_j-j^2-2j+2ij$} $+2i-i^2-1$</p>\n<p>我们发现一个问题：里面的 $\\text{max}$ 的 $2ij$ 既与 $i$ 有关又与 $j$ 有关。这是非常烦人的一点。</p>\n<p>这里可以先考虑把 $j$ 全部放到一个单调队列中。如果 $a\\le b$，且对于 $f_{i+1}$ 来说，选择 $f_b$ 转移比 $f_a$ 更优，那么可以删除 $a$ 这个元素。可是这个问题还是没有得到解决：$i$ 每增加 $1$，$f_j$ 这个决策点相对于其它决策点的差距还是会变化，怎么办呢？</p>\n<p>反正我到这里就放弃来，去想啥差分线段树分块各种歪解。最后走投无路才滚回这个单调队列的想法/kk。</p>\n<p><del>明 示 正 解</del></p>\n<p>容易发现，对于两个数 $x$ 和 $y$，对于当前计算的 $i$ 满足 $x\\le y$ 且选择 $f_x$ 比 $f_y$ 更好时，$y$ 比 $x$ “更有前途”（相对于后面的 $f_i$，它减少的速度更慢），但当前 $x$ 比 $y$ 暂时优一点，此时可以预测 $y$ 什么时候（当 $i$ 大于等于多少时）会变得比 $x$ 更优（当然，可能它到 $f$ 计算完毕后都不会更优）。令 $b_i=f_i-i\\times i-2\\times i$，则当 $i$ 大于等于 $\\frac{b_x-b_y}{2y-2x}$ 时 $y$ 开始反超 $x$ 了，对于今后的 $f_i$ 的计算，选择 $y$ 比选择 $x$ 一定更优了。</p>\n<p>但是我们不可能去用一个 <code>vector</code> 啥的去存这些信息，不然还是超时（其实这玩意儿我开始就想过，但是最后整了半天放弃了最后才滚回这个想法）。</p>\n<p>接着考虑以下情况：</p>\n<p>对于 $x,y,z$，$x\\le y\\le z$，若 $y$ 超过 $x$ 的时间早与 $y$ 被 $z$ 超过的时间，则 $y$ 一定是没有价值的，因为无论什么时候它都无法成为最优的决策。再想一想，单调队列的基本原理不正是保证每个元素都是<strong>一定</strong>有用的，一定能在某个时刻派上用场吗？上面的话，根据上面 $y$ 超过 $x$ 的时间的式子，可以转换为：</p>\n<p>若 $\\frac{b_x-b_y}{2y-2x}\\le \\frac{b_y-b_z}{2z-2y}$，即$\\frac{b_x-b_y}{y-x}\\le \\frac{b_y-b_z}{z-y}$ 时，可以删除 $y$。</p>\n<p>所以对于这个特殊的“单调队列”，设它表示为 $q_1,q_2…q_t$（在实现中，这里 $1$ 是head指针，$t$ 是tail指针），其中的元素表示下标，它维护的是 $\\frac{b_{q_i}-b_{q_{i+1}}}{q_{i+1}-q_i}$ 的单调性，如果其中的 $q_i$ 递增排序，则 $\\frac{b_{q_i}-b_{q_{i+1}}}{q_{i+1}-q_i}$ 是递减排序的。</p>\n<p>那么，我们怎么判断当前队列里的的某些元素已经被其它的决策点反超了呢？</p>\n<p>其实被反超就意味着对于当前计算的 $f_i$，$\\frac{b_{q_i}-b_{q_{i+1}}}{q_{i+1}-q_i}\\le i$，而 $\\frac{b_{q_i}-b_{q_{i+1}}}{q_{i+1}-q_i}$ 又是从前往后递减排序的，所以只需要从队首删除元素即可。</p>\n<p><del>越来越像标准单调队列了，爷青回</del></p>\n<p>什么爷青回啊这题不都做完了吗（（（</p>\n<p><del>我不会告诉你我推式子算错了两次</del></p>\n<p>注意std带了fread，如有不适敬请谅解（</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code:$\"></a>$Code:$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> gc (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 131072, stdin), p1 == p2) ? EOF : *p1 ++)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">131072</span>], *p1, *p2;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">\tint x(0LL), f(1LL);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((ch = gc) &lt; <span class=\"number\">48</span>) <span class=\"keyword\">if</span> (ch == <span class=\"string\">&#x27;-&#x27;</span>) f = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> x = x * <span class=\"number\">10</span> + ch - <span class=\"number\">48</span>; <span class=\"keyword\">while</span> ((ch = gc) &gt;= <span class=\"number\">48</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x * f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &gt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> f[<span class=\"number\">2000005</span>], b[<span class=\"number\">2000005</span>], w[<span class=\"number\">2000005</span>], q[<span class=\"number\">4000005</span>], head = <span class=\"number\">1</span>, tail = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, <span class=\"built_in\">ans</span>(<span class=\"number\">-1e15</span>);</span><br><span class=\"line\">\tn = <span class=\"built_in\">read</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) w[i] = <span class=\"built_in\">read</span>();</span><br><span class=\"line\">\tf[<span class=\"number\">1</span>] = w[<span class=\"number\">1</span>], q[<span class=\"number\">1</span>] = <span class=\"number\">1</span>, b[<span class=\"number\">1</span>] = f[<span class=\"number\">1</span>] - <span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">2</span>); i &lt;= n; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (tail &gt; head &amp;&amp; b[q[head]] - b[q[head + <span class=\"number\">1</span>]] &lt;= i * <span class=\"number\">2</span> * (q[head + <span class=\"number\">1</span>] - q[head])) ++ head;</span><br><span class=\"line\">\t\tf[i] = <span class=\"built_in\">max</span>(w[i] - (i - <span class=\"number\">1</span>) * (i - <span class=\"number\">1</span>),</span><br><span class=\"line\">\t\tf[q[head]] - (i - q[head] - <span class=\"number\">1</span>) * (i - q[head] - <span class=\"number\">1</span>) + w[i]);</span><br><span class=\"line\">\t\tb[i] = f[i] - i * i - <span class=\"number\">2</span> * i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (tail &gt; head &amp;&amp; (b[q[tail]] - b[i]) * (q[tail] - q[tail - <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&lt;= (i - q[tail]) * (b[q[tail - <span class=\"number\">1</span>]] - b[q[tail]])) -- tail;</span><br><span class=\"line\">\t\tq[++ tail] = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt;= n; ++ i) ans = <span class=\"built_in\">max</span>(ans, f[i] - (<span class=\"number\">1LL</span> * (n - i)) * (n - i));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, ans);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["动态规划"],"tags":["动态规划","单调队列"]},{"title":"1/26练习赛总结","url":"/2021/01/28/1-26-match-summary/","content":"<p>今天早上七点起来尼玛OJ还是上不去先把题解写了来吧qwq，代码什么的OJ上不去放不了<br><span id=\"more\"></span><br>A题我只能直接口胡了，赛场上打的暴力（话说好像随机数据树的高度期望只有 $O(logn)$？。只要一个点被标记，我们将它与它的父亲节点分裂。因为它的所有子树的节点（包括这个节点本身）到根节点上的路径最近的被标记节点，最远也就是这个点，不会再往上了。而这个点被标记了对除了自己子树以外的子树又没有任何影响，所以口胡出来是可以这样干的。</p>\n<p>然后继续瞎yy。如果真的要硬写一个分裂，能用得上的并且能保证时间复杂度的<del>我学过的</del>数据结构大概只有<strong>不能路径压缩</strong>的并查集。不能路径压缩，显然会被特殊构造的数据（比如一条链）卡成 $O(N^2)$，而且和暴力也没啥区别。至少对于这道题，啥JB启发式合并根本没用只能通过路径压缩保证复杂度。</p>\n<p>众所周知，路径压缩的并查集本来就不支持 <code>split</code>操作，只支持<code>merge</code>操作。而并查集的常见套路就是，只要一道题没有强制在线，那么<strong>离线</strong>倒着处理每个询问，将分裂转化为合并。</p>\n<p>对于这道题，显然先要把原始的树构建好，记 $F_i$ 表示 $i$ 原来的父亲，$fa_i$ 表示并查集中 $i$ 的父亲。我们先对于所有的标记操作，把并查集挨个分裂。这里的 $O(1)$ 分裂不影响查询复杂度，等会儿反正要路径压缩。这道题的<code>merge</code>相比一般的<code>merge</code>不一样，比如标记了 $i$ 点，因为我们倒序处理每个询问，那么在这个当前标记操作之前的询问，$i$ 都没有被标记，也就是 $i$ 没有被分裂，因此将 $i$ 与 $i$ 在原始的树上的父亲节点何必，直接一句 $fa_i=F_i$。</p>\n<p><del>由于这题是我原地瞎yy的，可能有问题，我自己都WA0</del></p>\n<p>B题。首先考虑一个结论，最后留下的图一定是联通的。这个结论非常显然，只要删除了 $u\\rightarrow v$ 这条边使得图不连通，那么这条边即使不删，不仅花费小，而且不会构成新的环。一个联通图，只有一个环，那么它其实就是 $n$ 个点 $n$ 条边，也就是树多了一条边构成环。当然这个图本身就是树的情况答案肯定就是 $0$ 了。</p>\n<p>这种树多了一条边，构成一个唯一的简单环的图你谷日报上称之为奇环树，<del>虽然我完全不会</del>但是对做这个题没有影响。题目要求删的边边权尽量小，也就是留下的边边权尽量大，也就是把最大生成树变成了最大生成奇环树。</p>\n<p>由于 <code>Kruskal</code> 可拓展性很强<del>其实是因为我早就忘了Prim怎么写</del>我采用Kruskal。将边按边权从大到小排序，如果遇到当前边，它不是一条重边且选择它就能构成环，并且当前没有选任何一条使整个图产生环的边，那么选择这条边，然后剩下的就和Kruskal没啥区别了。</p>\n<p><del>至于怎么证明，我一个朴素的Kruskal板子都不会证的蒟蒻会证这个玩意儿吗，自己找kruskal本人去</del></p>\n<p><del>老实说，学校OJ上不去，C题是啥来着</del></p>\n<p><del>D题又是啥啊</del></p>\n<p>哦想起来D了，md wtcl题都记不住，这个题一看数据规模就知道是贪心做法了。对于排序后的数组，$a_i+b_j$ 这个组合，一定存在 $i\\times j - 1$ 种组合小于等于它。由于我们只关心它的值不关心它具体选哪两个数加起来，所以只要 $i\\times j-1\\ge n$，也就是 $i\\times j&gt; n$，这个组合显然不会是前 $n$ 小的。</p>\n<p>所以我们枚举 $i$，$j$ 只用循环到 $n\\div i$ 即可。看似只对内层 $j$ 的循环做了一个<del>小小的</del>剪枝，实际上，众所周知 $\\sum\\limits^{i\\le n}_{i=1}\\frac{n}{i}\\approx nlog_2n$。所以我们其实只会考虑 $O(nlogn)$ 个元素。那么，这 $O(nlogn)$ 个元素如果排个序在输出就是 $O(nlognlogn)$ 的复杂度，对于1e6的数据很虚。虽然我比赛时由于太懒确实是这样艹过去的（这道题计算总用时，其实后面几个点都跑了超过1000ms），但是建议线性建队，不是说非要手写堆，NKOJ默认O2 STL性能飞起，所以也可以用<code>&lt;algorithm&gt;</code>自带的<code>make_heap</code>，<code>pop_heap</code>，<code>push_heap</code>函数。用法自行百度。这样做时间复杂度就是 $O(nlogn)$ 了，更严谨的是 $O(nlog_2(log_2n))$，不过影响不大。</p>\n","categories":["比赛"],"tags":["比赛"]},{"title":"1/27练习赛总结","url":"/2021/01/27/1-27-match-summary/","content":"<h1 id=\"赛时过程：\"><a href=\"#赛时过程：\" class=\"headerlink\" title=\"赛时过程：\"></a>赛时过程：</h1><span id=\"more\"></span>\n<p>四道题ABCD，IOI赛制。线上赛。这次是和xxs们打<del>当然我也是xxs</del>，所以对rk1甚至AK比较有信心</p>\n<p>A题签到，尼玛明明算好了开<code>long long</code>结果最后输出写成了<code>%d</code>，又交了一遍才过。</p>\n<p>B题，就一个并查集统计<code>Size</code>和每个点的度数，板子题。</p>\n<p>C题艹这不是我做过的原题改版吗，写了35分。</p>\n<p>看了看排名。我235rk1，WCH把A题A了还做了D题，70pts。</p>\n<p><del>尼玛，在我做C题时去干D题还想偷袭我。年轻人不讲武德，来骗，来偷袭，我一个十几岁的老同志，这好吗，这不好！我劝这位年轻人，耗子尾汁，以后不要再犯这样的小聪明</del></p>\n<p>然后怕被WCH巨佬挤下去（虽然只是暂时挤下去）花了四五分钟A了D。回头看C找到了问题，发现此题甚为麻烦。我写了个<code>unordered_map</code>套<code>unordered_set</code>，十分鬼畜<del>复杂度还是假的</del>（比赛结束后改成了正确的复杂度<del>结果跑得还更慢了</del>），但不管怎么说总算A了，可以AK离场了。</p>\n<p>摸了一会儿鱼，卡了A题的常数干正事去了。最后rk2lm100，rk3WCH195<del>WCH：cnm</del></p>\n<h1 id=\"赛后总结：\"><a href=\"#赛后总结：\" class=\"headerlink\" title=\"赛后总结：\"></a>赛后总结：</h1><p>C题，提交次数还是太多（5次）。另外A题不是一次性过的<del>是二次性过</del>。以后做题要注意提交次数了，尽量一次过（特别是对于水题）。</p>\n<h1 id=\"赛后题解：\"><a href=\"#赛后题解：\" class=\"headerlink\" title=\"赛后题解：\"></a>赛后题解：</h1><p>老师让我写题解给一起打这场比赛的小学同学们，那就写得详细点吧QwQ。代码放最后面，<del>方便不想展示代码的老师修改题解</del></p>\n<p>嗯……A题好像差不多都A了，具体的令 $s_i=\\sum\\limits^{j\\le i}_{j=1}a_j^2$ ，$g_i=\\sum\\limits^{j\\le n}_{j=i}a_j$，那么就可以枚举位置 $k$ 了。另外，建议算一下数据范围，免得十年OI一场空，不开____见祖宗。</p>\n<p>B题，其实是个板子，但是<del>除了我</del>没有人做出来。记 $cnt_i$ 表示 $i$ 为根的集合中的元素数量（注意是 $i$ 为根，所以 $i$ 必须是一个并查集的根）。</p>\n<p><code>merge</code>的时候就<code>fa[x]=y,cnt[y]+=x</code>即可（$x,y$ 分别为要合并的两个集合的根节点）。</p>\n<p>然后记录每个点的度数。对于每个点，输出它所在的集合中元素的个数减去度数减去 $1$ （$1$ 是它自己算一个人）。</p>\n<p>C题。首先举个例子。如果 $a_i$ 能和 $a_j$ 交换，$a_j$ 能和 $a_k$ 交换，那么 $a_i$ 就能和 $a_k$ 交换。也就是说，如果 $a_i$ 能够和 $a_j$ 交换，那么所有能够和 $a_i$ 交换的下标都能和所有能和 $a_j$ 交换的下标交换。</p>\n<p>说到这里肯定都想到并查集了吧。若 $a_i$ 和 $a_j$ 能够交换，合并 $i$ 和 $j$ 所在的集合即可。若 $i$ 和 $j$ 位于同一个集合，则 $a_i$ 和 $a_j$ 能够交换。</p>\n<p>这个题还有一个细节：对于一个固定的 $i$，可能存在多个 $j$ 使得 $a_i==b_j$。不难发现直接提前合并所有相同的 $b_j$ 对应的 $j$ 所在的集合是行不通的。</p>\n<p>为了解决这个问题，这里再给出一个结论：</p>\n<blockquote>\n<p>若 $S1$ 是能够和 $a_i$ 交换的所有下标 $k$ 构成的集合中满足 $a_i=b_k$ 的子集，$S2$ 是能够和 $a_j$ 交换的所有下标 $k$ 构成的集合中满足 $a_j=b_k$ 的子集，则 $S1\\and S2=\\empty$ 或 $S1=S2$</p>\n</blockquote>\n<p>看起来这么高大上，实际上仔细想想，能和 $a_i$ 交换的集合与能和 $a_j$ 交换的集合，即 $i$ 所在的集合与 $j$ 所在的集合。很显然这两个集合要么相等要么没有交集，也就自然而然地进一步的出了上面的结论。</p>\n<p>那这个结论有什么用呢？设<code>mp[i][j]</code> 表示以 $i$ ，$a_x=j$ 的下标 $x$ 的数量。那么扫一遍 $a$ 中的元素，只要 $mp_{find(i), a_i}$ （find为找根节点的函数）不为0，它就一定能交换到至少一个 $a_i==b_j$ 的 $j$ 位置。根据上面的结论，随便交换到哪一个都无所谓，因此直接<code>--mp[find(i)][a[i]]</code> 即可。</p>\n<p>实现的时候注意一个东西，要么把值给离散化，要么像我一样懒人式的使用 <code>unordered_map</code>。使用 <code>unordered_map</code>  非常可靠，虽然它底层哈希算法总会有出错的可能，但是我用这个东西的程序从来没因为这个东西而翻车<del>当然它因此常数巨大</del>，而且时间复杂度还比离散化小（少一个<code>log</code>）。如果真的怕用 <code>map</code> 也行。</p>\n<p>算是比赛中一道有思维含量也比较有趣的题。</p>\n<p>D题，WA70分盲猜是向上取整的时候翻车了。用每个并查集的 <code>size</code> 除以 $k$ 就好，合并的时候如何维护 <code>size</code> 和B题一样。</p>\n<p><del>尼玛，ABD的题解加起来都没有C题多</del></p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code:$\"></a>$Code:$</h1><h2 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A\"></a>A</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> gc (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 131072, stdin), p1 == p2) ? EOF : *p1 ++)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">131072</span>], *p1, *p2;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">x</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((ch = gc) &lt; <span class=\"number\">48</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> x = x * <span class=\"number\">10</span> + ch - <span class=\"number\">48</span>; <span class=\"keyword\">while</span> ((ch = gc) &gt;= <span class=\"number\">48</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">1000005</span>], s[<span class=\"number\">1000005</span>], g[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tint n(read()), ans(0);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\ta[i] = <span class=\"built_in\">read</span>(), s[i] = s[i - <span class=\"number\">1</span>] + a[i] * a[i];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(n); i; -- i) g[i] = g[i + <span class=\"number\">1</span>] + a[i];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s[i] * g[i + <span class=\"number\">1</span>] &gt; ans) ans = g[i + <span class=\"number\">1</span>] * s[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, ans), <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> fa[<span class=\"number\">100005</span>], cnt[<span class=\"number\">100005</span>], d[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;<span class=\"keyword\">return</span> fa[x] == x ? x : fa[x] = <span class=\"built_in\">find</span>(fa[x]);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">find</span>(x) != <span class=\"built_in\">find</span>(y)) cnt[<span class=\"built_in\">find</span>(y)] += cnt[<span class=\"built_in\">find</span>(x)], fa[<span class=\"built_in\">find</span>(x)] = <span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) fa[i] = i, cnt[i] = d[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (m --) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class=\"line\">\t\t<span class=\"built_in\">merge</span>(x, y), ++ d[x], ++ d[y];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, cnt[<span class=\"built_in\">find</span>(i)] - d[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> fa[<span class=\"number\">100005</span>], A[<span class=\"number\">100005</span>], B[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> used[<span class=\"number\">100005</span>];</span><br><span class=\"line\">std::unordered_map&lt;<span class=\"keyword\">int</span>, std::unordered_map&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; mp;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;<span class=\"keyword\">return</span> fa[x] == x ? fa[x] : fa[x] = <span class=\"built_in\">find</span>(fa[x]);&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> id, v;</span><br><span class=\"line\">\t<span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> node x) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> v &lt; x.v;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> v &lt; x;&#125;</span><br><span class=\"line\">&#125; b[<span class=\"number\">100005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, <span class=\"built_in\">ans</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, A + i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, B + i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) fa[i] = i;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;m);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (m --) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> u, v;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class=\"line\">\t\t++ u, ++ v;</span><br><span class=\"line\">\t\tfa[<span class=\"built_in\">find</span>(u)] = <span class=\"built_in\">find</span>(v);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) ++ mp[<span class=\"built_in\">find</span>(i)][B[i]];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!mp[<span class=\"built_in\">find</span>(i)][A[i]]) ++ ans;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> -- mp[<span class=\"built_in\">find</span>(i)][A[i]];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans), <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"D\"></a>D</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> fa[<span class=\"number\">100005</span>], cnt[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> mark[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;<span class=\"keyword\">return</span> fa[x] == x ? x : fa[x] = <span class=\"built_in\">find</span>(fa[x]);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">find</span>(x) != <span class=\"built_in\">find</span>(y)) cnt[<span class=\"built_in\">find</span>(y)] += cnt[<span class=\"built_in\">find</span>(x)], fa[<span class=\"built_in\">find</span>(x)] = <span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m, k, <span class=\"built_in\">ans</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) fa[i] = i, cnt[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (m --) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> u, v;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class=\"line\">\t\t<span class=\"built_in\">merge</span>(u, v);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!mark[<span class=\"built_in\">find</span>(i)]) mark[<span class=\"built_in\">find</span>(i)] = <span class=\"literal\">true</span>, ans += <span class=\"built_in\">ceil</span>(<span class=\"number\">1.00</span> * cnt[<span class=\"built_in\">find</span>(i)] / k);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans), <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["比赛"],"tags":["比赛"]},{"title":"1/23期末考试总结与反思","url":"/2021/01/23/1-23-match-summary/","content":"<h1 id=\"赛时过程\"><a href=\"#赛时过程\" class=\"headerlink\" title=\"赛时过程\"></a>赛时过程</h1><span id=\"more\"></span>\n<p>期末考试一共6题。题号ABCDEF。IOI赛制。</p>\n<p>A题觉得是个很麻烦的BIT，虽然一眼想到正解但是觉得码量大，身为一个签到题应该有更简单的做法就跳了。</p>\n<p>B题一看兴冲冲地打完堆解法愉快地TLE60。于是发现时间复杂度不对，爬了。</p>\n<p>C题一眼<code>priority_queue</code>，愉快地A掉。</p>\n<p>D题笔算了一下式子转化成了顺序对问题仍然很愉快地A掉。<del>怎么这场比赛A没A都这么愉快啊（危</del></p>\n<p>E题觉得是神仙题，没管看F。F题我记得做过一道很相似的题是并查集。这道题好像就是在那道题的基础上跑个最小生成树貌似就是正解了？？？</p>\n<p>A了过后反应过来A题是个sb前缀和又AC。滚回B题。开始在BE之间来回游走。此时我是460rk1，rk220。hh这场说不定能AK至少rk1稳了（大危</p>\n<p>然后想了很久很久没思路，xhw巨佬已经400了。赶紧打了E题地错解贪心，没想到骗了整整50分。我510rk1，xhw巨佬400rk2（xhw巨佬没打暴力比我多A一题stO xhw Orz（大大大大危</p>\n<p>于是xhw巨佬顺利500，在比赛最后十分钟眼睁睁看着xhwAK全场干掉了我。难受qwq。</p>\n<h1 id=\"赛后总结\"><a href=\"#赛后总结\" class=\"headerlink\" title=\"赛后总结\"></a>赛后总结</h1><p>感觉这次没能rk1甚至AK只能怪自己tcl。学过的知识总是不能灵活运用啊，菜啊。贪心的题目总是不擅长，菜啊。每次总是抢到rk1然后眼睁睁看着被别人吊打，菜啊。</p>\n<p>听完别人的讲解就觉得自己更菜了qwq。讲完了瞬间秒杀，考试的时候就是想不出来。</p>\n<p>还是不能在一个想法死磕太久啊，自己还是不太会迅速的转换一道题的解法。直接导致如果一开始的想法不对这道题基本上整场考试都A不掉了。</p>\n<h1 id=\"赛后题解\"><a href=\"#赛后题解\" class=\"headerlink\" title=\"赛后题解\"></a>赛后题解</h1><p>啥JB A题就不说了。</p>\n<p>B题，NKOJ5811，思路是二分需要发射多少次光弹，设为 $mid$。验证的时候先将每个怪的生命值减 $B\\times mid$，然后判断每个怪需要单独被击中多少次。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> N, A, B, monster[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cnt</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= N; ++ i) <span class=\"keyword\">if</span> (monster[i] &gt; B * k)</span><br><span class=\"line\">\t\tcnt += <span class=\"built_in\">ceil</span>((monster[i] - B * k) * <span class=\"number\">1.00</span> / (A - B));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cnt &lt;= k;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld%lld&quot;</span>, &amp;N, &amp;A, &amp;B);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= N; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, monster + i);</span><br><span class=\"line\">\tint l(1), r(1e9), ans(0);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(l + r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">check</span>(mid) ? ans = mid, r = mid - <span class=\"number\">1</span> : l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans), <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>C题，NKOJ5832，二分分界点 $k$，前 $N$ 棵树一定在 $k$ 的左边，后 $N$ 棵树一定在 $k$ 右边。$k$ 的范围很显然。快速求出对于每个 $k$，左边的高度最大的 $N$ 棵树，右边高度最小的 $N$ 棵树。显然扫一遍用堆维护就好了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &gt; y ? x : y;&#125; </span><br><span class=\"line\">std::priority_queue&lt;<span class=\"keyword\">int</span>, std::vector&lt;<span class=\"keyword\">int</span>&gt;, std::greater&lt;<span class=\"keyword\">int</span>&gt; &gt; q1;</span><br><span class=\"line\">std::priority_queue&lt;<span class=\"keyword\">int</span>&gt; q2;</span><br><span class=\"line\"><span class=\"keyword\">int</span> h[<span class=\"number\">300005</span>], s1[<span class=\"number\">300005</span>], s2[<span class=\"number\">300005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, ans, <span class=\"built_in\">sum</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, &amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= <span class=\"number\">3</span> * n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, h + i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt; n; ++ i) q1.<span class=\"built_in\">push</span>(h[i]), sum += h[i];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(n); i &lt;= n &lt;&lt; <span class=\"number\">1</span>; ++ i) &#123;</span><br><span class=\"line\">\t\tq1.<span class=\"built_in\">push</span>(h[i]), sum += h[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (q1.<span class=\"built_in\">size</span>() &gt; n) sum -= q1.<span class=\"built_in\">top</span>(), q1.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\ts1[i] = sum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">3</span> * n); i &gt; (n &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>; -- i) sum += h[i], q2.<span class=\"built_in\">push</span>(h[i]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>((n &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>); i &gt; n; -- i)&#123;</span><br><span class=\"line\">\t\tq2.<span class=\"built_in\">push</span>(h[i]), sum += h[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (q2.<span class=\"built_in\">size</span>() &gt; n) sum -= q2.<span class=\"built_in\">top</span>(), q2.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\ts2[i] = sum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tans = s1[n] - s2[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(n + <span class=\"number\">1</span>); i &lt;= n &lt;&lt; <span class=\"number\">1</span>; ++ i) ans = <span class=\"built_in\">max</span>(ans, s1[i] - s2[i + <span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, ans), <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>D题，NKOJ5810，就是让你找有多少个平均值大于 $k$ 的子序列。设这个子序列为 $(L,R]$，$s_i$ 表示数列前 $i$ 项的和。则这个子序列需要满足 $s_R-s_L\\ge k\\times (R-L)$，化简可得 $s_R-k\\times R\\ge s_L - k\\times L$。令 $g_i=s_i-k\\times i$，则问题就变成了求 $g$ 的顺序对。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">200005</span>], s[<span class=\"number\">200005</span>], N;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> id, v;</span><br><span class=\"line\">\t<span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> node x) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> v &lt; x.v;&#125;</span><br><span class=\"line\">&#125; b[<span class=\"number\">200005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> c[<span class=\"number\">200005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(x); i &lt;= N; i += (i &amp; ~i + <span class=\"number\">1</span>)) ++ c[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(x); i; i -= (i &amp; ~i + <span class=\"number\">1</span>)) sum += c[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, k, <span class=\"built_in\">ans</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;n, &amp;k);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, a + i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\ts[i] = s[i - <span class=\"number\">1</span>] + a[i] - k; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt;= n; ++ i) b[i].id = i, b[i].v = s[i];</span><br><span class=\"line\">\tstd::<span class=\"built_in\">sort</span>(b, b + n + <span class=\"number\">1</span>);</span><br><span class=\"line\">\ts[b[<span class=\"number\">0</span>].id] = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\ts[b[i].id] = s[b[i - <span class=\"number\">1</span>].id] + (b[i].v != b[i - <span class=\"number\">1</span>].v);</span><br><span class=\"line\">\tN = s[b[n].id];</span><br><span class=\"line\">\t<span class=\"built_in\">update</span>(s[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t\tans += <span class=\"built_in\">query</span>(s[i]), <span class=\"built_in\">update</span>(s[i]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, ans), <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>E题，NKOJ5831。贪心。先按难度系数排序。将最难的 $k$ 道题先做了来。然后在剩下的题目中，可能会考虑用某些题目替换已选的 $k$ 题。那么发生这种可能的前提是，被替换的题目的种类已经出现过了，且难度系数不是相同种类的题目中最大的（如果相同种类的题目存在难度系数和它一样的也算）。替换的则需要满足他贡献了一个新的种类。并且我们替换一定是按照难度系数由大到小替换的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> mark[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t, d;</span><br><span class=\"line\">\t<span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> node x) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> d &lt; x.d;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">std::priority_queue&lt;node&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, k, <span class=\"built_in\">cnt</span>(<span class=\"number\">0</span>), <span class=\"built_in\">ans</span>(<span class=\"number\">0</span>), <span class=\"built_in\">t</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;n, &amp;k);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> t, d;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;t, &amp;d);</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">push</span>(node&#123;t, d&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (q.<span class=\"built_in\">size</span>() &amp;&amp; cnt &lt; k) &#123;</span><br><span class=\"line\">\t\tint x(q.top().d), cnt1(0);</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (q.<span class=\"built_in\">top</span>().d == x &amp;&amp; cnt &lt; k) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!mark[q.<span class=\"built_in\">top</span>().t])</span><br><span class=\"line\">\t\t\t\t++ cnt, ans += x + t, mark[q.<span class=\"built_in\">top</span>().t] = <span class=\"literal\">true</span>, t += <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> ++ cnt1;</span><br><span class=\"line\">\t\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans += <span class=\"built_in\">min</span>(k - cnt, cnt1) * x, cnt += <span class=\"built_in\">min</span>(k - cnt, cnt1);<span class=\"comment\">//尝试替换并更新答案吧</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, ans), <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>F题，NKOJ4922。先举个例子，如果分别知道了区间 $[L,R]$ 和 $[R + 1, K]$ 总和的奇偶性，就知道 $[L,K]$ 总和的奇偶性了。那么对于每个 $C_{i,j}$，由 $i-1$ 向 $j$ 连一条边权为 $C_{i,j}$ 的边。在图上跑一个联通了 $0\\sim n$ 的所有点的最小生成树即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Line</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> u, v;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> w;</span><br><span class=\"line\">\t<span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> Line x) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> w &lt; x.w;&#125;</span><br><span class=\"line\">&#125; e[<span class=\"number\">4000005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> fa[<span class=\"number\">2005</span>], tot;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;<span class=\"keyword\">return</span> fa[x] == x ? x : fa[x] = <span class=\"built_in\">find</span>(fa[x]);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, <span class=\"built_in\">cnt</span>(<span class=\"number\">0</span>), <span class=\"built_in\">k</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">ans</span><span class=\"params\">(<span class=\"number\">0LL</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) fa[i] = i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(i); j &lt;= n; ++ j)</span><br><span class=\"line\">\t\t++ tot, <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;e[tot].w), e[tot].u = i - <span class=\"number\">1</span>, e[tot].v = j;</span><br><span class=\"line\">\tstd::<span class=\"built_in\">sort</span>(e + <span class=\"number\">1</span>, e + tot + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cnt &lt; n) &#123;</span><br><span class=\"line\">\t\t++ k;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">find</span>(e[k].u) == <span class=\"built_in\">find</span>(e[k].v)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> fa[<span class=\"built_in\">find</span>(e[k].u)] = <span class=\"built_in\">find</span>(e[k].v), ans += e[k].w, ++ cnt;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, ans), <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["比赛"],"tags":["比赛"]},{"title":"1/17周赛总结","url":"/2021/01/17/1-17-match-summary/","content":"<h1 id=\"赛时过程\"><a href=\"#赛时过程\" class=\"headerlink\" title=\"赛时过程\"></a>赛时过程</h1><span id=\"more\"></span>\n<p>ACM赛制。</p>\n<p>T1题水贪心，送分题切了过就不说了。</p>\n<p>T2一看什么鬼，乱写了个欧拉回路WA了就爬了。</p>\n<p>T3明显树状数组。看了一下打了会儿草稿发现异或运算可以消掉很多数，统计一下每个数在所有子序列中出现次数奇偶性，两个数树状数组乱搞就行。过了。</p>\n<p>开T4，2h30min的比赛还剩一个多小时，一看觉得是道神题没去管滚回去看T2，舒舒服服地WA了几次回来看T4，瞟到 $n\\le 16$ 的数据范围赶紧状压开始码码码，然后在比赛还剩二十分钟时<del>惊险</del>通过。</p>\n<p>赛后呢，老板把T2题面抄错了…………全场无人AC……</p>\n<h1 id=\"赛后题解：\"><a href=\"#赛后题解：\" class=\"headerlink\" title=\"赛后题解：\"></a>赛后题解：</h1><p>说一下C题吧。</p>\n<p>何老板给你一个长度为n的整数数列a，数列中每个数字都是32位非负整数。</p>\n<p>何老板会多次进行如下两种操作：<br>1.修改数列中某个数的值<br>2.询问某个区间内所有子区间的异或和的异或和。</p>\n<p>$n\\le 2\\times 10^5$</p>\n<p>子区间的异或和的异或和？？？<del>smg</del></p>\n<p>上次的：”中位数们的中位数“也是这种，老板最喜欢玩这种毒瘤了QwQ</p>\n<p>既然是异或，统计一下每个数字在最终的异或和中出现的奇偶性就行。</p>\n<p>对于区间 $[l,r]$ 的 $a_i$，它会被异或 $(i-l+1)\\times (r-i+1)$ 次。这个次数为奇数我们才考虑这个数。</p>\n<p>如果这个次数是奇数，那么 $i-l+1+r-i+1=r+l+2$ 也是奇数。所以 $r-l$ 也是奇数。</p>\n<p>然后用两个树状数组维护 $\\sum\\limits^{2\\times i-1\\le n}_{i=1}a_{2\\times i-1}$ 和 $\\sum\\limits^{2\\times i\\le n}_{i=1}a_{2\\times i}$ 的和即可。</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code:$\"></a>$Code:$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">200005</span>], n, len;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BIT</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> c[<span class=\"number\">100005</span>];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> k, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">t</span><span class=\"params\">(d ^ a[x])</span></span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(k); i &lt;= len; i += (i &amp; ~i + <span class=\"number\">1</span>)) c[i] ^= t;</span><br><span class=\"line\">\t\ta[x] = d;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(x); i; i -= (i &amp; ~i + <span class=\"number\">1</span>)) sum ^= c[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; q1, q2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> q;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class=\"line\">\tlen = n + <span class=\"number\">1</span> &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i &amp; <span class=\"number\">1</span>) q1.<span class=\"built_in\">update</span>(i, i + <span class=\"number\">1</span> &gt;&gt; <span class=\"number\">1</span>, x);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> q2.<span class=\"built_in\">update</span>(i, i &gt;&gt; <span class=\"number\">1</span>, x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (q --) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> op, l, r;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;op, &amp;l, &amp;r);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (l &amp; <span class=\"number\">1</span>) q1.<span class=\"built_in\">update</span>(l, l + <span class=\"number\">1</span> &gt;&gt; <span class=\"number\">1</span>, r); </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> q2.<span class=\"built_in\">update</span>(l, l &gt;&gt; <span class=\"number\">1</span>, r);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (r - l &amp; <span class=\"number\">1</span>) &#123;<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;0&quot;</span>); <span class=\"keyword\">continue</span>;&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, l &amp; <span class=\"number\">1</span> ? q1.<span class=\"built_in\">query</span>(r + <span class=\"number\">1</span> &gt;&gt; <span class=\"number\">1</span>) ^ q1.<span class=\"built_in\">query</span>(l - <span class=\"number\">1</span> &gt;&gt; <span class=\"number\">1</span>) :</span><br><span class=\"line\">\t\t\tq2.<span class=\"built_in\">query</span>(r &gt;&gt; <span class=\"number\">1</span>) ^ q2.<span class=\"built_in\">query</span>(l - <span class=\"number\">2</span> &gt;&gt; <span class=\"number\">1</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["比赛"],"tags":["比赛"]},{"title":"【洛谷P3149】排序","url":"/2021/01/17/luogu-P3149/","content":"<h1 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"$Solution$:\"></a>$Solution$:</h1><span id=\"more\"></span>\n<p>看到这道题，首先想到排过序的数之间的逆序对都被消掉了。假设当前的已经给 $\\le a_k$ 的数排了序。</p>\n<p>则对于其它的逆序对分两种：</p>\n<ol>\n<li><p>一个 $\\le a_k$ 的数与一个 $&gt;a_k$ 的数组成。对于这个 $&gt;a_k$ 的数，无论 $\\le a_k$ 的数怎么排，它贡献的逆序对个数都是一样的，所以不用管。</p>\n</li>\n<li><p>两个 $&gt;a_k$ 的数组成。这种明显个数不变也不用管。</p>\n</li>\n</ol>\n<p>对于一个操作 $a_k$，如果之前存在一个操作 $a_{k^{\\prime}}$ 使得 $a_{k^{\\prime}}\\ge a_k$ ，则这个操作不用考虑，直接输出上一次询问的答案。</p>\n<p>对于一个要考虑的操作 $k$。排除了上面两种逆序对，我们就要在总的逆序对个数中减去所有 $\\le a_k$ 的数构成的逆序对。预处理 $le i$ 的数之间产生的逆序对记为 $s_i$。树状数组预处理出来即可。</p>\n<p>至于这个预处理的过程，简要说一下（这也是我想得最久的地方）：<strong>从右往左</strong>扫描数组，遇到一个数 $a_i$，$s_{a_i} +=$ 目前遇到过的比 $a_i$ 小的数。原理比较明显。</p>\n<p>然后对 $s_i$ 做个前缀和。</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code:$\"></a>$Code:$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> id, v;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> node x) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> v &lt; x.v;&#125;</span><br><span class=\"line\">&#125; b[<span class=\"number\">300005</span>];</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> node y) &#123;<span class=\"keyword\">return</span> x &lt; y.v;&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">300005</span>], c[<span class=\"number\">300005</span>], s[<span class=\"number\">300005</span>], n, N;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(x); i &lt;= n; i += (i &amp; ~i + <span class=\"number\">1</span>)) ++ c[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(x); i; i -= (i &amp; ~i + <span class=\"number\">1</span>)) sum += c[i];</span><br><span class=\"line\"><span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> m, <span class=\"built_in\">last</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, &amp;b[i].v), b[i].id = i;</span><br><span class=\"line\">std::<span class=\"built_in\">sort</span>(b + <span class=\"number\">1</span>, b + n + <span class=\"number\">1</span>);</span><br><span class=\"line\">a[b[<span class=\"number\">1</span>].id] = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">2</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">a[b[i].id] = (b[i].v != b[i - <span class=\"number\">1</span>].v) + a[b[i - <span class=\"number\">1</span>].id];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(n); i &gt;= <span class=\"number\">1</span>; -- i)</span><br><span class=\"line\">s[a[i]] += <span class=\"built_in\">query</span>(a[i]), <span class=\"built_in\">update</span>(a[i]);</span><br><span class=\"line\">N = a[b[n].id];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">2</span>); i &lt;= N; ++ i) s[i] += s[i - <span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld\\n&quot;</span>, s[N]);</span><br><span class=\"line\">a[<span class=\"number\">0</span>] = <span class=\"number\">-0x3fffffff</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (m --) &#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> k;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, &amp;k);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a[k] &lt; a[last]) k = last;</span><br><span class=\"line\">last = k;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld\\n&quot;</span>, s[N] - s[a[k]]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>逆序对很玄，讨论区有说，另外我让小粉兔大佬换数据了<del>不过暂时还没换</del>。相信粉兔不会咕多久qwq。</p>\n","categories":["数据结构"],"tags":["树状数组"]},{"title":"1/13树状数组专项练习赛总结","url":"/2021/01/14/1-13-match-summary/","content":"<h1 id=\"赛时过程\"><a href=\"#赛时过程\" class=\"headerlink\" title=\"赛时过程\"></a>赛时过程</h1><span id=\"more\"></span>\n<p>这次树状数组专项练习赛，<del>我不会告诉你我做不起板子题。</del></p>\n<p>先看T1，一个sb板子，然后完美打挂过了。</p>\n<p>T2以为是某长代码蓝题的加强版直接爬，当时想这怕不是紫题。</p>\n<p>T3一看就知道毒瘤爬。T4板子又打挂了，40。现在排名垫底，rk10。</p>\n<p>慌得1p。看着旁边的某些高中学长比赛时讨论得热火朝天心里很不舒服。强迫自己冷静下来去看T3，没思路看T2，发现自己傻逼了，这题不就是个板子吗。于是切了回到T1。</p>\n<p>T1调了一个sb错误过了样例A了。现在剩下T3，由于是IOI赛制，我卡了卡常卡挂了然后老老实实开T3。</p>\n<p>想了一会儿发现可以逆序对做，于是代码灰常简单，就是必须<code>getchar</code>读入让我看着很不舒服。然后A了。于是AK，rk2，某高中巨佬xhw先AK了（这场比赛除了我都是高一）。我的程序总用时慢了100ms。</p>\n<p>于是………………</p>\n<p>我记得xhw巨佬好像不会写fread（（（（，赶紧卡常卡了半天比xhw巨佬少跑了一一半的时间。然后rk1。</p>\n<p>没想到这场比赛还能打个翻身仗。不过也许题水也是一个原因吧<del>我都能做出来那还能不水吗</del>。</p>\n<h1 id=\"赛后题解\"><a href=\"#赛后题解\" class=\"headerlink\" title=\"赛后题解\"></a>赛后题解</h1><p>T1T2板子，T4也比较板，写个T3题解吧。</p>\n<p>题目：</p>\n<p>何老板最近在玩一款叫”彩色方块”的小游戏，游戏虽然简单，但何老板仍旧乐此不疲。<br>游戏中有 $n$ 个彩色方块成一排，方块的颜色用字母表示，给出目标排列，只要把它们排成跟目标一样的排列，就算过关。每次操作只 能交换相邻两个方块。<br>给出一关游戏，何老板想知道，最少操作几次就能过关，请你帮他计算最少所需的操作步数。</p>\n<p>输入格式<br>第一行，一个整数 $n$ 表示方块的数量<br>第二行，$n$ 个大写字母，表示一开始方块的排列情况。每个字母表示对应方块的颜色。<br>第三行，$n$ 个大写字母，表示方块的目标排列情况。</p>\n<p>输出格式就不说了，样例：</p>\n<p>样例输入<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">RGB</span><br><span class=\"line\">GBR</span><br></pre></td></tr></table></figure><br>样例输出<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n<p>有一个比较显然的贪心策略：按照目标排列给原始排列编上号，比如样例原始排列编号312。然后先把编号小的交换的前面去，这样依次 交换。然后就是一个逆序对板子。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;deque&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> gc (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 131072, stdin), p1 == p2) ? EOF : *p1 ++)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">131072</span>], *p1, *p2;</span><br><span class=\"line\">std::deque&lt;<span class=\"keyword\">int</span>&gt; block[<span class=\"number\">26</span>];</span><br><span class=\"line\"><span class=\"keyword\">char</span> str1[<span class=\"number\">1000005</span>], str2[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">1000005</span>], c[<span class=\"number\">1000005</span>], n;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(x); i &lt;= n; i += (i &amp; ~i + <span class=\"number\">1</span>)) ++ c[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(x); i; i -= (i &amp; ~i + <span class=\"number\">1</span>)) sum += c[i];</span><br><span class=\"line\"><span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">ans</span><span class=\"params\">(<span class=\"number\">0LL</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\"><span class=\"keyword\">char</span> ch;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ((ch = gc) == <span class=\"string\">&#x27;\\n&#x27;</span> &amp;&amp; ch == <span class=\"string\">&#x27;\\r&#x27;</span> &amp;&amp; ch == <span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) str1[i] = gc - <span class=\"number\">65</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ((ch = gc) == <span class=\"string\">&#x27;\\n&#x27;</span> &amp;&amp; ch == <span class=\"string\">&#x27;\\r&#x27;</span> &amp;&amp; ch == <span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) str2[i] = gc - <span class=\"number\">65</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) block[str1[i]].<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">a[block[str2[i]].<span class=\"built_in\">front</span>()] = i, block[str2[i]].<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) ans += (<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)<span class=\"built_in\">query</span>(n) - <span class=\"built_in\">query</span>(a[i]), <span class=\"built_in\">update</span>(a[i]);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["比赛"],"tags":["比赛"]},{"title":"NKOJ元旦欢乐赛Div1总结","url":"/2021/01/03/NKOJ%E5%85%83%E6%97%A6%E6%AC%A2%E4%B9%90%E8%B5%9BDiv1-Div2%E6%80%BB%E7%BB%93/","content":"<p>div1初中组，div2高中组。</p>\n<span id=\"more\"></span>\n<p>老板：你既是初中生，也是高中生。</p>\n<p><del>然而我只是个无辜的小六生。</del></p>\n<h2 id=\"赛时过程：\"><a href=\"#赛时过程：\" class=\"headerlink\" title=\"赛时过程：\"></a>赛时过程：</h2><p>其实Div1和Div2都做得烂爆了qwq。</p>\n<p>Div1前三道一看签到题，爆切了直接过。</p>\n<p>然后后面的题卡死了……</p>\n<p>比赛最后十分钟发现E看错题了，瞬间想到正解，可是有什么用呢，于是比赛就这样结束了。</p>\n<p>于是我除了签到题就是爆零了。/kk</p>\n<p>比赛后评讲是只用了一半时间就AK的银牌爷<a href=\"https://www.luogu.com.cn/user/38685\">deaf</a>，stO deaf Orz,deafAKIOI是我们的神，deaf太强了，deafAKIOIeveryday</p>\n<h2 id=\"赛后题解：\"><a href=\"#赛后题解：\" class=\"headerlink\" title=\"赛后题解：\"></a>赛后题解：</h2><p>A题：$n$ 个球，每个球标有一个数字，问你最少修改多少个小球上的数字能使得最多有 $k$ 个不同数字出现在小球上。</p>\n<p>纯签到送分。直接放代码。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">200002</span>];</span><br><span class=\"line\">std::priority_queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, k, <span class=\"built_in\">t</span>(<span class=\"number\">0</span>), <span class=\"built_in\">len</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, a + i);</span><br><span class=\"line\">std::<span class=\"built_in\">sort</span>(a + <span class=\"number\">1</span>, a + n + <span class=\"number\">1</span>);</span><br><span class=\"line\">a[<span class=\"number\">0</span>] = a[<span class=\"number\">1</span>] - <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; ++ i) <span class=\"keyword\">if</span> (a[i] != a[i - <span class=\"number\">1</span>]) q.<span class=\"built_in\">push</span>(len), len = <span class=\"number\">1</span>; <span class=\"keyword\">else</span> ++ len;</span><br><span class=\"line\">q.<span class=\"built_in\">push</span>(len);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ans</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (q.<span class=\"built_in\">size</span>() &amp;&amp; k --) ans -= q.<span class=\"built_in\">top</span>(), q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>B题：一个 $n$ 层的数字金字塔上有 $n(n+1)\\div 2$ 个非负整数。当一个数字的左上方和右上方没有数字时就可以被取走。现在要取走恰好 $k$ 个数，并且使拿走的最小数最小。请你帮忙计算，可能取走的最小数是多少。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">210</span>][<span class=\"number\">210</span>], mark[<span class=\"number\">210</span>][<span class=\"number\">210</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mark[x][y]) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">mark[x][y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (x == <span class=\"number\">1</span> &amp;&amp; y == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (y == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">dfs</span>(x - <span class=\"number\">1</span>, <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x == y) <span class=\"keyword\">return</span> <span class=\"built_in\">dfs</span>(x - <span class=\"number\">1</span>, y - <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">dfs</span>(x - <span class=\"number\">1</span>, y - <span class=\"number\">1</span>) + <span class=\"built_in\">dfs</span>(x - <span class=\"number\">1</span>, y) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, k, <span class=\"built_in\">ans</span>(<span class=\"number\">0x7fffffff</span>);</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= i; ++ j) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">1</span>); j &lt;= i; ++ j) <span class=\"keyword\">if</span> (a[i][j] &lt; ans) &#123;</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> mark);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">dfs</span>(i, j) &lt;= k) ans = a[i][j];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>C题，不想说题面了qwq：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> node X) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> x &lt; X.x;&#125;</span><br><span class=\"line\">&#125; a[<span class=\"number\">500005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> mark[<span class=\"number\">500005</span>][<span class=\"number\">7</span>];</span><br><span class=\"line\">std::priority_queue&lt;node&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> m, n, <span class=\"built_in\">ans</span>(<span class=\"number\">0LL</span>);</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;m, &amp;n);</span><br><span class=\"line\">mark[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = mark[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = mark[<span class=\"number\">1</span>][<span class=\"number\">2</span>] = mark[<span class=\"number\">1</span>][<span class=\"number\">3</span>] = mark[<span class=\"number\">1</span>][<span class=\"number\">4</span>] = mark[<span class=\"number\">1</span>][<span class=\"number\">5</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;a[i].x, &amp;a[i].y), q.<span class=\"built_in\">push</span>(a[i]);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt;= m; ++ i) &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, ans);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">0</span>); j &lt;= <span class=\"number\">5</span>; ++ j) <span class=\"keyword\">if</span> (mark[i][j]) &#123;</span><br><span class=\"line\"><span class=\"function\">node <span class=\"title\">t</span><span class=\"params\">(q.top())</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (i + q.<span class=\"built_in\">top</span>().y - <span class=\"number\">1</span> &lt;= m) mark[i + t.y][j] = <span class=\"literal\">true</span>, ans += t.x * t.y, q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"><span class=\"keyword\">else</span> ans += t.x * (m - i + <span class=\"number\">1</span>), q.<span class=\"built_in\">pop</span>(), q.<span class=\"built_in\">push</span>(node &#123;t.x, t.y - (m - i + <span class=\"number\">1</span>)&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>D题：</p>\n<p>将 $n$ 拆分为若干个分数 $\\frac{a_i}{b_i}$ 的和，满足以下条件：</p>\n<ul>\n<li>$a_i, b_i$ 都是正整数</li>\n<li>$b_i$ 是 $n$ 的约数</li>\n<li>$b_i$ 严格单调递增<br>求方案数 $mod 2^{31}$。</li>\n</ul>\n<p>赛场上想到了正解的一半，讲完了觉得真的是个大水题。</p>\n<p>就把每个因数看成背包乱搞。理论上有 $O(\\sqrt{n})$ 个因数。然而众所周知这个上界完全是假的，实际情况也就 $O(logn)$ 的常数倍左右而已，所以可以轻松通过。</p>\n<p>这题都没做出来，我真是个菜逼。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> f[<span class=\"number\">1000005</span>], p[<span class=\"number\">2005</span>], cnt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, &amp;n);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(n - <span class=\"number\">1</span>); i &gt;= <span class=\"number\">2</span>; -- i) <span class=\"keyword\">if</span> (n % i == <span class=\"number\">0</span>) p[++ cnt] = i;</span><br><span class=\"line\">f[<span class=\"number\">0</span>] = <span class=\"number\">1LL</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= cnt; ++ i)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(p[i]); j &lt; n; ++ j) f[j] += f[j - p[i]], f[j] %= (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">31</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, f[n - <span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>E题：</p>\n<p>不说了这题看题问题没搞出来题目都懒得说。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &gt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Line</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> l, r;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> Line x) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> l &lt; x.l;&#125;</span><br><span class=\"line\">&#125; a[<span class=\"number\">300005</span>], b[<span class=\"number\">300005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnta, cntb;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m, <span class=\"built_in\">ans</span>(<span class=\"number\">0LL</span>), <span class=\"built_in\">MaxR</span>(<span class=\"number\">0LL</span>), <span class=\"built_in\">len</span>(<span class=\"number\">0LL</span>);</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) &#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;x, &amp;y);</span><br><span class=\"line\">x &lt;= y ? a[++ cnta] = Line &#123;x, y&#125; : b[++ cntb] = Line &#123;y, x&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">std::<span class=\"built_in\">sort</span>(a + <span class=\"number\">1</span>, a + cnta + <span class=\"number\">1</span>), std::<span class=\"built_in\">sort</span>(b + <span class=\"number\">1</span>, b + cntb + <span class=\"number\">1</span>);</span><br><span class=\"line\">ans = m;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (cntb == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, ans), <span class=\"number\">0</span>;</span><br><span class=\"line\">MaxR = b[<span class=\"number\">1</span>].r, len = b[<span class=\"number\">1</span>].r - b[<span class=\"number\">1</span>].l;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">2</span>); i &lt;= cntb; ++ i) <span class=\"keyword\">if</span> (b[i].r &gt; MaxR)</span><br><span class=\"line\">len += b[i].r - <span class=\"built_in\">max</span>(MaxR, b[i].l), MaxR = b[i].r;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld\\n&quot;</span>, ans + (len &lt;&lt; <span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>F题：</p>\n<p>整场比赛唯一一道难题。</p>\n<p>NKOJ上一共有 $n$ 道题，题目编号 $1$ 到 $n$，每道题都有一个难度系数，第 $i$ 题的难度系数为正整数 $p_i$。</p>\n<p>NK信竞队总共有 $m$ 名同学，编号 $1$ 到 $m$。何老板给每个同学都安排了解题任务。其中第 $i$ 号同学的任务是在编号在 $a_i$ 到 $b_i$ 之间的题中，任选一道，并刷掉它。</p>\n<p>不过，NK的同学们都很懒，他们总会选难度最低的题来做，每个同学都有一个解题能力值 $c_i$，同学们是不会去做难度系数超过其解题能力的题的。比如第 $i$ 号同学会从 $[a_i, b_i]$ 中选难度系数最低的题出来，如果这个题的难度系数大于 $c_i$，号同学就会放弃 解题，进入自闭状态，并表示自己”太菜了”。<br>同学们的解题习性让何老板很是烦恼，何老板想给每道题都设定一个合适的难度系数，使得同学们完成的题目的难度系数总和尽量大。</p>\n<p>请你帮助何老板设定每道题的难度系数，并计算出所有人完成题目的难度系数总和的最大值。</p>\n<p><del>首先题目非常真实好评。</del></p>\n<p>非常好也很妙的题，考试里就deafakioi一个人做出来。</p>\n<p>先猜一猜复杂度（滑稽），$O(n^2m)$ or $O(n^3m)$</p>\n<p>是一道关于线段覆盖的题目。首先应该想到区间DP，<del>然而我太弱了没想到</del>。</p>\n<p>显然每道题的难度只为设为所有 $c_i$ 中的一个。</p>\n<p>状态：$f[i][j]$ 表示做题区间<strong>完全包含</strong>在 $[i,j]$ 中的同学完成的题目难度系数最大的总和。</p>\n<p>方程：$f[i][j] = max${$f[i][k - 1] + f[k + 1][j] + S$}$(i\\le k\\le j)$</p>\n<p>$S$ 表示所有经过 $k$ 的线段的最大难度系数总和。</p>\n<p>然而有问题，因为我们不知道 $[i,k-1],[k+1,j]$ 里是否有更简单的题。</p>\n<p>所以修改状态：$f[i][j][x]$ 表示做题区间完全包含在 $[i,j]$ 中的同学完成的题目难度系数最大的总和，且最简单的一道题难度为 $x$。将每道题的难度（$c_i$）离散化一下。</p>\n<p>方程：$f[i][j][x] = max${$g[i][k - 1][x] + g[k + 1][j][x] + S$}$(i\\le k\\le j)$</p>\n<p>其中 $g[i][j][x]$ 表示所有 $f[i][j][k]$ 的最大值，$k\\ge x$。</p>\n<p>其中，$x$ 为完全包含在区间 $[i,j]$ 内的线段的难度系数。$S$ 为所有经过点 $k$ 并且被完全包含在 $[i,j]$ 内的线段的数量乘上 $x$。</p>\n<p>现在只有一个问题，就是 $S$ 怎么算？</p>\n<p>神爷deaf给我们讲了这东西的套路：$h[i][j]$ 表示完全包含在 $[i,j]$ 内的区间数量。则完全包含在 $[i,j]$ 中且经过点 $k$ 的线 段数量为 $h[i][j]-h[i][k-1]-h[k+1][j]$。我们用区间数量乘上 $x$ 就行了。$h[i][j]$ 可以很简单地预处理出来。</p>\n<p>时间复杂度 $O(n^3m)$</p>\n<p>差不多完事了？</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code:$\"></a>$Code:$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> l, r, x, p;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> node X) &#123;<span class=\"keyword\">return</span> x &lt; X.x;&#125;</span><br><span class=\"line\">&#125; a[<span class=\"number\">4001</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> f[<span class=\"number\">51</span>][<span class=\"number\">51</span>][<span class=\"number\">4001</span>], g[<span class=\"number\">51</span>][<span class=\"number\">51</span>][<span class=\"number\">4001</span>], h[<span class=\"number\">51</span>][<span class=\"number\">51</span>][<span class=\"number\">4001</span>], Key[<span class=\"number\">4001</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &gt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= m; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;a[i].l, &amp;a[i].r, &amp;a[i].x);</span><br><span class=\"line\">std::<span class=\"built_in\">sort</span>(a + <span class=\"number\">1</span>, a + m + <span class=\"number\">1</span>);</span><br><span class=\"line\">Key[a[<span class=\"number\">1</span>].p = <span class=\"number\">1</span>] = a[<span class=\"number\">1</span>].x;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">2</span>); i &lt;= m; ++ i)</span><br><span class=\"line\">Key[a[i].p = (a[i].x != a[i - <span class=\"number\">1</span>].x) + a[i - <span class=\"number\">1</span>].p] = a[i].x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">k</span>(<span class=\"number\">1</span>); k &lt;= m; ++  k)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= a[k].l; ++ i)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(a[k].r); j &lt;= n; ++ j) ++ h[i][j][a[k].p];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(i); j &lt;= n; ++ j)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">k</span>(a[m].p - <span class=\"number\">1</span>); k; -- k)</span><br><span class=\"line\">h[i][j][k] += h[i][j][k + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">l</span>(<span class=\"number\">1</span>); l &lt;= n; ++ l)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n - l + <span class=\"number\">1</span>; ++ i) &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">j</span><span class=\"params\">(i + l - <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">x</span>(<span class=\"number\">1</span>); x &lt;= m; ++ x) <span class=\"keyword\">if</span> (a[x].l &gt;= i &amp;&amp; a[x].r &lt;= j) &#123;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">k</span>(i); k &lt;= j; ++ k)</span><br><span class=\"line\">g[i][j][a[x].p] = f[i][j][a[x].p] = <span class=\"built_in\">max</span>(f[i][j][a[x].p], g[i][k - <span class=\"number\">1</span>][a[x].p]</span><br><span class=\"line\">+ g[k + <span class=\"number\">1</span>][j][a[x].p] + (h[i][j][a[x].p] - h[i][k - <span class=\"number\">1</span>][a[x].p] -</span><br><span class=\"line\">h[k + <span class=\"number\">1</span>][j][a[x].p]) * Key[a[x].p]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">x</span>(a[m].p - <span class=\"number\">1</span>); x; -- x) g[i][j][x] = <span class=\"built_in\">max</span>(g[i][j][x], g[i][j][x + <span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ans</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= a[m].p; ++ i) ans = <span class=\"built_in\">max</span>(ans, f[<span class=\"number\">1</span>][n][i]);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>G题：</p>\n<p>有点意思，但是不难，这题一眼看上去数论难题又排在最后一位，我没敢看，结果其实不难。</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P1758\">传送门</a></p>\n<p>首先，让我们求平方和肯定是有原因的嘛QAQ（（（</p>\n<p>可以看成两个装置同时取珠，两个装置输出了相同的序列则答案加一。<br><del>这个很好理解吧（（（</del></p>\n<p>然后：$f[i][j][x][y]$ 表示第一个装置上管道取到了 $i$ 个珠子，下管道取到了 $j$ 个珠子，第二个装置同理。</p>\n<p>因为 $i+j=x+y$，所以最后那一维可以不要。</p>\n<p>最后滚动一下就好了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MOD = <span class=\"number\">1024523</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &gt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">upd</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">if</span> ((x += y) &gt;= MOD) x -= MOD;&#125;</span><br><span class=\"line\"><span class=\"keyword\">char</span> a[<span class=\"number\">501</span>], b[<span class=\"number\">501</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">2</span>][<span class=\"number\">501</span>][<span class=\"number\">501</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d\\n%s\\n%s&quot;</span>, &amp;n, &amp;m, a + <span class=\"number\">1</span>, b + <span class=\"number\">1</span>);</span><br><span class=\"line\">std::<span class=\"built_in\">reverse</span>(a + <span class=\"number\">1</span>, a + n + <span class=\"number\">1</span>), std::<span class=\"built_in\">reverse</span>(b + <span class=\"number\">1</span>, b + m + <span class=\"number\">1</span>);</span><br><span class=\"line\">dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt;= n; ++ i) &#123;</span><br><span class=\"line\">int t(i &amp; 1), t2(i - 1 &amp; 1);</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(dp[t], <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> dp[t]);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">0</span>); j &lt;= m; ++ j)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> <span class=\"built_in\">k</span>(<span class=\"built_in\">max</span>(<span class=\"number\">0</span>, i + j - m)); k &lt;= <span class=\"built_in\">min</span>(i + j, n); ++ k) &#123;</span><br><span class=\"line\">int l(i + j - k), &amp;f(dp[t][j][k]);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (i &amp;&amp; k &amp;&amp; a[i] == a[k]) <span class=\"built_in\">upd</span>(f, dp[t2][j][k - <span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (i &amp;&amp; l &amp;&amp; a[i] == b[l]) <span class=\"built_in\">upd</span>(f, dp[t2][j][k]);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (j &amp;&amp; k &amp;&amp; b[j] == a[k]) <span class=\"built_in\">upd</span>(f, dp[t][j - <span class=\"number\">1</span>][k - <span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (j &amp;&amp; l &amp;&amp; b[j] == b[l]) <span class=\"built_in\">upd</span>(f, dp[t][j - <span class=\"number\">1</span>][k]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, dp[n &amp; <span class=\"number\">1</span>][m][n]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["比赛"],"tags":["比赛"]},{"title":"洛谷 P4182 【[USACO18JAN]Lifeguards P】","url":"/2020/12/26/%E6%B4%9B%E8%B0%B7-P4182-%E3%80%90-USACO18JAN-Lifeguards-P%E3%80%91/","content":"<h1 id=\"UPD\"><a href=\"#UPD\" class=\"headerlink\" title=\"UPD:\"></a>UPD:</h1><span id=\"more\"></span>\n<p>修复了代码中一个数组越界的问题，并进行卡常，使得不开O2也能轻松过题</p>\n<p>这题在学校听了老板讲，然而并没有听懂个啥（</p>\n<p>然后自己重新定状态，推式子，优化（</p>\n<p><del>IEE</del></p>\n<p>吐槽翻译。<a href=\"https://www.luogu.com.cn/paste/opegmwc5\">题面</a></p>\n<h1 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h1><p>首先将每个救生牛的工作时段抽象为线段。则题意变为，给你 $N$ 条线段，要你删除 $K$ 条，使得剩下的线段覆盖最多的点。为了方便描述，令 $l_i=s_i$，$r_i=t_i$</p>\n<p>很多题解一上来先去掉了什么”不需要保留的线段”。其实我认为正常做题应该是想好了如何动规再根据动规需求删除这些没有保留价值的线段。</p>\n<h2 id=\"朴素做法的状态与方程\"><a href=\"#朴素做法的状态与方程\" class=\"headerlink\" title=\"朴素做法的状态与方程\"></a>朴素做法的状态与方程</h2><p>根据数据范围，设 $f[i][j]$ 表示前 $i$ 条线段，删除了 $j$ 条，剩下的线段最多可以覆盖多少个点。</p>\n<p>方程为：$f[i][j]=max${$f[k][j-i+k+1]+r_i-max(l_i,r_k)$}$(i-j-1\\le k\\le i-1,i\\le N,j\\le K)$</p>\n<p>然而时间复杂度 $O(NK^2)$，<del>如果对自己的常数与厌氧程度不够自信</del>建议放弃</p>\n<h2 id=\"优化DP\"><a href=\"#优化DP\" class=\"headerlink\" title=\"优化DP\"></a>优化DP</h2><p>上述内容自己稍加思考便能想到。难的是优化。</p>\n<p>状态数肯定逃不了，想办法在 $O(K)$ 的转移上做手脚。</p>\n<p>根据动规优化的套路，将式子中与 $k$ 无关的项硬提出来。令 $x=j-i+1$。</p>\n<p>则原式变为：$f[i][j]=max\\{f[k][x+k]+r_i-max(l_i,r_k)\\}$</p>\n<p>现在很讨厌的是里面的那个 $max$。我们尝试用干掉绝对值的方法干掉这个 $max$—<strong>分类讨论</strong>。</p>\n<p>如果 $r_k\\le l_i$，相当于要 $f[k][x+k]$ 最大。</p>\n<p>如果 $r_k&gt;l_i$，相当于要 $f[k][x+k]-r_k$ 最大。</p>\n<p>为了方便维护，我们考虑将每条线段按左端点排序。这样方便确定计算顺序。</p>\n<p>现在，如果按传统的<code>for(i 1......n),for(j 1......k)</code>计算很不方便。</p>\n<p>考虑按照 $x=j-i+1$ 划分阶段。$1$ 是常数，相当于按照 $j-i$ 划分阶段。</p>\n<p>我们发现，所有能转移到状态 $f[i][j]$ 的状态 $f[x][y]$ <strong>必定满足</strong> $y-x=j-i+1$。所以，状态 $f[i][j]$ 能转移到的状态 $f[x_1][y_1]$ 满足 $y_1-x_1=j-i-1$。</p>\n<p>因此按照 $j-i$ <strong>倒序</strong>计算每个状态。将所有 $j-i=0$ 的状态设为 $0$（相当于所有线段全部删除）。</p>\n<p>这样，就相当于在所有范围内的 $k$ 中，对于 $r_k\\le l_i$ 的情况（情况1）取一个最大值，对于 $r_k&gt;l_i$ （情况2）取一个最大值。</p>\n<p>考虑使用前缀和sum维护情况1，单调队列维护情况2。因为所有线段按照左端点排好了序，所以在 $x=j-i-1$ 确定的情况下，从小到大枚举 $j$（个人认为枚举 $j$ 方便，枚举 $i$ 当然也没有任何问题），$i$ 也是从小到大的，$r_{i-1}$ 也是从小到大的。（为什么是 $i-1$，因为 $i-j-1\\le k\\le i-1$），$l_{i-1}$ 也是从小到大的。</p>\n<p>等等！线段只按照左端点进行了排序，为什么 $r_{i-1}$ 也”天然有序”？仔细想想，如果有两条线段 $i$，$j$，$l_i\\le l_j$ 且 $r_i\\ge r_j$，线段 $j$ 无论保留还是删除都不会影响结果。换句话说，$j$ 被 $i$ <strong>完全覆盖</strong>了，我们应该在预处理时删掉这种线段。如果预处理完已经删除了超过 $K$ 条线段直接将所有线段覆盖的点数输出即可。</p>\n<p>扯了半天，回到式子。单调队列装下每个方案对应的 $k$，每次检查单调队列首部的元素 $k$ 是否 $r_k\\le l_i$，如果是，将这个方案的 $f[k][x+k]$ 计算出来，与 $sum$ 比较取大值。单调队列<code>pop_front()</code>。然后根据各个线段的情况决定 $k=i-1$ 放到单调队列里还是直接更新前缀和。</p>\n<p>时间复杂度：$O(NK)$。因为单调队列每个元素最多只会有一次进队和出队的机会。</p>\n<p>细节见代码。</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code:$\"></a>$Code:$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &gt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MaxN = <span class=\"number\">100001</span>, INF = <span class=\"number\">0x3fffffff</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Line</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> l, r;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> Line x) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> l &lt; x.l;&#125;</span><br><span class=\"line\">&#125; a[MaxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">int</span> MAXSIZE&gt; <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">deque</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> head, tail, a[MAXSIZE];</span><br><span class=\"line\"><span class=\"built_in\">deque</span>() &#123;head = <span class=\"number\">0</span>, tail = <span class=\"number\">-1</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;head = <span class=\"number\">0</span>, tail = <span class=\"number\">-1</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;a[++ tail] = x;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span> </span>&#123;-- tail;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pop_front</span><span class=\"params\">()</span> </span>&#123;++ head;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> tail - head + <span class=\"number\">1</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">front</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> a[head];&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">back</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> a[tail];&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">deque&lt;1005&gt; q;</span><br><span class=\"line\"><span class=\"keyword\">int</span> f[MaxN][<span class=\"number\">101</span>], L[MaxN], R[MaxN], n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> N, K, <span class=\"built_in\">ans</span>(-INF), <span class=\"built_in\">MaxR</span>(-INF);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;N, &amp;K);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(f, ~<span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= N; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;a[i].l, &amp;a[i].r);</span><br><span class=\"line\">    std::<span class=\"built_in\">sort</span>(a + <span class=\"number\">1</span>, a + N + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= N; ++ i) <span class=\"keyword\">if</span> (a[i].r &gt; MaxR)</span><br><span class=\"line\">    L[++ n] = a[i].l, R[n] = a[i].r, MaxR = a[i].r;</span><br><span class=\"line\">    K -= N - n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (K &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        int ans(0), MaxR(L[1]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) ans += R[i] - <span class=\"built_in\">max</span>(MaxR, L[i]), MaxR = R[i];</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt;= K; ++ i) f[i][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">k</span>(<span class=\"number\">-1</span>); k &gt;= -n; -- k) &#123;</span><br><span class=\"line\">        int x(k + 1), sum(-INF);</span><br><span class=\"line\">        q.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">0</span>); j &lt;= <span class=\"built_in\">min</span>(K, n + k); ++ j) &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">i</span><span class=\"params\">(j - k)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (q.<span class=\"built_in\">size</span>() &amp;&amp; R[q.<span class=\"built_in\">front</span>()] &lt;= L[i])</span><br><span class=\"line\">                sum = <span class=\"built_in\">max</span>(sum, f[q.<span class=\"built_in\">front</span>()][x + q.<span class=\"built_in\">front</span>()]), q.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (R[i - <span class=\"number\">1</span>] &lt;= L[i]) sum = <span class=\"built_in\">max</span>(sum, f[i - <span class=\"number\">1</span>][x + i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (q.<span class=\"built_in\">size</span>() &amp;&amp; f[q.<span class=\"built_in\">back</span>()][x + q.<span class=\"built_in\">back</span>()] - R[q.<span class=\"built_in\">back</span>()] &lt;=</span><br><span class=\"line\">                f[i - <span class=\"number\">1</span>][x + i - <span class=\"number\">1</span>] - R[i - <span class=\"number\">1</span>]) q.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">                q.<span class=\"built_in\">push_back</span>(i - <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            f[i][j] = sum - L[i] + R[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q.<span class=\"built_in\">size</span>()) f[i][j] = <span class=\"built_in\">max</span>(f[i][j], f[q.<span class=\"built_in\">front</span>()][x + q.<span class=\"built_in\">front</span>()] - R[q.<span class=\"built_in\">front</span>()] + R[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(n - K); i &lt;= n; ++ i) ans = <span class=\"built_in\">max</span>(ans, f[i][K - n + i]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["动态规划","数据结构"],"tags":["动态规划","单调队列"]},{"title":"12/19练习赛总结","url":"/2020/12/19/12-19%E7%BB%83%E4%B9%A0%E8%B5%9B%E6%80%BB%E7%BB%93/","content":"<p>这次是动规专练QwQ。2h30min。</p>\n<p><del>赛前祈祷：我弱智的DP啊，我弱智的DP啊</del></p>\n<span id=\"more\"></span>\n<p><del>然而还是没有我的数论弱智</del></p>\n<p>如果考数据结构优化动规那就rk前3稳了QwQ<del>震惊！数据结构狂热爱好者竟敢口出狂言！</del></p>\n<p>一共六道，ABCDEF。A题抢到二血（？），B抢到First Blood，看来不错嘛（危）</p>\n<p>做了E，30分。目前rk1，估计一直这样发挥就rk1稳了（大危）</p>\n<p>E题改了半天不知道哪里错了。看看C，几下干掉了发现超时 $17pts$，通过一些很艹的手段卡到了 $66pts$（大大大大大大大危）。</p>\n<p>看了看排行榜。我rk8了？？？</p>\n<p>？</p>\n<p>？？</p>\n<p>？？？</p>\n<p>？？？？</p>\n<p>？？？？？</p>\n<p>？？？？？？</p>\n<p><del>tmd你们死定了</del></p>\n<p>然后肝D，搞了好久好久。</p>\n<p><del>艹尼玛我今天不A了这题我倒立吃奥力给</del></p>\n<p>半个小时后……发现题目有一个理解错的地方，赶紧改，$60\\operatorname{pts}$，然后改了一个弱智错误A了。</p>\n<p>随即肝E。$1\\operatorname{min}$ A了。还是一个弱智错。</p>\n<p>此时比赛还剩 $13\\operatorname{min}$。赶紧看F题。</p>\n<p>看完了发现是个水题。赶紧做。于是在我打最后一个字母时考试结束了。</p>\n<p><del>nmsl。</del></p>\n<p>发挥……还行吧，正常。但是失策了，因为我的某些傻逼细胞花了太多时间肝D和E，没看水得1p的F。</p>\n<p>最后竟然rk4。不知道大家是不是都挂了。（然而赛后发现不是，顿时原地懵逼）</p>\n<h1 id=\"菜-是-原-罪\"><a href=\"#菜-是-原-罪\" class=\"headerlink\" title=\"菜 是 原 罪\"></a>菜 是 原 罪</h1><h1 id=\"你蒻归你蒻，你没有zqs蒻\"><a href=\"#你蒻归你蒻，你没有zqs蒻\" class=\"headerlink\" title=\"你蒻归你蒻，你没有zqs蒻\"></a>你蒻归你蒻，你没有zqs蒻</h1><p>赛后题解<del>马上</del>补。</p>\n","categories":["比赛"],"tags":["比赛"]},{"title":"洛谷P2839 [国家集训队]middle","url":"/2020/12/17/P2839-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-middle/","content":"<p><a href=\"https://www.luogu.com.cn/problem/P2839\">传送门</a></p>\n<p>做主席树练习的时候搜到了这题，不过看到这数据范围我的第一反应是分块……</p>\n<span id=\"more\"></span>\n<p>分块确实能过，时间复杂度没问题，代码短，常数小，跑得更快。只不过渐进时间复杂度更高。不过反正都是来练习主席树的就用主席树做吧。</p>\n<p>框架大概是二分中位数 <code>mid</code> 值看能否实现。</p>\n<p><del>于是沉思良久决定看题解。</del></p>\n<blockquote>\n<p>首先，对于区间中位数，有一个比较套路的做法：将区间内每个比当前mid值大或相等的设置为1，否则设置为-1，对区间进行求和。如果和非负，中位数可以变大；否则，中位数只能调小</p>\n</blockquote>\n<p><del>摘自题解。</del></p>\n<p><del>wcnmd这是套路？果然还是我太年轻了啊。</del></p>\n<p>于是我想了想决定对于每一个 <code>mid</code> 建一颗线段树（肯定要离散化）。空间炸了，于是用主席树。</p>\n<p>然后二分 <code>mid</code> ，对于每个给定的区间范围，$[b,c]$ 为必选区间，然后在 $[a,b-1]$ 中取最大后缀，在 $[c+1,d]$ 中取最大前缀。</p>\n<p>主席树每个节点维护当前区间的和，最大前缀，最大后缀，区间合并的时候就很easy了。</p>\n<p>复杂度 $O(nlog^2_2n)$，而分块复杂度为 $O(n\\sqrt{n})$<br><del>然后不能Unique啥的，我就做了四天</del></p>\n<p><del>cnm</del></p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code:$\"></a>$Code:$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">int x(0), f(1);</span><br><span class=\"line\"><span class=\"keyword\">while</span> ((ch = <span class=\"built_in\">getchar</span>()) &lt; <span class=\"number\">48</span>) <span class=\"keyword\">if</span> (ch == <span class=\"string\">&#x27;-&#x27;</span>) f = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">do</span> x = x * <span class=\"number\">10</span> + ch - <span class=\"number\">48</span>; <span class=\"keyword\">while</span> ((ch = <span class=\"built_in\">getchar</span>()) &gt;= <span class=\"number\">48</span>);</span><br><span class=\"line\"><span class=\"keyword\">return</span> x * f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Max</span> &#123;</span><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">operator</span> <span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y)</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> x &gt; y ? x : y;&#125;&#125; max;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">20005</span>, n = <span class=\"built_in\">read</span>();</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[N], Key[N];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">I_want_to_AKIOI</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> v, idx, rnk;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> I_want_to_AKIOI x) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> v &lt; x.v;&#125;</span><br><span class=\"line\">&#125; b[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Chairman_tree</span> &#123;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> v, v1, v2, ls, rs;</span><br><span class=\"line\">&#125; a[N &lt;&lt; <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> rt[N], tot, x, y, ans, s;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">make_tree</span>(rt[<span class=\"number\">1</span>] = tot = <span class=\"number\">1</span>, <span class=\"number\">1</span>, n);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make_tree</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> p, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> l, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">a[p].v = a[p].v1 = a[p].v2 = r - l + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (l != r) <span class=\"built_in\">make_tree</span>(a[p].ls = ++ tot, l, l + r &gt;&gt; <span class=\"number\">1</span>),</span><br><span class=\"line\"><span class=\"built_in\">make_tree</span>(a[p].rs = ++ tot, (l + r &gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Update</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">k</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\"><span class=\"comment\">//if (b[i].rnk == b[i - 1].rnk) x = b[i].idx, update(rt[k], 1, n, rt[k - 1]);</span></span><br><span class=\"line\">x = b[i].idx, rt[++ k] = ++ tot, <span class=\"built_in\">update</span>(rt[k], <span class=\"number\">1</span>, n, rt[k - <span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> p, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> l, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> r, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> root)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (l == r) &#123;a[p].v = <span class=\"number\">-1</span>, a[p].v1 = a[p].v2 = <span class=\"number\">0</span>; <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">int mid(l + r &gt;&gt; 1), &amp;ls(a[p].ls), &amp;rs(a[p].rs);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mid &gt;= x) &#123;</span><br><span class=\"line\"><span class=\"built_in\">update</span>((ls ? ls : ls = ++ tot), l, mid, a[root].ls);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!rs) rs = a[root].rs;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"built_in\">update</span>((rs ? rs : rs = ++ tot), mid + <span class=\"number\">1</span>, r, a[root].rs);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!ls) ls = a[root].ls;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a[p].v = a[ls].v + a[rs].v, a[p].v1 = <span class=\"built_in\">max</span>(a[ls].v1, a[ls].v + a[rs].v1),</span><br><span class=\"line\">a[p].v2 = <span class=\"built_in\">max</span>(a[rs].v2, a[rs].v + a[ls].v2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">Query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> A, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> B, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> C, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> D)</span> </span>&#123;</span><br><span class=\"line\">int l(1), r(n), Ans(0);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">x = B, y = C;</span><br><span class=\"line\">int mid(l + r &gt;&gt; 1), sum(query(rt[mid], 1, n));</span><br><span class=\"line\">x = A, y = B - <span class=\"number\">1</span>, s = ans = <span class=\"number\">0</span>, <span class=\"built_in\">queryr</span>(rt[mid], <span class=\"number\">1</span>, n), sum += ans;</span><br><span class=\"line\">x = C + <span class=\"number\">1</span>, y = D, s = ans = <span class=\"number\">0</span>, <span class=\"built_in\">queryl</span>(rt[mid], <span class=\"number\">1</span>, n), sum += ans;</span><br><span class=\"line\">sum &gt;= <span class=\"number\">0</span> ? Ans = mid, l = mid + <span class=\"number\">1</span> : r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> Ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">queryl</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> p, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> l, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;ans = <span class=\"built_in\">max</span>(ans, s + a[p].v1), s += a[p].v; <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(l + r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mid &gt;= x) <span class=\"built_in\">queryl</span>(a[p].ls, l, mid);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mid &lt; y) <span class=\"built_in\">queryl</span>(a[p].rs, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">queryr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> p, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> l, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;ans = <span class=\"built_in\">max</span>(ans, s + a[p].v2), s += a[p].v; <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(l + r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mid &lt; y) <span class=\"built_in\">queryr</span>(a[p].rs, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mid &gt;= x) <span class=\"built_in\">queryr</span>(a[p].ls, l, mid);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> p, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> l, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> r)</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class=\"keyword\">return</span> a[p].v;</span><br><span class=\"line\">int mid(l + r &gt;&gt; 1), sum(0);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mid &gt;= x) sum += <span class=\"built_in\">query</span>(a[p].ls, l, mid);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mid &lt; y) sum += <span class=\"built_in\">query</span>(a[p].rs, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\"><span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125; Tree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">int last(0), m;</span><br><span class=\"line\">Tree.<span class=\"built_in\">build</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) b[i].idx = i, b[i].v = a[i] = <span class=\"built_in\">read</span>();</span><br><span class=\"line\">std::<span class=\"built_in\">sort</span>(b + <span class=\"number\">1</span>, b + n + <span class=\"number\">1</span>);</span><br><span class=\"line\">Key[b[<span class=\"number\">1</span>].rnk = <span class=\"number\">1</span>] = b[<span class=\"number\">1</span>].v;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">2</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">Key[b[i].rnk = (b[i].v == b[i - <span class=\"number\">1</span>].v ? b[i - <span class=\"number\">1</span>].rnk : b[i - <span class=\"number\">1</span>].rnk + <span class=\"number\">1</span>)] = b[i].v;</span><br><span class=\"line\">std::<span class=\"built_in\">sort</span>(a + <span class=\"number\">1</span>, a + n + <span class=\"number\">1</span>);</span><br><span class=\"line\">Tree.<span class=\"built_in\">Update</span>(), m = <span class=\"built_in\">read</span>();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (m --) &#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> q[<span class=\"number\">4</span>] = &#123;<span class=\"built_in\">read</span>(), <span class=\"built_in\">read</span>(), <span class=\"built_in\">read</span>(), <span class=\"built_in\">read</span>()&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">0</span>); i &lt; <span class=\"number\">4</span>; ++ i) q[i] = (q[i] + last) % n + <span class=\"number\">1</span>;</span><br><span class=\"line\">std::<span class=\"built_in\">sort</span>(q, q + <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, last = a[Tree.<span class=\"built_in\">Query</span>(q[<span class=\"number\">0</span>], q[<span class=\"number\">1</span>], q[<span class=\"number\">2</span>], q[<span class=\"number\">3</span>])]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数据结构"],"tags":["主席树"]},{"title":"从零搭建自己的hexo博客（三）：加速与深度美化","url":"/2020/12/12/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%8A%A0%E9%80%9F%E4%B8%8E%E6%B7%B1%E5%BA%A6%E7%BE%8E%E5%8C%96/","content":"<h1 id=\"加速\"><a href=\"#加速\" class=\"headerlink\" title=\"加速\"></a>加速</h1><p>我们的博客不加速是不行的……</p>\n<span id=\"more\"></span>\n<h2 id=\"CDN加速\"><a href=\"#CDN加速\" class=\"headerlink\" title=\"CDN加速\"></a>CDN加速</h2><p>我们的博客加载字体会非常慢。这是因为在国内不能访问 <code>Google</code>，从<code>Google</code>加载就会慢得1p。</p>\n<p>在主题配置文件找到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Uri of fonts host. E.g. &#x2F;&#x2F;fonts.googleapis.com (Default)</span><br><span class=\"line\">host:</span><br></pre></td></tr></table></figure>\n<p>将 <code>host</code> 后面打个空格输入<code>//fonts.lug.ustc.edu.cn</code></p>\n<p>当然还有一堆效果不明显的<code>CDN</code>加速。效果不明显就不必要加了。当然如果你追求极致去加一下也没事，至少不会拖慢加载速度。</p>\n<h2 id=\"使用gulp压缩静态文件\"><a href=\"#使用gulp压缩静态文件\" class=\"headerlink\" title=\"使用gulp压缩静态文件\"></a>使用gulp压缩静态文件</h2><p>在博客根目录下执行<code>npm install gulp -g</code>。</p>\n<p>再依次执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install gulp --save</span><br><span class=\"line\">npm install gulp-minify-css --save</span><br><span class=\"line\">npm install gulp-uglify --save</span><br><span class=\"line\">npm install gulp-htmlmin --save</span><br><span class=\"line\">npm install gulp-htmlclean --save</span><br><span class=\"line\">npm install gulp-imagemin --save</span><br></pre></td></tr></table></figure>\n<p>在站点根目录下添加<code>gulpfile.js</code>文件。内容如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> minifycss = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-minify-css&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> uglify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-uglify&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> htmlmin = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-htmlmin&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> htmlclean = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-htmlclean&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> imagemin = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-imagemin&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;minify-html&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;./public/**/*.html&#x27;</span>)</span><br><span class=\"line\">        .pipe(htmlclean())</span><br><span class=\"line\">        .pipe(htmlmin(&#123;</span><br><span class=\"line\">            removeComments: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            minifyJS: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            minifyCSS: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            minifyURLs: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">&#x27;./public&#x27;</span>))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;minify-css&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;./public/**/*.css&#x27;</span>)</span><br><span class=\"line\">        .pipe(minifycss(&#123;</span><br><span class=\"line\">            compatibility: <span class=\"string\">&#x27;ie8&#x27;</span></span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">&#x27;./public&#x27;</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;minify-js&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;./public/js/**/*.js&#x27;</span>)</span><br><span class=\"line\">        .pipe(uglify())</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">&#x27;./public&#x27;</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;minify-images&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;./public/images/**/*.*&#x27;</span>)</span><br><span class=\"line\">        .pipe(imagemin(</span><br><span class=\"line\">        [imagemin.gifsicle(&#123;<span class=\"string\">&#x27;optimizationLevel&#x27;</span>: <span class=\"number\">3</span>&#125;),</span><br><span class=\"line\">        imagemin.mozjpeg(&#123;<span class=\"string\">&#x27;progressive&#x27;</span>: <span class=\"literal\">true</span>&#125;),</span><br><span class=\"line\">        imagemin.optipng(&#123;<span class=\"string\">&#x27;optimizationLevel&#x27;</span>: <span class=\"number\">7</span>&#125;),</span><br><span class=\"line\">        imagemin.svgo()],</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;verbose&#x27;</span>: <span class=\"literal\">true</span>&#125;))</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">&#x27;./public/images&#x27;</span>))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;default&#x27;</span>,gulp.series(gulp.parallel(<span class=\"string\">&#x27;minify-html&#x27;</span>,<span class=\"string\">&#x27;minify-css&#x27;</span>,<span class=\"string\">&#x27;minify-js&#x27;</span>,<span class=\"string\">&#x27;minify-images&#x27;</span>)));</span><br></pre></td></tr></table></figure>\n<p>每次<code>hexo g</code>后执行命令<code>gulp</code>即可。它能有效压缩静态文件加快博客加载速度。</p>\n<p><code>neat</code>是<code>hexo</code>自带的插件。由于是”量身定制”的，它压缩后的文件的大小要小一点（<del>其实小不到哪儿去，差不多</del>），并且不需要输入额外命令，只需要按照原来的<code>hexo</code>三连即可。但是它不支持压缩有 $\\LaTeX$的文章……</p>\n<h2 id=\"使用Hexo自带插件加速\"><a href=\"#使用Hexo自带插件加速\" class=\"headerlink\" title=\"使用Hexo自带插件加速\"></a>使用Hexo自带插件加速</h2><p>在站点根目录下<code>npm install hexo-service-worker hexo-filter-optimize --save</code>。</p>\n<p>在站点配置文件末尾添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># offline config passed to sw-precache.</span><br><span class=\"line\">service_worker:</span><br><span class=\"line\">  maximumFileSizeToCacheInBytes: 5242880</span><br><span class=\"line\">  staticFileGlobs:</span><br><span class=\"line\">  - public&#x2F;**&#x2F;*.&#123;js,html,css,png,jpg,gif,svg,eot,ttf,woff,woff2&#125;</span><br><span class=\"line\">  stripPrefix: public</span><br><span class=\"line\">  verbose: true</span><br><span class=\"line\"></span><br><span class=\"line\">filter_optimize:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  # remove static resource query string</span><br><span class=\"line\">  #   - like &#96;?v&#x3D;1.0.0&#96;</span><br><span class=\"line\">  remove_query_string: true</span><br><span class=\"line\">  # remove the surrounding comments in each of the bundled files</span><br><span class=\"line\">  remove_comments: true</span><br><span class=\"line\">  css:</span><br><span class=\"line\">    enable: true</span><br><span class=\"line\">    # bundle loaded css file into the one</span><br><span class=\"line\">    bundle: true</span><br><span class=\"line\">    # use a script block to load css elements dynamically</span><br><span class=\"line\">    delivery: true</span><br><span class=\"line\">    # make specific css content inline into the html page</span><br><span class=\"line\">    #   - only support the full path</span><br><span class=\"line\">    #   - default is [&#39;css&#x2F;main.css&#39;]</span><br><span class=\"line\">    inlines:</span><br><span class=\"line\">    excludes:</span><br><span class=\"line\">  js:</span><br><span class=\"line\">    # bundle loaded js file into the one</span><br><span class=\"line\">    bundle: true</span><br><span class=\"line\">    excludes:</span><br><span class=\"line\">  # set the priority of this plugin,</span><br><span class=\"line\">  # lower means it will be executed first, default is 10</span><br><span class=\"line\">  priority: 12</span><br></pre></td></tr></table></figure>\n<p>它能显著提高网站速度。</p>\n<h2 id=\"fastclick\"><a href=\"#fastclick\" class=\"headerlink\" title=\"fastclick\"></a>fastclick</h2><p>在主题配置文件找到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Added switch option for separated repo in 6.0.0.</span><br><span class=\"line\"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-fastclick</span><br><span class=\"line\">fastclick: false</span><br></pre></td></tr></table></figure>\n<p>将<code>fastclick</code>改为<code>true</code>即可。</p>\n<h2 id=\"InstantClick\"><a href=\"#InstantClick\" class=\"headerlink\" title=\"InstantClick\"></a>InstantClick</h2><p>这个纯属黑科技。加了会让你的网站速度有质的飞跃。</p>\n<p>网上很多资料不再赘述。但是这个插件<strong>是有副作用的</strong>：</p>\n<ul>\n<li><p>与 FancyBox、Google Analytics 等等不兼容。还有很多与它不兼容的东西。</p>\n</li>\n<li><p>如果你大费周折搞定了上述问题<del>反正我是没搞定</del>那么恭喜你。但是注意，它的原理是当鼠标悬停在链接上时预加载。显而易见这样会带给服务器很多额外负担。极端情况下，用户的鼠标在一堆链接上滑来滑去就很那啥。当然可以通过一些设置来减缓这个问题。</p>\n</li>\n</ul>\n<p>如果你成功加上了真的加了这个插件，你的网站速度会相当惊人。但是对于一般的，对速度要求不严苛的用户上述两个优化就足够了。</p>\n<h1 id=\"深度美化\"><a href=\"#深度美化\" class=\"headerlink\" title=\"深度美化\"></a>深度美化</h1><p>继续咕咕咕……</p>\n","categories":["业余开发"],"tags":["搭建博客"]},{"title":"洛谷P2633 Count on a tree","url":"/2020/12/10/%E6%B4%9B%E8%B0%B7P2633-Count-on-a-tree/","content":"<p><a href=\"https://www.luogu.com.cn/problem/P2633\">传送门</a></p>\n<p>刚学会主席树，胡乱找了一些主席树的题，<del>结果差不多都是板，我还调了很久</del>。</p>\n<span id=\"more\"></span>\n<p>题目很人性不翻译了。</p>\n<p>强制在线毁我终生，导致我WA0-&gt;RE0<del>反正都是爆零。</del></p>\n<p>主席树是满足前缀和性质的数据结构，这个在敲板子的时候都知道。对于这道题，我们可以设 $s_u$ 表示点 $u$ 到根节点的路径上的一颗线段树，维护这条路径上的各个大小所有数字出现的出现的次数（肯定要离散化的，不多说）。</p>\n<p>那么求 $u,v$ 两点的第 $k$ 小，对应的线段树是：$s_u+s_v-s_{lca(u,v)}-s_{fa(lca(u,v))}$。</p>\n<p><del>好像挺简单啊。</del></p>\n<p>然而我调了一个下午+晚上。原因是惯性地把某个点减了一（就是求 $k$ 小的板子，打惯了）。</p>\n<p><del>内心：你tmd怎么这么菜啊，一道板子调一天。</del></p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code:$\"></a>$Code:$</h1><p>```cpp</p>\n<h1 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include \"></a>include <cstdio></h1><h1 id=\"include-1\"><a href=\"#include-1\" class=\"headerlink\" title=\"include \"></a>include <vector></h1><h1 id=\"include-2\"><a href=\"#include-2\" class=\"headerlink\" title=\"include \"></a>include <cmath></h1><h1 id=\"include-3\"><a href=\"#include-3\" class=\"headerlink\" title=\"include \"></a>include <algorithm></h1><p>const int N = 1e5 + 5;<br>std::vector<int> sons[N];<br>int A[N], Fa[N][18], Dep[N], Key[N], num[N], n, tot;</p>\n<p>struct node {<br>int idx, v, rnk;<br>inline bool operator &lt; (const node X) {return v &lt; X.v;}<br>} B[N];</p>\n<p>struct kachang {<br>inline bool operator () (const node X, const node Y) const {return X.idx &lt; Y.idx;}<br>};</p>\n<p>inline int LCA(int u, int v) {<br>if (Dep[u] &lt; Dep[v]) u ^= v ^= u ^= v;<br>int S(ceil(log2(Dep[u] - Dep[v])));<br>for (int i(0); i &lt;= S; ++ i) if (Dep[u] - Dep[v] &amp; 1 &lt;&lt; i) u = Fa[u][i];<br>if (u == v) return u;<br>for (int i(ceil(log2(Dep[u]))); ~i; — i)<br>if (Fa[u][i] != Fa[v][i]) u = Fa[u][i], v = Fa[v][i];<br>return Fa[u][0];<br>}</p>\n<p>struct Chairman_tree {<br>int cnt[N &lt;&lt; 5], ls[N &lt;&lt; 5], rs[N &lt;&lt; 5], root[N], x, tot;<br>inline void Update(int k, int _x, int pre) {<br>x = _x, update(root[k] = ++ tot, 1, n, root[pre]);<br>}<br>inline int Query(int u, int v, int k) {<br>int lca(LCA(u, v));<br>u = num[u], v = num[v];<br>if (u &gt; v) u ^= v ^= u ^= v;<br>return query(root[u], root[v], root[num[lca]], root[num[Fa[lca][0]]], 1, n, k);<br>}<br>inline void build() {make_tree(root[0] = tot = 1, 1, n);}<br>void make_tree(int p, int l, int r) {<br>if (l == r) return;<br>int mid(l + r &gt;&gt; 1);<br>make_tree(ls[p] = ++ tot, l, mid), make_tree(rs[p] = ++ tot, mid + 1, r);<br>}</p>\n<p>void update(int u, int l, int r, int root) {<br>if (l == r) {cnt[u] = cnt[root] + 1; return;}<br>int mid(l + r &gt;&gt; 1);<br>if (mid &gt;= x) update(ls[u] = ++ tot, l, mid, ls[root]), rs[u] = rs[root];<br>else update(rs[u] = ++ tot, mid + 1, r, rs[root]), ls[u] = ls[root];<br>cnt[u] = cnt[ls[u]] + cnt[rs[u]];<br>}</p>\n<p>int query(int u, int v, int lca, int falca, int l, int r, int d) {<br>if (l == r) return l;<br>int x(cnt[ls[u]] + cnt[ls[v]] - cnt[ls[lca]] - cnt[ls[falca]]), mid(l + r &gt;&gt; 1);<br>return d &lt;= x ? query(ls[u], ls[v], ls[lca], ls[falca], l, mid, d) :<br>query(rs[u], rs[v], rs[lca], rs[falca], mid + 1, r, d - x);<br>}<br>} Tree;</p>\n<p>void dfs(int u) {<br>Tree.Update(num[u] = ++ tot, B[u].rnk, num[Fa[u][0]]);<br>int S(ceil(log2(Dep[u] = Dep[Fa[u][0]] + 1)));<br>for (int i(1); i &lt;= S; ++ i) Fa[u][i] = Fa[Fa[u][i - 1]][i - 1];<br>for (int i : sons[u]) if (i != Fa[u][0]) Fa[i][0] = u, dfs(i);<br>}</p>\n<p>int main() {<br>int m, last(0);<br>scanf(“%d%d”, &amp;n, &amp;m);<br>Tree.build();<br>for (int i(1); i &lt;= n; ++ i) scanf(“%d”, A + i), B[i].v = A[i], B[i].idx = i;<br>std::sort(B + 1, B + n + 1);<br>Key[B[1].rnk = 1] = B[1].v;<br>for (int i(2); i &lt;= n; ++ i)<br>Key[B[i].rnk = (B[i - 1].v == B[i].v ? B[i - 1].rnk : B[i - 1].rnk + 1)] = B[i].v;<br>std::sort(B + 1, B + n + 1, kachang());<br>for (int i(1); i &lt; n; ++ i) {<br>int u, v;<br>scanf(“%d%d”, &amp;u, &amp;v);<br>sons[u].push_back(v), sons[v].push_back(u);<br>}<br>dfs(1);<br>while (m —) {<br>int u, v, k;<br>scanf(“%d%d%d”, &amp;u, &amp;v, &amp;k);<br>printf(“%d\\n”, last = Key[Tree.Query(u ^ last, v, k)]);<br>}<br>}</p>\n","categories":["数据结构"],"tags":["主席树"]},{"title":"主席树学习笔记","url":"/2020/12/07/%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"一些废话\"><a href=\"#一些废话\" class=\"headerlink\" title=\"一些废话\"></a>一些废话</h1><p>今天下午老板让我这个刚学线段树一个月的菜鸡去学主席树，还自学。</p>\n<span id=\"more\"></span>\n<p><del>我：认真的吗？</del></p>\n<h1 id=\"主席树定义\"><a href=\"#主席树定义\" class=\"headerlink\" title=\"主席树定义\"></a>主席树定义</h1><p>主席树是什么？</p>\n<p>主席树，又称可持久化线段树。简单地说，就是在线段树每次update后，保留之前的版本。也就是说，保存若干次修改前的线段树。”保 留之前的版本”大概就是可持久化的意思（<del>吧？</del>）。这个有点像平时编辑器的撤销功能。</p>\n<p>可持久化数据结构都是通过<strong>复用</strong>一些节点来节省空间。显然每次修改重新开一颗线段树超时炸空间。所以主席树尽量地使用原来的节点，必要的时候再创建节点。</p>\n<p><del>对于一个普通的智商不至于外星人的OIer来说以上大概没有一句听懂了吧</del>（或许是我太弱？</p>\n<h1 id=\"主席树的思想\"><a href=\"#主席树的思想\" class=\"headerlink\" title=\"主席树的思想\"></a>主席树的思想</h1><p><a href=\"https://www.luogu.com.cn/problem/P3834\">模板</a></p>\n<p>之前在学校OJ上用分块水过去的。</p>\n<p><strong>数据已经过加强，请使用主席树。同时请注意常数优化。</strong></p>\n<p><del>然而时限特别宽，一点都不卡常。</del></p>\n<p>主席树具体怎么时限，<del>结合全网通用的张图：</del></p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/z53caos2.png\" alt=\"\"></p>\n<p>主席树和传统的线段树至少形态上有很大的不同。可以看到，很多节点共用了一个儿子。这就是”复用节点”在主席树中的实现。</p>\n<p>每次插入节点，最多有 $logn$（$n$ 是区间长度）个节点被修改。</p>\n<p>比如说，我们先建好一颗 $1\\sim 7$ 区间的一颗空树。在主席树的每一个版本的线段树上，我们记录值在当前这个范围的数字有多少。</p>\n<p>比如插入数字 $1$，树变成了这样：</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/ouyz42n3.png\" alt=\"\"></p>\n<p>但显然，不能每次插入都重新搞一颗树。这颗树和原来的空树，也就是上一个版本，有很多节点相同。</p>\n<p>这些节点，就没必要重新创建。只需要重新创建 [$1$,$7$],[$1$,$4$],[$1$,$2$],[$1$,$1$]这四个点即可。</p>\n<p>树应该是这样：（好丑啊，<del>简直灵魂画师</del>):</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201207211252218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p2cnVvX3NoYWJp,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<p><del>好了你已经了解了主席树的基本原理，让我们一起A了这道紫题板子吧。</del></p>\n<p>简单的说就是，记录一个数组 $root[i]$，表示每个版本下主席树的根。每次修改创建一个新的根，将它在上一个版本的树中对应的位置（也就是表示区间和它相同的节点）$u$ 记录下来，如果要修改的点在左边，创建新的左儿子，递归左边，右儿子就是 $u$ 的右儿子。 反之递归右边，左儿子就是 $u$ 的左儿子。$sum[u]$ 表示节点 $u$ 的权值。</p>\n<p>查询就很简单了，假设查询 $u\\sim v$ 间的第 $k$ 小，那么主席树每个节点就是 $sum_u-sum_v$，在权值线段树上类似于二分查找这样搞一搞应该都会吧（</p>\n<p><del>另外数这么大不离散化对得起良心吗</del></p>\n<p><del>下面是你们最期待的东西。</del></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GetL(p) (ls[p] ? ls[p] : ls[p] = ++ nodetot)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GetR(p) (rs[p] ? rs[p] : rs[p] = ++ nodetot)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, a[N], b[N], Num[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Chairman_tree</span> &#123;</span><span class=\"comment\">//主 席 树</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> sum[N &lt;&lt; <span class=\"number\">5</span>], root[N], ls[N &lt;&lt; <span class=\"number\">5</span>], rs[N &lt;&lt; <span class=\"number\">5</span>], nodetot, x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">x = p, <span class=\"built_in\">update</span>(root[k] = ++ nodetot, <span class=\"number\">1</span>, n, root[k - <span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">Query</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(root[r], root[l - <span class=\"number\">1</span>], <span class=\"number\">1</span>, n, k);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make_tree</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (x == y) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"><span class=\"built_in\">make_tree</span>(ls[p] = <span class=\"built_in\">GetL</span>(p), x, x + y &gt;&gt; <span class=\"number\">1</span>),</span><br><span class=\"line\"><span class=\"built_in\">make_tree</span>(rs[p] = <span class=\"built_in\">GetR</span>(p), (x + y &gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> root)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (l == r) &#123;sum[p] = sum[root] + <span class=\"number\">1</span>; <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(l + r &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mid &gt;= x) <span class=\"built_in\">update</span>(ls[p] = <span class=\"built_in\">GetL</span>(p), l, mid, ls[root]), rs[p] = rs[root];</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(rs[p] = <span class=\"built_in\">GetR</span>(p), mid + <span class=\"number\">1</span>, r, rs[root]), ls[p] = ls[root];</span><br><span class=\"line\">sum[p] = sum[ls[p]] + sum[rs[p]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">int mid(l + r &gt;&gt; 1), x(sum[ls[u]] - sum[ls[v]]);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (d &lt;= x) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(ls[u], ls[v], l, mid, d);</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(rs[u], rs[v], mid + <span class=\"number\">1</span>, r, d - x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125; Tree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> m;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">Tree.<span class=\"built_in\">make_tree</span>(Tree.root[<span class=\"number\">0</span>] = Tree.nodetot = <span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, a + i), b[i] = a[i];</span><br><span class=\"line\">std::<span class=\"built_in\">sort</span>(b + <span class=\"number\">1</span>, b + n + <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i)</span><br><span class=\"line\">Tree.<span class=\"built_in\">Update</span>(i, std::<span class=\"built_in\">lower_bound</span>(b + <span class=\"number\">1</span>, b + n + <span class=\"number\">1</span>, a[i]) - b);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (~-- m) &#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> l, r, k;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, b[Tree.<span class=\"built_in\">Query</span>(l, r, k)]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数据结构"],"tags":["主席树","可持久化"]},{"title":"从零搭建自己的Hexo博客（二）：写文章与基础美化","url":"/2020/12/05/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%99%E6%96%87%E7%AB%A0%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%BE%8E%E5%8C%96/","content":"<h1 id=\"一、写文章\"><a href=\"#一、写文章\" class=\"headerlink\" title=\"一、写文章\"></a>一、写文章</h1><h2 id=\"新建文章\"><a href=\"#新建文章\" class=\"headerlink\" title=\"新建文章\"></a>新建文章</h2><p>博客搭建是干什么的？写文章的啊！</p>\n<p>好吧hexo写博客可以用一堆命令然后本地写，我不说这种方法，另一种我认为更好的方法：</p>\n<span id=\"more\"></span>\n<p>在你的站点根目录下打开PowerShell输入<code>npm install --save hexo-admin</code>安装<code>admin</code>插件</p>\n<p>再使用<code>hexo s</code>在本地运行，访问<code>localhost:4000/admin</code>即可。点击左上角的<code>new post</code>输入标题即可写文章（标题长度有限制，太长会引起回车后无法弹出写文章的界面）</p>\n<p>这个插件右边的预览栏支持Markdown语法，但是不支持 $\\LaTeX$，要在博客里才能看到经过 $\\LaTeX$ 渲染后的文章。</p>\n<p>在左边的侧边栏可以看到自己博客的所有文章，还可以对其编辑。</p>\n<p>不管使用这个插件还是直接编辑，都只能在本地写文章。</p>\n<p>先写一篇文章，用于试验后面的功能吧。</p>\n<h2 id=\"文章部分截取\"><a href=\"#文章部分截取\" class=\"headerlink\" title=\"文章部分截取\"></a>文章部分截取</h2><p>我们发现，博客的主页显示了文章的全部。在文章增多的时候，会导致主页加载慢得离谱而且特别难看。</p>\n<p>怎么办呢？将<code>my_blog\\source\\_posts</code>中自己的文章的<code>md</code>文件打开，在需要截断的位置添加<code>&lt;!--more--&gt;</code>即可。主页会只显示<code>more</code>前面的内容。</p>\n<h1 id=\"二、基础美化\"><a href=\"#二、基础美化\" class=\"headerlink\" title=\"二、基础美化\"></a>二、基础美化</h1><p><del>不觉得自己的博客就这样太简陋了吗。</del></p>\n<p>打开<strong>主题配置文件</strong>。这里提一下<strong>配置文件</strong>和<strong>主题配置文件</strong>。配置文件是站点根目录下的<code>_config.yml</code>，主题配置文件则是<code>站点根目录/themes/主题名（我们使用next)/_config.yml</code>。</p>\n<p>Ctrl+F，搜索文件中的<code>menu</code>字段，找到如下的一段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: &#x2F; || home</span><br><span class=\"line\">  #about: &#x2F;about&#x2F; || user</span><br><span class=\"line\">  #tags: &#x2F;tags&#x2F; || tags</span><br><span class=\"line\">  #categories: &#x2F;categories&#x2F; || th</span><br><span class=\"line\">  archives: &#x2F;archives&#x2F; || archive</span><br><span class=\"line\">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class=\"line\">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class=\"line\">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure>\n<p>可以看到我们的博客默认只显示<code>home</code>和<code>archives</code>两个链接。我们将<code>about</code>，<code>tags</code>和<code>categories</code>前的<code>#</code>去掉。接下来我会分别配置<code>about</code>界面和<code>tags</code>，<code>categories</code>。</p>\n<p>这时访问你的博客主页就会多出<code>about</code>、<code>tags</code>、<code>categories</code>链接，</p>\n<h2 id=\"about界面：\"><a href=\"#about界面：\" class=\"headerlink\" title=\"about界面：\"></a>about界面：</h2><p>在站点根目录下PowerShell运行<code>hexo new page &quot;about&quot;</code>。</p>\n<p><code>根目录（我是my_blog）/source/</code>下多了<code>about</code>文件夹。</p>\n<p>将<code>about/index.md</code>改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 关于我</span><br><span class=\"line\">date: 2020-11-29 17:43:54</span><br><span class=\"line\">---</span><br><span class=\"line\"></span><br><span class=\"line\">你的自我介绍……</span><br></pre></td></tr></table></figure>\n<p><code>date</code>可以更改。这时点击主页的<code>about</code>就有你的个人介绍！</p>\n<h2 id=\"tags界面：\"><a href=\"#tags界面：\" class=\"headerlink\" title=\"tags界面：\"></a>tags界面：</h2><h3 id=\"配置tags界面\"><a href=\"#配置tags界面\" class=\"headerlink\" title=\"配置tags界面\"></a>配置tags界面</h3><p>在站点根目录下PowerShell运行<code>hexo new page &quot;tags&quot;</code>。</p>\n<p><code>根目录（我是my_blog）/source/</code>下多了<code>tags</code>文件夹。</p>\n<p>将<code>tags/index.md</code>改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: &quot;文章标签&quot;</span><br><span class=\"line\">date: 2020-03-07 16:35:25</span><br><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">layout: &quot;tags&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p><code>date</code>可以更改。这时点击主页的<code>tags</code>就有你的标签页面！</p>\n<h3 id=\"添加文章标签：\"><a href=\"#添加文章标签：\" class=\"headerlink\" title=\"添加文章标签：\"></a>添加文章标签：</h3><p><code>my_blog/source/_posts</code>。</p>\n<p>会看到你的所有文章的<code>.md</code>文件。</p>\n<p>选出你的一篇文章：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">title: 你的文章标题</span><br><span class=\"line\">author: 你的名字或首字母缩写或昵称</span><br><span class=\"line\">date: 2020-12-01 20:24:25</span><br><span class=\"line\">tags:</span><br><span class=\"line\">    - 标签1</span><br><span class=\"line\">    - 标签2</span><br><span class=\"line\">---</span><br><span class=\"line\">正文……</span><br></pre></td></tr></table></figure>\n<p>可以仿照上面的代码为文章加标签。</p>\n<h2 id=\"categories界面：\"><a href=\"#categories界面：\" class=\"headerlink\" title=\"categories界面：\"></a>categories界面：</h2><h3 id=\"配置categories界面\"><a href=\"#配置categories界面\" class=\"headerlink\" title=\"配置categories界面\"></a>配置categories界面</h3><p>在站点根目录下PowerShell运行<code>hexo new page &quot;categories&quot;</code>。</p>\n<p><code>my_blog/source/</code>下多了<code>categories</code>文件夹。</p>\n<p>将<code>categories/index.md</code>改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: &quot;文章分类&quot;</span><br><span class=\"line\">date: 2020-03-07 16:35:25</span><br><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">layout: &quot;tags&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p><code>date</code>可以更改。这时点击主页的<code>categories</code>就有你的标签页面！</p>\n<h3 id=\"添加文章标签：-1\"><a href=\"#添加文章标签：-1\" class=\"headerlink\" title=\"添加文章标签：\"></a>添加文章标签：</h3><p><code>my_blog/source/_posts</code>。</p>\n<p>会看到你的所有文章的<code>.md</code>文件。</p>\n<p>选出你的一篇文章：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">title: 你的文章标题</span><br><span class=\"line\">author: 你的名字或首字母缩写或昵称</span><br><span class=\"line\">date: 2020-12-01 20:24:25</span><br><span class=\"line\">tags:</span><br><span class=\"line\">    - 标签1</span><br><span class=\"line\">    - 标签2</span><br><span class=\"line\">categories:</span><br><span class=\"line\">   - 一级分类</span><br><span class=\"line\">   - 二级分类</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">正文……</span><br></pre></td></tr></table></figure>\n<p>可以仿照上面的代码为文章加分类。</p>\n<p>分类级数越高分的越细。</p>\n<h2 id=\"博客主题样式：\"><a href=\"#博客主题样式：\" class=\"headerlink\" title=\"博客主题样式：\"></a>博客主题样式：</h2><p>next主题默认的样式是Muse。</p>\n<p>在主题配置文件中Ctrl+F搜索”Schemes”，找到如下字段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Schemes</span><br><span class=\"line\">scheme: Muse</span><br><span class=\"line\">#scheme: Mist</span><br><span class=\"line\">#scheme: Pisces</span><br><span class=\"line\">#scheme: Gemini</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我的blog使用的是Gemini样式，只需要改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Schemes</span><br><span class=\"line\">#scheme: Muse</span><br><span class=\"line\">#scheme: Mist</span><br><span class=\"line\">#scheme: Pisces</span><br><span class=\"line\">scheme: Gemini</span><br></pre></td></tr></table></figure>\n<p>即可。其它两个样式可以自行尝试。</p>\n<h2 id=\"代码块样式：\"><a href=\"#代码块样式：\" class=\"headerlink\" title=\"代码块样式：\"></a>代码块样式：</h2><p>在主题配置文件中搜索”highlight_theme”。</p>\n<p>找到如下字段：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Code Highlight theme</span><br><span class=\"line\"># Available values: normal | night | night eighties | night blue | night bright</span><br><span class=\"line\"><span class=\"meta\"># https:<span class=\"comment\">//github.com/chriskempson/tomorrow-theme</span></span></span><br><span class=\"line\">highlight_theme: normal</span><br></pre></td></tr></table></figure>\n<p>可以看到，NexT为我们提供了几种代码块颜色。我使用的是<code>night bright</code>，只需要将默认的<code>normal</code>改为<code>night bright</code>即可。</p>\n<p>另外，如果想给代码添加Copy按钮，在主题配置文件中搜索<code>copy_button</code>，找到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">copy_button:</span><br><span class=\"line\">    enable: false</span><br><span class=\"line\">    # Show text copy result</span><br><span class=\"line\">    show_result: false</span><br></pre></td></tr></table></figure>\n<p>将<code>enable</code>后面的<code>false</code>改为<code>true</code>即可。</p>\n<h2 id=\"搜索功能：\"><a href=\"#搜索功能：\" class=\"headerlink\" title=\"搜索功能：\"></a>搜索功能：</h2><p>在站点根目录打开PowerShell输入<code>npm install hexo-generator-searchdb --save</code>。</p>\n<p>进入站点配置文件在末尾添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">  path: search.json #网上很多教程这里写的是search.xml，会导致无法搜索，那是老掉牙的版本的写法了。</span><br><span class=\"line\">  field: post</span><br><span class=\"line\">  format: html</span><br><span class=\"line\">  limit: 1000</span><br></pre></td></tr></table></figure>\n<p>在主题配置文件找到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Local Search</span><br><span class=\"line\"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-generator-searchdb</span><br><span class=\"line\">local_search:</span><br><span class=\"line\">  enable: false</span><br><span class=\"line\">  # If auto, trigger search by changing input.</span><br><span class=\"line\">  # If manual, trigger search by pressing enter key or search button.</span><br><span class=\"line\">  trigger: auto</span><br><span class=\"line\">  # Show top n results per article, show all results by setting to -1</span><br><span class=\"line\">  top_n_per_article: 1</span><br><span class=\"line\">  # Unescape html strings to the readable one.</span><br><span class=\"line\">  unescape: false</span><br><span class=\"line\">  # Preload the search data when the page loads.</span><br><span class=\"line\">  preload: false</span><br></pre></td></tr></table></figure>\n<p>将<code>enable</code>的<code>false</code>改为<code>true</code>即可。完成了上面的美化后，你的博客应该相当顺眼了！</p>\n<p>当前，我们的博客不出意外会<strong>非常卡</strong>。下一篇文章我会对博客进行加速和深度美化。</p>\n","categories":["业余开发"],"tags":["搭建博客"]},{"title":"POI2014 & NKOJ 3777 卡牌操作","url":"/2020/12/04/POI2014-%E5%8D%A1%E7%89%8C%E6%93%8D%E4%BD%9C/","content":"<h4 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h4><p>有 $n$ 张卡片在桌上一字排开，每张卡片上有两个数，第i张卡片上，正面的数为 $a_i$，反面的数为 $b_i$。现在，有 $m$ 个熊孩子 来破坏你的卡片了！<br><span id=\"more\"></span><br>第i个熊孩子会交换 $c_i$ 和 $d_i$ 两个位置上的卡片。<br>每个熊孩子捣乱后，你都需要判断，通过任意翻转卡片（把正面变为反面或把反面变成正面，但不能改变卡片的位置），能否让卡片正面上的数从左到右单调不降。</p>\n<h4 id=\"Input-Format\"><a href=\"#Input-Format\" class=\"headerlink\" title=\"Input Format\"></a>Input Format</h4><p>第一行一个 $n$。<br>接下来 $n$ 行，每行两个数 $a_i,b_i$。<br>接下来一行一个 $m$。<br>接下来 $m$ 行，每行两个数 $c_i,d_i$。</p>\n<h4 id=\"Output-Format\"><a href=\"#Output-Format\" class=\"headerlink\" title=\"Output Format\"></a>Output Format</h4><p>$m$ 行，每行对应一个答案。如果能成功，输出TAK，否则输出NIE。</p>\n<h4 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">2 5</span><br><span class=\"line\">3 4</span><br><span class=\"line\">6 3</span><br><span class=\"line\">2 7</span><br><span class=\"line\">2</span><br><span class=\"line\">3 4</span><br><span class=\"line\">1 3</span><br></pre></td></tr></table></figure>\n<h4 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">NIE</span><br><span class=\"line\">TAK</span><br></pre></td></tr></table></figure>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>线段树区间合并题。看见题目有一个显而易见的贪心策略：为了以后更好的发展，当前选择的卡牌总是尽可能让它小的一面朝上，实在不行在大的一面朝上。大的一面都不行无解凉凉。</p>\n<p><del>不过这题能用线段树做是真的挺神仙。</del></p>\n<p>线段树记录下该区间内，第一张卡片选择小的一面和大的一面最后一张卡片能取得的最小值。若无法让整个序列单调不减为 $\\infty$。 线段树不需要支持查询操作，挺好写。不过这道题质量真的挺高。</p>\n<p>每个区间很容易由它的两个子区间合并而来，详见代码。</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code:$\"></a>$Code:$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> inf 0x3fffffff</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> gc (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 131072, stdin), p1 == p2) ? EOF : *p1 ++)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">131072</span>], *p1, *p2;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">char</span> ch;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">x</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ((ch = gc) &lt; <span class=\"number\">48</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (ch &gt;= <span class=\"number\">48</span>) x = x * <span class=\"number\">10</span> + ch - <span class=\"number\">48</span>, ch = gc;</span><br><span class=\"line\"><span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Pair</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125; card[<span class=\"number\">200005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Segment_tree</span> &#123;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> l, r, v1, v2;</span><br><span class=\"line\">&#125; a[<span class=\"number\">800005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Solve</span><span class=\"params\">(<span class=\"keyword\">int</span> O)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(a[O &lt;&lt; <span class=\"number\">1</span>].r + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a[O &lt;&lt; <span class=\"number\">1</span>].v1 &lt;= card[mid].y) &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a[O &lt;&lt; <span class=\"number\">1</span>].v1 &lt;= card[mid].x) a[O].v1 = a[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v1;</span><br><span class=\"line\"><span class=\"keyword\">else</span> a[O].v1 = a[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v2;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a[O &lt;&lt; <span class=\"number\">1</span>].v2 &lt;= card[mid].y) &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a[O &lt;&lt; <span class=\"number\">1</span>].v2 &lt;= card[mid].x) a[O].v2 = a[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v1;</span><br><span class=\"line\"><span class=\"keyword\">else</span> a[O].v2 = a[O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].v2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> a[O].v2 = inf;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> a[O].v1 = a[O].v2 = inf;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make_tree</span><span class=\"params\">(<span class=\"keyword\">int</span> O, <span class=\"keyword\">int</span> L, <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">a[O].l = L, a[O].r = R;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mid</span><span class=\"params\">(L + R &gt;&gt; <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (L != R) <span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span>, L, mid), <span class=\"built_in\">make_tree</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, R), <span class=\"built_in\">Solve</span>(O);</span><br><span class=\"line\"><span class=\"keyword\">else</span> a[O].v1 = card[L].x, a[O].v2 = card[L].y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> O, <span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a[O].l == a[O].r) &#123;a[O].v1 = card[a[O].l].x, a[O].v2 = card[a[O].l].y; <span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a[O &lt;&lt; <span class=\"number\">1</span>].r &gt;= p) <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span>, p);</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(O &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, p);</span><br><span class=\"line\"><span class=\"built_in\">Solve</span>(O);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125; Tree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">int n(read()), m;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) &#123;</span><br><span class=\"line\">card[i].x = <span class=\"built_in\">read</span>(), card[i].y = <span class=\"built_in\">read</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (card[i].x &gt; card[i].y) std::<span class=\"built_in\">swap</span>(card[i].x, card[i].y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Tree.<span class=\"built_in\">make_tree</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">m = <span class=\"built_in\">read</span>();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (~-- m) &#123;</span><br><span class=\"line\">int c(read()), d(read());</span><br><span class=\"line\">std::<span class=\"built_in\">swap</span>(card[c], card[d]);</span><br><span class=\"line\">Tree.<span class=\"built_in\">update</span>(<span class=\"number\">1</span>, c), Tree.<span class=\"built_in\">update</span>(<span class=\"number\">1</span>, d);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (Tree.a[<span class=\"number\">1</span>].v1 &lt;= <span class=\"number\">1e9</span>) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;TAK&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;NIE&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数据结构"],"tags":["线段树"]},{"title":"洛谷P5021 【NOIP2018D1T3】赛道修建","url":"/2020/12/04/%E6%B4%9B%E8%B0%B7P5021-%E3%80%90NOIP2018D1T3%E3%80%91%E8%B5%9B%E9%81%93%E4%BF%AE%E5%BB%BA/","content":"<p><a href=\"https://www.luogu.com.cn/problem/P5021\">传送门</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给你一颗 $n$ 个点构成的树，要在这棵树上选择 $m$ 条互不相交的链，求这些链中长度最小的最大长度。<br><span id=\"more\"></span></p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><h3 id=\"算法主框架\"><a href=\"#算法主框架\" class=\"headerlink\" title=\"算法主框架\"></a>算法主框架</h3><p>看到这种类似要求”最小值最大”或者”最大值最小”，首先就应该想到二分这个最小值或最大值。</p>\n<p>对于本题，二分最短的赛道长度 $lim$。为了方便后文描述，$cnt$ 表示当前找到的满足限制的赛道条数。</p>\n<p>二分上界：$\\sum l_i\\div m$。</p>\n<h3 id=\"如何检查二分的值是否能够实现\"><a href=\"#如何检查二分的值是否能够实现\" class=\"headerlink\" title=\"如何检查二分的值是否能够实现\"></a>如何检查二分的值是否能够实现</h3><p>我们知道，一条赛道不可能同时经过一个节点的两颗以上的子树。对于一颗子树，我们先找到在这颗子树内的所有的长度大于等于 $lim$ 的赛道，再没被经过的其它边中找一条最长的链，把这条链的长度向上（它的父亲）传递。</p>\n<p>什么意思呢？拿样例一来说：</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/pic/43162.png\" alt=\"\"></p>\n<ul>\n<li><p>我们设 $7$ 为树的根，设当前二分的 $lim=19$，则 $4$ 没有任何儿子，向它的父亲 $2$ 上传递 $0$。$5$ 没有儿子，向 $2$ 传递 $0$。这个时候，$2$ 将这些传递的值加上对应的边权，这些值就变成了 $8,9$。</p>\n</li>\n<li><p>这个时候，肉眼观察发现 $8$，$9$ 都不满足条件，将这两个值加起来 $8+9=17&lt;19$ 也不满足条件。而我们只能向上传递一条最长的 链，于是向 $1$ 传递值 $9$。$1$ 将这个值加上边权 $10$，得到 $19$。</p>\n</li>\n<li><p>这个时候，我们发现 $19$ 满足条件。那么把这个向上传递的值删除，因为它满足了条件，我们即使把它向上传递，$cnt$ 最多也是加1，还不如就地用了直接报废，给上面多留一些边。那么此时 $1$ 没有可以传递的值了，向 $3$ 传递 $0$，加上边权变为 $5$。</p>\n</li>\n</ul>\n<ul>\n<li><p>然后这个时候 $3$ 除了 $1$ 这个儿子，又找到 $6$ 向它交代。$6$ 没有任何儿子，传递 $0$。加上边权 $6$ 就是 $6$。$3$ 最终有两个元素：$5$ 和 $6$。这两个元素加起来都不够 $19$，向 $7$ 传递 $6$，加上边权为 $13$。</p>\n</li>\n<li><p>7发现没有其它儿子，$12&lt;lim$，就地报废。最终，$cnt=1$，所以当 $lim=19$ 时，最多能修建 $1$ 条长度大于等于 $19$ 的赛道。</p>\n</li>\n</ul>\n<h4 id=\"总结一下：\"><a href=\"#总结一下：\" class=\"headerlink\" title=\"总结一下：\"></a>总结一下：</h4><ul>\n<li><p>从根节点出发向下dfs，让它的儿子向它传递值。</p>\n</li>\n<li><p>将它的儿子传递上来的值加上边权，从小到大排个序，从最小值开始扫，找到能和它配对（也就是与它的和大于等于 $lim$）的值时删除这两个元素，$cnt++$。很显然，这个过程用<code>multiset</code>比较合适。代码中为每个节点都分配了一个<code>multiset</code>。</p>\n</li>\n<li><p>在 <code>multiset</code> 中剩下的元素中找最大的，如果为空就往父节点传递0（代码为<code>return 0</code>，否则返回集合中最大的元素。）</p>\n</li>\n</ul>\n<p>这道题的分析就完了。解释一下代码：<code>dfs(u,f)</code>表示当前搜索到节点 $u$，父节点为 $fa$，让它向父节点传递值。</p>\n<p>注意：每次二分后<code>cnt</code>要重置为0，<strong>每个点的<code>multiset</code>都要清空！</strong>（我在这里卡了两个小时希望没把你吓到）。</p>\n<p>时间复杂度 $O(nlog(\\sum l_i\\div m)log n)$。</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code:$\"></a>$Code:$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> to, v, nxt;</span><br><span class=\"line\">&#125; e[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> head[<span class=\"number\">50005</span>], tot, lim, cnt;</span><br><span class=\"line\">std::multiset&lt;<span class=\"keyword\">int</span>&gt; sons[<span class=\"number\">50005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">AddEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span> </span>&#123;</span><br><span class=\"line\">e[++ tot].to = v, e[tot].nxt = head[u], head[u] = tot, e[tot].v = w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> fa)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\">std::multiset&lt;<span class=\"keyword\">int</span>&gt;&amp; <span class=\"title\">s</span><span class=\"params\">(sons[u])</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(head[u]); i; i = e[i].nxt)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (e[i].to != fa) &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">w</span><span class=\"params\">(dfs(e[i].to, u) + e[i].v)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (w &lt; lim) sons[u].<span class=\"built_in\">insert</span>(w);</span><br><span class=\"line\"><span class=\"keyword\">else</span> ++ cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (s.<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> <span class=\"built_in\">i</span>(s.<span class=\"built_in\">begin</span>()); i != s.<span class=\"built_in\">end</span>();) &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">it</span><span class=\"params\">(s.lower_bound(lim - *i))</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (i == it) ++ it;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (it != s.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">++ cnt, s.<span class=\"built_in\">erase</span>(i ++);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (i != it) s.<span class=\"built_in\">erase</span>(it);</span><br><span class=\"line\"><span class=\"keyword\">else</span> s.<span class=\"built_in\">erase</span>(i ++);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> ++ i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> s.<span class=\"built_in\">empty</span>() ? <span class=\"number\">0</span> : *(-- s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m, <span class=\"built_in\">l</span>(<span class=\"number\">1</span>), <span class=\"built_in\">r</span>(<span class=\"number\">0</span>), <span class=\"built_in\">ans</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt; n; ++ i) &#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> u, v, w;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class=\"line\"><span class=\"built_in\">AddEdge</span>(u, v, w), <span class=\"built_in\">AddEdge</span>(v, u, w), r += w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">r /= m;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">lim = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) sons[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">cnt = <span class=\"number\">0</span>, <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">cnt &gt;= m ? ans = lim, l = lim + <span class=\"number\">1</span> : r = lim - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["树上问题"],"tags":["平衡树","贪心","二分"]},{"title":"NKOJ 3761 送外卖","url":"/2020/12/02/NKOJ-3761-%E9%80%81%E5%A4%96%E5%8D%96/","content":"<blockquote>\n<p>改编自POI2007 atr</p>\n</blockquote>\n<p>好吧POI的题，NKOJ改编的……</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P3451\">某谷传颂门</a></p>\n<span id=\"more\"></span>\n<h1 id=\"这篇题解在你谷上过不去，只有95，NKOJ过了\"><a href=\"#这篇题解在你谷上过不去，只有95，NKOJ过了\" class=\"headerlink\" title=\"这篇题解在你谷上过不去，只有95，NKOJ过了\"></a>这篇题解在你谷上过不去，只有95，NKOJ过了</h1><p>这道题 $k\\le 20$，明示状压DP。</p>\n<p>设计状态：第一维显然就是表示当前经过了哪几个点（包括1），我们发现这样还不能确定一个完整的状态，于是第二维表示当前在哪个 点。</p>\n<p>状态：设 $dp[i][j]$ 表示停留了 $i$ 中的所有点，当前在 $j-1$ 个点（减一是为了给状压DP带来方便），需要走的最短距离。</p>\n<p>方程：$dp[i][j] = dp[i][j]+dp[t][k]+dis[k+1][j+1]$ （$j$ 是 $i$ 的一个二进制位，$t$ 是 $i$ 去掉第 $j$ 个点得到的集合，$k$ 是 $t$ 的一个二进制位，$dis[u][v]$ 表示 $u$，$v$ 两点间的距离。</p>\n<p>这个方程基本不用解释吧……</p>\n<p>然后用 $mp[u][v]$ 表示必须先停留在点 $u$ 再停留在点 $v$，找到入度为 $0$的点大法师就行了。将停留点 $i$ 前必须停留的点记为 $prep[i]$。</p>\n<p>$OK[S]=true$表示状态 $S$ 不合法，能起到一些玄学的优化作用（也许？</p>\n<h4 id=\"关于Dijkstra，它死了\"><a href=\"#关于Dijkstra，它死了\" class=\"headerlink\" title=\"关于Dijkstra，它死了\"></a>关于Dijkstra，它死了</h4><h3 id=\"关于SPFA，它诈尸了\"><a href=\"#关于SPFA，它诈尸了\" class=\"headerlink\" title=\"关于SPFA，它诈尸了\"></a>关于SPFA，它诈尸了</h3><p><del>然而是因为NKOJ开了O2速度不到你谷一半造成的，理论上Dijkstra能过。</del></p>\n<p>时间复杂度：$O(2^k\\cdot k^2+SPFA玄学\\cdot mk)$</p>\n<p><del>这复杂度劝你重新做个人</del></p>\n<p>注：这样在你谷会MLE爆零，用unordered_map代替就 $95pts$ 了。</p>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code:$\"></a>$Code:$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> gc (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 131072, stdin), p1 == p2) ? EOF : *p1 ++)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">131072</span>], *p1 = buf, *p2 = buf;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">char</span> ch;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">x</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ((ch = gc) &lt; <span class=\"number\">48</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (ch &gt;= <span class=\"number\">48</span>) x = x * <span class=\"number\">10</span> + ch - <span class=\"number\">48</span>, ch = gc;</span><br><span class=\"line\"><span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> to, v, nxt;</span><br><span class=\"line\">&#125; e[<span class=\"number\">200005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[<span class=\"number\">22</span>][<span class=\"number\">20001</span>], dp[<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">21</span>][<span class=\"number\">22</span>], head[<span class=\"number\">20001</span>], prep[<span class=\"number\">22</span>], tot, K, n, m, t;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[<span class=\"number\">22</span>][<span class=\"number\">20001</span>], flag[<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">21</span>][<span class=\"number\">22</span>], mp[<span class=\"number\">22</span>][<span class=\"number\">22</span>], In[<span class=\"number\">22</span>];</span><br><span class=\"line\">std::queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">AddEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span>  </span>&#123;</span><br><span class=\"line\">e[++ tot].to = v, e[tot].nxt = head[u], e[tot].v = w, head[u] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">SPFA</span><span class=\"params\">(<span class=\"keyword\">int</span> st)</span> </span>&#123;</span><br><span class=\"line\">q.<span class=\"built_in\">push</span>(st);</span><br><span class=\"line\"><span class=\"keyword\">int</span> *Dis = dis[st];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> *Vis = vis[st];</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(dis[st], <span class=\"number\">0x3f</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(dis[st]));</span><br><span class=\"line\">Dis[st] = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (q.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">u</span><span class=\"params\">(q.front())</span></span>;</span><br><span class=\"line\">q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">Vis[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(head[u]); i; i = e[i].nxt) &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">v</span><span class=\"params\">(e[i].to)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (Dis[u] + e[i].v &lt; Dis[v]) &#123;</span><br><span class=\"line\">Dis[v] = Dis[u] + e[i].v;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!Vis[v]) q.<span class=\"built_in\">push</span>(v), Vis[v] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> before)</span> </span>&#123;</span><br><span class=\"line\">prep[u] |= before;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">2</span>); i &lt;= K; ++ i)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mp[u][i]) <span class=\"built_in\">dfs</span>(i, before | <span class=\"number\">1</span> &lt;&lt; u - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">DP</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(dp, <span class=\"number\">0x3f</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(dp));</span><br><span class=\"line\">dp[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">2</span>); i &lt; <span class=\"number\">1</span> &lt;&lt; K; ++ i)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">0</span>); j &lt; K; ++ j) <span class=\"keyword\">if</span> (i &amp; <span class=\"number\">1</span> &lt;&lt; j) &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">t</span><span class=\"params\">(i ^ <span class=\"number\">1</span> &lt;&lt; j)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ((prep[j + <span class=\"number\">1</span>] | t) &gt; t) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">k</span>(<span class=\"number\">0</span>); k &lt; K; ++ k)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (t &amp; <span class=\"number\">1</span> &lt;&lt; k) dp[i][j] = <span class=\"built_in\">min</span>(dp[i][j], dp[t][k] + dis[k + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ans</span><span class=\"params\">(<span class=\"number\">0x3fffffff</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">j</span>(<span class=\"number\">0</span>); j &lt; K; ++ j) ans = <span class=\"built_in\">min</span>(ans, dp[(<span class=\"number\">1</span> &lt;&lt; K) - <span class=\"number\">1</span>][j] + dis[j + <span class=\"number\">1</span>][n]);</span><br><span class=\"line\"><span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">int n(read()), m(read());</span><br><span class=\"line\">K = <span class=\"built_in\">read</span>() + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (m --) &#123;</span><br><span class=\"line\">int u(read()), v(read()), w(read());</span><br><span class=\"line\"><span class=\"built_in\">AddEdge</span>(u, v, w), <span class=\"built_in\">AddEdge</span>(v, u, w);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">t</span><span class=\"params\">(read())</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (t --) &#123;</span><br><span class=\"line\">int u(read()), v(read());</span><br><span class=\"line\">mp[u][v] = <span class=\"number\">1</span>, In[v] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">2</span>); i &lt;= K; ++ i) <span class=\"built_in\">SPFA</span>(i);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">2</span>); i &lt;= K; ++ i)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!In[i]) <span class=\"built_in\">dfs</span>(i, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, <span class=\"built_in\">DP</span>());</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["动态规划"],"tags":["最短路","状压DP"]},{"title":"Grass Cownoisseur G","url":"/2020/12/01/Grass-Cownoisseur-G/","content":"<h1 id=\"Tarjan缩点-SPFA最长路\"><a href=\"#Tarjan缩点-SPFA最长路\" class=\"headerlink\" title=\"Tarjan缩点+SPFA最长路\"></a>Tarjan缩点+SPFA最长路</h1><p><a href=\"https://www.luogu.com.cn/problem/P3119\">传送门</a></p>\n<span id=\"more\"></span>\n<p>看到这题有一个显然的贪心策略：可以经过一个牧场多次，那么在一个强连通分量里的牧场只要经过了其中的一个牧场剩下的一定都会被贝西吃掉。</p>\n<p>所以先进行缩点。然后题目中说的可以逆向行走，我是这样处理的：</p>\n<ul>\n<li>先把图中的点分为两种：第一种是从点 $1$ 出发能够到达的，第二种是从该点出发能到点1的。</li>\n<li>不可能有一个点既是第一种又是第二种，毕竟缩点过后的图是一个DAG。</li>\n<li>我们记下从点 $1$ 出发到第一种点途中能经过最多的所有牧场总数，为 $QAQ[i]$，而从第二种点出发到点 $1$ 的点途中能经过的最 多的牧场总数记为 $QwQ[i]$。这里使用SPFA跑跑最长路即可。</li>\n<li><del>原谅我皮了一波。</del></li>\n<li>由于贝西要回到一号牧场，除了只吃第一个牧场所在的强连通分量所在的所有牧场之外，如果存在一个点 $u$ 是第二类点，$v$ 是第 一类点，且存在一条从 $u$ 到 $v$ 的有向边 $u\\rigitrow v$，只要将这一条边反过来（逆向行走）就可以吃到 $QwQ[u]+QAQ[v]$ 个牧场的草。</li>\n<li>枚举点 $u$，然后在 $u$ 能到达的所有点种枚举点 $v$。</li>\n</ul>\n<h1 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code:$\"></a>$Code:$</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100005</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXM 100005</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> gc (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 131072, stdin), p1 == p2) ? EOF : *p1 ++)</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">131072</span>], *p1 = buf, *p2 = buf;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">//不会吧不会吧不会都0202年了还没有人用快读吧（滑稽.jpg</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> ch;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">x</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ((ch = gc) &lt; <span class=\"number\">48</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (ch &gt;= <span class=\"number\">48</span>) x = x * <span class=\"number\">10</span> + ch - <span class=\"number\">48</span>, ch = gc;</span><br><span class=\"line\"><span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &lt; y ? x : y;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x &gt; y ? x : y;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Graph</span> &#123;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> to, nxt;</span><br><span class=\"line\">&#125; e[MAXM &lt;&lt; <span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> head[MAXN], tot;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">AddEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">e[++ tot].to = v, e[tot].nxt = head[u], head[u] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125; G1, G2, G3;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> low[MAXN], dfn[MAXN], cnt[MAXN], color[MAXN], QwQ[MAXN], QAQ[MAXN], vis[MAXN], scc, Num;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> InStack[MAXN], mark[MAXN], mark2[MAXN];<span class=\"comment\">//mark表示每个点是否是第一类点，mark2标记是否为第二类点</span></span><br><span class=\"line\">std::stack&lt;<span class=\"keyword\">int</span>&gt; S;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Tarjan</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">dfn[u] = low[u] = ++ Num, S.<span class=\"built_in\">push</span>(u), InStack[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(G1.head[u]); i; i = G1.e[i].nxt) &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">v</span><span class=\"params\">(G1.e[i].to)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!dfn[v]) <span class=\"built_in\">Tarjan</span>(v), low[u] = <span class=\"built_in\">min</span>(low[u], low[v]);</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (InStack[v]) low[u] = <span class=\"built_in\">min</span>(low[u], dfn[v]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (dfn[u] == low[u]) &#123;</span><br><span class=\"line\">++ scc;</span><br><span class=\"line\"><span class=\"keyword\">int</span> v;</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">v = S.<span class=\"built_in\">top</span>(), S.<span class=\"built_in\">pop</span>(), color[v] = scc, ++ cnt[scc], InStack[v] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (u != v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">SPFA</span><span class=\"params\">(Graph&amp; G, <span class=\"keyword\">bool</span> * mark, <span class=\"keyword\">int</span> * TnT)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(vis));</span><br><span class=\"line\">q.<span class=\"built_in\">push</span>(color[<span class=\"number\">1</span>]);</span><br><span class=\"line\">TnT[color[<span class=\"number\">1</span>]] = cnt[color[<span class=\"number\">1</span>]];</span><br><span class=\"line\">mark[color[<span class=\"number\">1</span>]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (q.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">u</span><span class=\"params\">(q.front())</span></span>;</span><br><span class=\"line\">q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">vis[u] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(G.head[u]); i; i = G.e[i].nxt) &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">v</span><span class=\"params\">(G.e[i].to)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!mark[v] || TnT[u] + cnt[v] &gt; TnT[v]) &#123;</span><br><span class=\"line\">TnT[v] = TnT[u] + cnt[v], mark[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!vis[v]) q.<span class=\"built_in\">push</span>(v), vis[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">int n(read()), m(read()), u, v;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (m --)</span><br><span class=\"line\">    u = <span class=\"built_in\">read</span>(), v = <span class=\"built_in\">read</span>(), G1.<span class=\"built_in\">AddEdge</span>(u, v);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(<span class=\"number\">1</span>); i &lt;= n; ++ i) <span class=\"keyword\">if</span> (!dfn[i]) <span class=\"built_in\">Tarjan</span>(i);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">u</span>(<span class=\"number\">1</span>); u &lt;= n; ++ u)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(G1.head[u]); i; i = G1.e[i].nxt) &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">v</span><span class=\"params\">(G1.e[i].to)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (color[u] != color[v])</span><br><span class=\"line\">        G2.<span class=\"built_in\">AddEdge</span>(color[u], color[v]), G3.<span class=\"built_in\">AddEdge</span>(color[v], color[u]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">SPFA</span>(G2, mark, QAQ), <span class=\"built_in\">SPFA</span>(G3, mark2, QwQ);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ans</span><span class=\"params\">(cnt[color[<span class=\"number\">1</span>]])</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">u</span>(<span class=\"number\">1</span>); u &lt;= scc; ++ u) <span class=\"keyword\">if</span> (mark2[u])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> <span class=\"built_in\">i</span>(G2.head[u]); i; i = G2.e[i].nxt)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mark[G2.e[i].to]) ans = <span class=\"built_in\">max</span>(ans, QwQ[u] + QAQ[G2.e[i].to] - cnt[color[<span class=\"number\">1</span>]]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["图论"],"tags":["SPFA","缩点"]},{"title":"从零建设自己的Hexo博客（一）：搭建","url":"/2020/11/29/HexoBlog/","content":"<p>作为一个萌（傻）新（逼），搭建这个博客花了我整整两天时间。其实搭建个人博客的步骤并不少，但是只要肯百度，<del>乱搞</del>总能找到适合自己的系统环境的搭建方法。</p>\n<p><strong>我的系统：Win10</strong></p>\n<span id=\"more\"></span>\n<h1 id=\"为什么要搭建自己的个人博客：\"><a href=\"#为什么要搭建自己的个人博客：\" class=\"headerlink\" title=\"为什么要搭建自己的个人博客：\"></a>为什么要搭建自己的个人博客：</h1><p>第三方博客（CSDN，博客园等）有什么不好的吗？</p>\n<p>没有什么不好，但是在自己的博客里还是有好处的：</p>\n<ul>\n<li>可以装*</li>\n<li>可以装B</li>\n<li>可以装逼</li>\n</ul>\n<p><del>当然是开玩笑的啦</del>，除了装逼，当然会更加的自由，不受约束，自己的博客交上去不用通过审核啥的，界面随自己的想法调整，<del>可以进行辱骂（不是</del>……好处还是很多的。如果你是一个程序员or我这种OIer，就更没有理由不自己动手搭建<del>狗窝</del>博客了。</p>\n<h1 id=\"为什么使用Hexo？\"><a href=\"#为什么使用Hexo？\" class=\"headerlink\" title=\"为什么使用Hexo？\"></a>为什么使用Hexo？</h1><p>Hexo框架专门搭建博客，非常轻巧，有非常多的主题。并且不像WordPress那样重，除了对LaTeX公式不太支持（其实支持，只不过只能用KaTeX，如果非要用标准LaTeX不仅使用的博客主题受限还卡）以外都很好用。</p>\n<h1 id=\"在本地搭建博客\"><a href=\"#在本地搭建博客\" class=\"headerlink\" title=\"在本地搭建博客\"></a>在本地搭建博客</h1><p>首先下载<code>node.js</code>，如果没有下载<a href=\"https://jingyan.baidu.com/article/375c8e19f2918b25f2a22982.html\">左转百度经验</a>，这个十分简单，不再赘述。</p>\n<p>Git什么的自己下就行，可能会有亿点点卡，但是不会卡死，等个十分钟也就好了。不会的朋友<a href=\"https://jingyan.baidu.com/article/4ae03de3c5ba323eff9e6b00.html\">出门右转</a></p>\n<p><code>node.js</code>和<code>Git</code>下好以后一路Next就好。</p>\n<p>下载好以后，<strong>我们需要配置环境变量。</strong></p>\n<p>首先，点击”此电脑”：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201129131907909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p2cnVvX3NoYWJp,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>然后最左边的那一栏会出现一个此电脑，鼠标右键单击它：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201129132114353.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p2cnVvX3NoYWJp,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>点击红色圈圈那里的”属性”</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201129132259334.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p2cnVvX3NoYWJp,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>点击红色圈里的”高级系统设置”</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201129132405898.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p2cnVvX3NoYWJp,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>点击”环境变量”。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201129132629446.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p2cnVvX3NoYWJp,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>选中Path变量，点击”编辑”（对姓名部分做了处理）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201129132906454.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p2cnVvX3NoYWJp,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>将黄色标出的三个环境变量加进去即可，对姓名做了很不美观的处理哈哈哈（在你的电脑上，nodejs和Git的安装路径可能稍有不同）。</p>\n<p>然后就是重点了：请出我们的主角Hexo。</p>\n<p><a href=\"https://hexo.io/\">链接</a></p>\n<p>网站可能会有点卡，进去了不要乱点，按Windows+R键，输入<code>npm install hexo-cli -g</code>，回车。</p>\n<p>此时会弹出一个窗口，耐心地等它安装，如果卡死了反复尝试一下。</p>\n<p>然后，在任意位置（最好不是C盘）新建一个文件夹，比如叫my_blog。</p>\n<p>然后按住shift键，右击这个my_blog文件夹，打开PowerShell窗口。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201129133429992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p2cnVvX3NoYWJp,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>依次输入命令：</p>\n<p><code>hexo init</code></p>\n<p><code>hexo g</code></p>\n<p><code>hexo s</code></p>\n<p>在浏览器访问<code>localhost:4000</code>，就可以看到你的博客了！</p>\n<p><del>是不是很简单</del></p>\n<h1 id=\"让博客支持LaTeX\"><a href=\"#让博客支持LaTeX\" class=\"headerlink\" title=\"让博客支持LaTeX\"></a>让博客支持LaTeX</h1><p>我们把主题换成目前最流行的NexT，可以去 <a href=\"https://hexo.io/theme\">这儿</a> 看到所有主题，<a href=\"https://github.com/iissnan/hexo-theme-next\">这里</a>下载目前最流行的next主题。如果下载了其他的主题<strong>可能</strong>会遇到各种奇奇怪怪的问题，而且NexT主题有极强的可扩展 性，简介，留给博主的创造空间很大，样式丰富，虽然初看起来没有默认主题美观，但是特别利于后期美化。我的这个blog就是NexT主题<strong>初步</strong>美化后的效果。</p>\n<p>然后，打开<code>my_blog/_config.yml</code>文件，直接用记事本打开就行。</p>\n<p>把 <code>#Site</code> 那一栏改为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">title: 你的博客标题</span><br><span class=\"line\">subtitle: 副标题</span><br><span class=\"line\">description: 博客描述</span><br><span class=\"line\">keywords: 博客关键字</span><br><span class=\"line\">author: 作者</span><br><span class=\"line\">language: zh_CN</span><br><span class=\"line\">timezone: <span class=\"string\">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>再往下翻到最底，会有这样一段：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https:<span class=\"comment\">//hexo.io/plugins/</span></span><br><span class=\"line\">## Themes: https:<span class=\"comment\">//hexo.io/themes/</span></span><br><span class=\"line\">theme: landscape</span><br></pre></td></tr></table></figure>\n<p>把<code>landscape</code>改为<code>next</code>即可。</p>\n<p>如何让博客支持LaTeX？网上有很多文章，第一种是使用mathjax，它支持标准的LaTeX，并且字体美观，缺点就是加载实在太慢。我的blog用的是KaTeX$，参考<a href=\"https://blog.csdn.net/appleyuchi/article/details/92795620\">这里</a>，我就不再赘述（这篇文章说的是yelee 主题，实际上啥主题都行）</p>\n<p>UPD：我的博客换成mathjax渲染，原因很可笑，仅仅是因为mathjax的渲染字体好看一点。</p>\n<p>UPD：又换回了KaTeX，因为mathjax的加载速度实在是令人无法忍受……</p>\n<h1 id=\"部署你的博客\"><a href=\"#部署你的博客\" class=\"headerlink\" title=\"部署你的博客\"></a>部署你的博客</h1><p>然后，注册一个Github账号（如果你没有的话），新建一个仓库，名为<code>你的用户名.github.io</code>。</p>\n<p>然后，将<code>my_blog/_config.yml</code>最后一段改为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https:<span class=\"comment\">//hexo.io/docs/one-command-deployment</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: 你的仓库网址.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>在<code>my_blog</code>打开Powershell窗口，依次执行命令：</p>\n<p><code>hexo clean</code></p>\n<p><code>hexo g</code></p>\n<p><code>hexo d</code></p>\n<p>执行<code>hexo d</code>可能会出现一堆Warn，不要管，然后会弹出一个小窗口，输入你的Github用户名和密码即可。</p>\n<p>然后，如果出现了登录失败<code>logon failed</code> 的提示，再次输入用户名，回车，输入密码（输入密码的时候为了隐私保护不会回显，自己 输就行了），回车，等待出现类似</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Enumerating objects: <span class=\"number\">35</span>, done.</span><br><span class=\"line\">Counting objects: <span class=\"number\">100</span>% (<span class=\"number\">35</span>/<span class=\"number\">35</span>), done.</span><br><span class=\"line\">Delta compression <span class=\"keyword\">using</span> up to <span class=\"number\">6</span> threads</span><br><span class=\"line\">Compressing objects: <span class=\"number\">100</span>% (<span class=\"number\">11</span>/<span class=\"number\">11</span>), done.</span><br><span class=\"line\">Writing objects: <span class=\"number\">100</span>% (<span class=\"number\">18</span>/<span class=\"number\">18</span>), <span class=\"number\">9.07</span> KiB | <span class=\"number\">1.29</span> MiB/s, done.</span><br><span class=\"line\">Total <span class=\"number\">18</span> (delta <span class=\"number\">6</span>), reused <span class=\"number\">0</span> (delta <span class=\"number\">0</span>)</span><br><span class=\"line\">remote: Resolving deltas: <span class=\"number\">100</span>% (<span class=\"number\">6</span>/<span class=\"number\">6</span>), completed with <span class=\"number\">1</span> local object.</span><br><span class=\"line\">To https:<span class=\"comment\">//github.com/ioiakzqs/ioiakzqs.github.io.git</span></span><br><span class=\"line\">   ec007fc..dfa41c2  HEAD -&gt; master</span><br><span class=\"line\">Branch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;https://github.com/ioiakzqs/ioiakzqs.github.io.git&#x27;.</span><br><span class=\"line\">[<span class=\"number\">39</span>m</span><br></pre></td></tr></table></figure>\n<p>的字样，就说明你大功告成了！你的博客网址将会是：<code>你的Github用户名.github.io</code></p>\n","categories":["业余开发"],"tags":["搭建博客"]}]